-- MySQL dump 10.13  Distrib 5.7.17, for osx10.12 (x86_64)
--
-- Host: db02.wsl.mind.meiji.ac.jp    Database: search_degital_library
-- ------------------------------------------------------
-- Server version	5.7.20-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `books`
--

DROP TABLE IF EXISTS `books`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `books` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL,
  `created` datetime NOT NULL,
  `modified` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=104 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `books`
--

LOCK TABLES `books` WRITE;
/*!40000 ALTER TABLE `books` DISABLE KEYS */;
INSERT INTO `books` VALUES (1,'リーダブルコード','2017-11-20 15:02:14','2017-11-20 15:02:14'),(2,'イラストで学ぶ情報理論の考え方','2017-11-20 15:38:31','2017-11-20 15:38:31'),(3,'劣モジュラ最適化と機械学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(4,'機械学習のための確率と統計','2017-11-20 15:38:31','2017-11-20 15:38:31'),(5,'Pythonからはじめる数学入門','2017-11-20 15:38:31','2017-11-20 15:38:31'),(6,'徹底攻略CiscoCCNA CCENT教科書IDND1編','2017-11-20 15:38:31','2017-11-20 15:38:31'),(7,'線形代数講義','2017-11-20 15:38:31','2017-11-20 15:38:31'),(8,'深層学習による自然言語処理','2017-11-20 15:38:31','2017-11-20 15:38:31'),(9,'戦略的データサイエンス入門','2017-11-20 15:38:31','2017-11-20 15:38:31'),(10,'関係データ学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(11,'バンディット問題の理論とアルゴリズム','2017-11-20 15:38:31','2017-11-20 15:38:31'),(12,'一般化線形モデル入門','2017-11-20 15:38:31','2017-11-20 15:38:31'),(13,'統計的学習の基礎 データマイニング・推論・予測','2017-11-20 15:38:31','2017-11-20 15:38:31'),(14,'マスタリングTCP IP_情報セキュリティ編','2017-11-20 15:38:31','2017-11-20 15:38:31'),(15,'IPythonデータサイエンスクックブック','2017-11-20 15:38:31','2017-11-20 15:38:31'),(16,'Pythonではじめる機械学習（scikit-learnで学ぶ特徴量エンジニアリングと機械学習の基礎）','2017-11-20 15:38:31','2017-11-20 15:38:31'),(17,'Cによる探索プログラミング','2017-11-20 15:38:31','2017-11-20 15:38:31'),(18,'Pythonによるデータ分析入門','2017-11-20 15:38:31','2017-11-20 15:38:31'),(19,'初歩から学ぶ統計的学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(20,'UMLモデリングのエッセンス_第3版','2017-11-20 15:38:31','2017-11-20 15:38:31'),(21,'マスタリングTCPIP 入門編 第5版','2017-11-20 15:38:31','2017-11-20 15:38:31'),(22,'Gitによるバージョン管理','2017-11-20 15:38:31','2017-11-20 15:38:31'),(23,'独習Java_第4版','2017-11-20 15:38:31','2017-11-20 15:38:31'),(24,'Scalaスケーリングプログラミング','2017-11-20 15:38:31','2017-11-20 15:38:31'),(25,'メタプログラミング Ruby','2017-11-20 15:38:31','2017-11-20 15:38:31'),(26,'ディジタル画像処理','2017-11-20 15:38:31','2017-11-20 15:38:31'),(27,'アンサンブル機械学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(28,'実践機械学習システム','2017-11-20 15:38:31','2017-11-20 15:38:31'),(29,'WEBマーケティング111の技','2017-11-20 15:38:31','2017-11-20 15:38:31'),(30,'生命情報処理における機械学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(31,'ウェブデータの機械学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(32,'PythonユーザのためのJupyter[実践]入門','2017-11-20 15:38:31','2017-11-20 15:38:31'),(33,'データ解析におけるプライバシー保護','2017-11-20 15:38:31','2017-11-20 15:38:31'),(34,'深層学習（人工知能学会監修）','2017-11-20 15:38:31','2017-11-20 15:38:31'),(35,'力のつく微分積分-1変数の微積分','2017-11-20 15:38:31','2017-11-20 15:38:31'),(36,'明解演習線形代数','2017-11-20 15:38:31','2017-11-20 15:38:31'),(37,'イラストで学ぶ機械学習','2017-11-20 15:38:31','2017-11-20 15:38:31'),(38,'Ruby on Rails4アプリケーションプログラミング','2017-11-20 15:38:31','2017-11-20 15:38:31'),(39,'Rubyのしくみ','2017-11-20 15:38:31','2017-11-20 15:38:31'),(40,'機械学習のための連続最適化','2017-11-20 15:38:31','2017-11-20 15:38:31'),(41,'統計的因果探索','2017-11-20 15:38:31','2017-11-20 15:38:31'),(42,'初めてのRuby','2017-11-20 15:38:31','2017-11-20 15:38:31'),(43,'定性的データ分析','2017-11-20 15:38:31','2017-11-20 15:38:31'),(44,'ヒューマンコンピュテーションとクラウドソーシング','2017-11-20 15:38:31','2017-11-20 15:38:31'),(45,'初めてのJavaScript','2017-11-20 15:38:31','2017-11-20 15:38:31'),(46,'PythonによるWebスクレイピング','2017-11-20 15:38:31','2017-11-20 15:38:31'),(47,'入門Python3','2017-11-20 15:38:31','2017-11-20 15:38:31'),(48,'入門Python2&3対応','2017-11-20 15:38:31','2017-11-20 15:38:31'),(49,'異常検知と変化検知','2017-11-20 15:38:32','2017-11-20 15:38:32'),(51,'一般化線形モデル（統計解析スタンダード）','2017-11-20 15:38:32','2017-11-20 15:38:32'),(52,'Chainer v2による実践深層学習','2017-11-20 15:38:32','2017-11-20 15:38:32'),(53,'[改訂第4版オールカラーHTMLポケットリファレンス]','2017-11-20 15:38:32','2017-11-20 15:38:32'),(54,'画像認識','2017-11-20 15:38:32','2017-11-20 15:38:32'),(55,'統計的学習理論','2017-11-20 15:38:32','2017-11-20 15:38:32'),(56,'入門git','2017-11-20 15:38:32','2017-11-20 15:38:32'),(57,'論理設計 スイッチング回路理論','2017-11-20 15:38:32','2017-11-20 15:38:32'),(58,'Docker','2017-11-20 15:38:32','2017-11-20 15:38:32'),(59,'Python文法詳解','2017-11-20 15:38:32','2017-11-20 15:38:32'),(60,'変分ベイズ学習','2017-11-20 15:38:32','2017-11-20 15:38:32'),(61,'マーケティング・データ分析の基礎','2017-11-20 15:38:32','2017-11-20 15:38:32'),(62,'ノンパラメトリックベイズ','2017-11-20 15:38:32','2017-11-20 15:38:32'),(63,'質問応答システム','2017-11-20 15:38:32','2017-11-20 15:38:32'),(64,'ゼロから作るDeepLearning Pythonで学ぶディープラーニングの理論と実装','2017-11-20 15:38:32','2017-11-20 15:38:32'),(65,'入門自然言語処理','2017-11-20 15:38:32','2017-11-20 15:38:32'),(66,'Javaで学ぶ遺伝的アルゴリズム','2017-11-20 15:38:32','2017-11-20 15:38:32'),(67,'チャート式DUAL SCOPE デュアルスコープ総合英語','2017-11-20 15:38:32','2017-11-20 15:38:32'),(68,'入門機械学習','2017-11-20 15:38:32','2017-11-20 15:38:32'),(69,'SQL書き方ドリル','2017-11-20 15:38:32','2017-11-20 15:38:32'),(70,'ゲーム開発者のためのAI入門','2017-11-20 15:38:32','2017-11-20 15:38:32'),(71,'遺伝的プログラミング','2017-11-20 15:38:32','2017-11-20 15:38:32'),(72,'Pythonベースの活用レシピ60+ TensorFlow 機械学習クックブック','2017-11-20 15:38:32','2017-11-20 15:38:32'),(73,'デ−タサイエンティスト養成読本 登竜門編','2017-11-20 15:38:32','2017-11-20 15:38:32'),(74,'ゼロからはじめるデータサイエンス Pythonで学ぶ基本と実践','2017-11-20 15:38:32','2017-11-20 15:38:32'),(75,'コンピュータサイエンス教科書シリーズ15 離散数学','2017-11-20 15:38:32','2017-11-20 15:38:32'),(76,'新版_数理計画入門','2017-11-20 15:38:32','2017-11-20 15:38:32'),(77,'わかりやすい数理統計の基礎','2017-11-20 15:38:32','2017-11-20 15:38:32'),(78,'Python機械学習プログラミング','2017-11-20 15:38:32','2017-11-20 15:38:32'),(79,'オンライン予測','2017-11-20 15:38:32','2017-11-20 15:38:32'),(80,'PythonとJavaScriptではじめるデータビジュアライゼーション','2017-11-20 15:38:32','2017-11-20 15:38:32'),(81,'明解C言語_入門編','2017-11-20 15:38:32','2017-11-20 15:38:32'),(88,'プログラミングのための線形代数','2017-11-24 08:40:51','2017-11-24 08:40:51'),(89,'プログラミングのための確率統計','2017-11-24 08:45:14','2017-11-24 08:45:14'),(90,'ベクトル解析-キャンパス・ゼミ-','2017-12-03 18:17:39','2017-12-03 18:17:39'),(91,'線形代数-キャンパス・ゼミ-','2017-12-03 18:18:45','2017-12-03 18:18:45'),(92,'OpenCV','2017-12-03 18:18:54','2017-12-03 18:18:54'),(93,'統計学-キャンパス・ゼミ-','2017-12-03 18:23:53','2017-12-03 18:23:53'),(94,'微分積分-キャンパス・ゼミ-','2017-12-03 18:23:58','2017-12-03 18:23:58'),(95,'統計のための数学入門30講','2017-12-05 22:21:36','2017-12-05 22:21:36'),(97,'Pythonで体験するベイズ推論','2017-12-06 02:06:41','2017-12-06 02:06:41'),(98,'データ分析のための機械学習入門','2017-12-06 02:06:49','2017-12-06 02:06:49'),(99,'詳解Apache Spark','2017-12-12 02:10:12','2017-12-12 02:10:12'),(100,'Fluent Python','2017-12-12 02:11:23','2017-12-12 02:11:23'),(101,'Pythonによるスクレイピング&機械学習','2017-12-18 21:33:00','2017-12-18 21:33:00'),(103,'Pythonによる機械学習入門','2017-12-18 21:42:53','2017-12-18 21:42:53');
/*!40000 ALTER TABLE `books` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `books_categories`
--

DROP TABLE IF EXISTS `books_categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `books_categories` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `book_id` int(11) NOT NULL,
  `category_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `book_id` (`book_id`),
  KEY `category_id` (`category_id`),
  CONSTRAINT `books_categories_ibfk_1` FOREIGN KEY (`book_id`) REFERENCES `books` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `books_categories_ibfk_2` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=130 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `books_categories`
--

LOCK TABLES `books_categories` WRITE;
/*!40000 ALTER TABLE `books_categories` DISABLE KEYS */;
INSERT INTO `books_categories` VALUES (1,11,10),(2,5,6),(3,16,6),(4,47,6),(5,59,6),(6,80,6),(7,8,7),(8,34,7),(9,52,7),(10,15,12),(11,25,17),(12,39,17),(13,3,3),(14,1,20),(15,54,21),(16,70,25),(17,23,16),(18,3,2),(19,16,2),(20,27,2),(21,28,2),(23,54,2),(24,79,2),(25,2,1),(26,8,8),(27,65,8),(28,79,26),(29,17,13),(30,81,13),(31,4,4),(32,19,4),(33,69,23),(34,69,24),(35,14,11),(36,21,11),(37,58,11),(38,18,14),(39,58,22),(40,52,19),(41,5,5),(42,7,5),(43,12,5),(44,22,15),(45,45,18),(46,9,9),(47,15,9),(48,43,9),(49,73,9),(50,74,9),(57,46,42),(61,42,17),(63,55,4),(64,60,51),(65,40,3),(68,89,55),(69,88,5),(70,79,56),(71,60,56),(72,62,56),(73,55,56),(74,40,56),(75,74,57),(76,59,57),(77,59,57),(78,65,57),(79,65,57),(80,51,4),(81,64,57),(82,54,58),(83,54,58),(84,49,58),(85,30,2),(86,41,56),(87,75,5),(88,8,58),(89,78,2),(90,80,18),(91,24,60),(92,32,12),(93,63,61),(94,5,57),(95,15,57),(96,42,57),(97,4,55),(98,80,57),(99,36,5),(101,94,63),(102,93,63),(103,91,63),(104,90,63),(105,97,51),(106,98,2),(107,95,4),(108,94,5),(110,93,4),(111,91,5),(112,95,5),(122,62,51),(124,72,59),(125,97,6),(126,98,9),(128,100,6),(129,99,65);
/*!40000 ALTER TABLE `books_categories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `categories`
--

DROP TABLE IF EXISTS `categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `categories` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL,
  `created` datetime NOT NULL,
  `modified` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=66 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categories`
--

LOCK TABLES `categories` WRITE;
/*!40000 ALTER TABLE `categories` DISABLE KEYS */;
INSERT INTO `categories` VALUES (1,'情報理論','2017-11-20 15:40:10','2017-11-20 15:40:10'),(2,'機械学習','2017-11-20 15:40:10','2017-11-20 15:40:10'),(3,'最適化','2017-11-20 15:40:10','2017-11-20 15:40:10'),(4,'統計','2017-11-20 15:40:10','2017-11-20 15:40:10'),(5,'数学','2017-11-20 15:40:10','2017-11-20 15:40:10'),(6,'python','2017-11-20 15:40:10','2017-11-20 15:40:10'),(7,'深層学習','2017-11-20 15:40:10','2017-11-20 15:40:10'),(8,'自然言語処理','2017-11-20 15:40:10','2017-11-20 15:40:10'),(9,'データサイエンス','2017-11-20 15:40:10','2017-11-20 15:40:10'),(10,'強化学習','2017-11-20 15:40:10','2017-11-20 15:40:10'),(11,'インフラ','2017-11-20 15:40:10','2017-11-20 15:40:10'),(12,'Jupyter','2017-11-20 15:40:10','2017-11-20 15:40:10'),(13,'C言語','2017-11-20 15:40:10','2017-11-20 15:40:10'),(14,'データ分析','2017-11-20 15:40:10','2017-11-20 15:40:10'),(15,'github','2017-11-20 15:40:10','2017-11-20 15:40:10'),(16,'java','2017-11-20 15:40:10','2017-11-20 15:40:10'),(17,'ruby','2017-11-20 15:40:10','2017-11-20 15:40:10'),(18,'JavaScript','2017-11-20 15:40:10','2017-11-20 15:40:10'),(19,'chainer','2017-11-20 15:40:10','2017-11-20 15:40:10'),(20,'コード書き方','2017-11-20 15:40:10','2017-11-20 15:40:10'),(21,'画像','2017-11-20 15:40:10','2017-11-20 15:40:10'),(22,'docker','2017-11-20 15:40:10','2017-11-20 15:40:10'),(23,'SQL','2017-11-20 15:40:10','2017-11-20 15:40:10'),(24,'データベース','2017-11-20 15:40:10','2017-11-20 15:40:10'),(25,'ゲーム','2017-11-20 15:40:10','2017-11-20 15:40:10'),(26,'オンライン学習','2017-11-20 15:40:10','2017-11-20 15:40:10'),(42,'スクレイピング','2017-11-21 16:50:58','2017-11-21 16:50:58'),(51,'ベイズ','2017-11-23 13:46:54','2017-11-23 13:46:54'),(55,'確率','2017-11-24 10:10:54','2017-11-24 10:10:54'),(56,'青本','2017-11-27 01:32:01','2017-11-27 01:32:01'),(57,'オライリー','2017-11-27 08:33:23','2017-11-27 08:33:23'),(58,'赤本','2017-11-27 08:35:36','2017-11-27 08:35:36'),(59,'tensorflow','2017-11-27 08:43:15','2017-11-27 08:43:15'),(60,'scala','2017-11-27 08:43:34','2017-11-27 08:43:34'),(61,'自然言語','2017-11-27 08:45:32','2017-11-27 08:45:32'),(63,'宗政おすすめ','2017-12-06 03:49:51','2017-12-06 03:49:51'),(65,'spark','2017-12-17 01:37:50','2017-12-17 01:37:50');
/*!40000 ALTER TABLE `categories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `pages`
--

DROP TABLE IF EXISTS `pages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `pages` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `book_id` int(11) NOT NULL,
  `number` int(11) DEFAULT NULL,
  `raw_text` text,
  `parsed_text` text,
  `created` datetime NOT NULL,
  `modified` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `book_id` (`book_id`),
  CONSTRAINT `pages_ibfk_1` FOREIGN KEY (`book_id`) REFERENCES `books` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=247 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `pages`
--

LOCK TABLES `pages` WRITE;
/*!40000 ALTER TABLE `pages` DISABLE KEYS */;
INSERT INTO `pages` VALUES (1,1,0,'／ＴＨＥＯＲＹ／１Ｎ／ＰＲＡＣＴＩＣＥ\n\nダブルコ 一ド\n\nより良いコードを書くための\nシンプルで実践的なテクニック\n\n戸\n\n、 （」\n\n、\n\n１\n\nＬＬ\n\n可\n\nDustin\nTrevor\n\nBosweil\nFoucher 言\n訳\n角 征 典\n\n○\'REILDT\n\nオライリー･ジャパン\n\n。\nʼ\n\n','ＴＨＥＯＲＹＮＰＲＡＣＴＩＣＥ  ダブルコ 一ド  より良いコードを書くための シンプルで実践的なテクニック  戸  、 」  、    ＬＬ  可  Dustin Trevor  Bosweil Foucher 言 訳 角 征 典  ○\'REILDT  オライリー･ジャパン  。 ʼ  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(2,1,1,'雷\n\n一\n\n一\n\n…\n\n\'\n正撒EOmSBB蟻懸溌A(cid:20273)職溌(cid:7688)\n\n(cid:7785)聴\n\n(cid:7683)急熱難舗\n\n̅\n\n○ﾂREILLY\'\n\nオライリー･ジャパン\n\n','雷  一  一  …  \' 正撒EOmSBB蟻懸溌A(cid:)職溌(cid:)  (cid:)聴  (cid:)急熱難舗  ̅  ○ﾂREILLY\'  オライリー･ジャパン  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(3,1,2,'リーダブルコード\nより良いコードを書くための\nシンプルで実践的なテクニック\n\nDustin  Boswe皿著\nTrevor Foucher\n角 征 典 訳\n\n○\'REILLYR\n\nオライリー･ジャパン\n\n','リーダブルコード より良いコードを書くための シンプルで実践的なテクニック  Dustin  Boswe皿著 Trevor Foucher 角 征 典 訳  ○\'REILLYR  オライリー･ジャパン  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(4,1,3,'本書で使用するシステム名、製品名は、それぞれ各社の商標、または登録商標です〈\nなお、本文中ではnM，③、◎マークは省略しています。\n\nO\n\n','本書で使用するシステム名、製品名は、それぞれ各社の商標、または登録商標です〈 なお、本文中ではnM③、◎マークは省略しています。  O  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(5,1,4,'The Art of Readable Code\n\nDustin Bosweil and Trevor Foucher\n\n○\'REILLYR\nBeijin9・〔ambrid9e・Farnham・Koln・Sebastopol・Tokyo\n\n','The Art of Readable Code  Dustin Bosweil and Trevor Foucher  ○\'REILLYR Beijin・〔ambride・Farnham・Koln・Sebastopol・Tokyo  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(6,1,5,'◎2012 O\'Reilly Japan, Inc. Authorized Japanese translation of the English edition of \"The Art of\nReadable Code\". c 2012 Dustin Bosweil and Trevor Foucher. This translation is published and sold\nby permission of O\'Reilly Media, Inc., the owner of all rights to publish and sell the same.\n\n本書は、株式会社オライリー・ジャパンがO\'Reilly  Media,  Inc.との許諾に基づき翻訳したものです。\n日本語版についての権利は、株式会社オライリー・ジャパンが保有します。\n\n日本語版の内容について、株式会社オライリー・ジャパンは最大限の努力をもって正確を期していま\nすが、本書の内容に基づく運用結果について責任を負いかねますので、ご了承ください。\n\n','◎ O\'Reilly Japan, Inc. Authorized Japanese translation of the English edition of \"The Art of Readable Code\". c  Dustin Bosweil and Trevor Foucher. This translation is published and sold by permission of O\'Reilly Media, Inc., the owner of all rights to publish and sell the same.  本書は、株式会社オライリー・ジャパンがO\'Reilly  Media,  Inc.との許諾に基づき翻訳したものです。 日本語版についての権利は、株式会社オライリー・ジャパンが保有します。  日本語版の内容について、株式会社オライリー・ジャパンは最大限の努力をもって正確を期していま すが、本書の内容に基づく運用結果について責任を負いかねますので、ご了承ください。  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(7,1,6,'V\n\n訳者まえがき\n\n本書は、\"Dustin Bosweil and Trevor Foucher, The Art of Readable Code, O\'Reilly\nMedia, Inc., 2011\"の全訳である。底本には書籍とSafari Books Onlineの電子版を使\n用した。\n\n面白いと、読みやすいは、違うんだよ？\nタイトルが示すとおり、本書のテーマは「読みやすいコード」である。「読みやす\nい」と聞いてすぐに思い浮かぶのは、島本和彦『アオイホノオ』（小学館）７巻に出\nてくるセリフだ（くしくも原書と同じ2011/11に発売されている)。\n\n｢面白いと、読みやすいは、違うんだよ？」\n\n「読みやすい」コードを書くのに「面白い」ことをする必要はない。いい名前をつ\nける。適切なコメントを書く。意味のある単位に分割する。キレイに整形する。こう\nした基本的なことを着実にやればいい。このことを丁寧に説明してくれるのが本書で\nある。\n\nあまりにも基本的なことなので、地味な内容じゃないかと心配された人がいるかも\nしれない。Amazon.comには「Nothing  New  (別に普通じゃん)」とのレビューもあ\nる。でも、心配しなくていい。本書は「面白い｣。\nやらんもんは…勝たれへん１１\n本書が面白いのは、アドバイスの仕方がいいからだと思う。よくありがちな「コー\nドはこう書きなさい」という説教じみたものじゃなく、かといってふざけたものでも\n\n','V  訳者まえがき  本書は、\"Dustin Bosweil and Trevor Foucher, The Art of Readable Code, O\'Reilly Media, Inc., \"の全訳である。底本には書籍とSafari Books Onlineの電子版を使 用した。  面白いと、読みやすいは、違うんだよ タイトルが示すとおり、本書のテーマは「読みやすいコード」である。「読みやす い」と聞いてすぐに思い浮かぶのは、島本和彦『アオイホノオ』小学館巻に出 てくるセリフだくしくも原書と同じ/に発売されている)。  ｢面白いと、読みやすいは、違うんだよ」  「読みやすい」コードを書くのに「面白い」ことをする必要はない。いい名前をつ ける。適切なコメントを書く。意味のある単位に分割する。キレイに整形する。こう した基本的なことを着実にやればいい。このことを丁寧に説明してくれるのが本書で ある。  あまりにも基本的なことなので、地味な内容じゃないかと心配された人がいるかも しれない。Amazon.comには「Nothing  New  (別に普通じゃん)」とのレビューもあ る。でも、心配しなくていい。本書は「面白い｣。 やらんもんは…勝たれへん 本書が面白いのは、アドバイスの仕方がいいからだと思う。よくありがちな「コー ドはこう書きなさい」という説教じみたものじゃなく、かといってふざけたものでも  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(8,1,7,'v i 訳 者 ま え が き\n\nなく（挿絵はふざけてるけどな！）、先輩から「こうしたほうがいいよ」と優しくア\nドバイスを受けているような感じがする。説明用のサンプルコードも豊富だし、今日\nからすぐに使えるヒントも満載だ。\n\nまた、あれだけのアドバイスが詰まっていながら、２００ページ以内に収まっている\nというのもいい（訳書は200ページを超えてしまったけど……)。持ち運びに便利だ\nし、これなら読み返そうと思ったときに楽に取り出せる。誰かにコードの書き方を教\nえたことがある人ならわかると思うけど、これは本当にすごいことだ。\n\n「読みやすい」コードを書くことは、「理解しやすい」コードを書くことであり、そ\nの結果として「優れた」コードにつながるという信念も素晴らしい。誰もが優れた\nコードを書きたいと思っている。だけど、そのために何をどうすればいいのかわから\nなくて悩んだりする。でも、その答えが本書に載っていた。「読みやすい」コードを\n書けばいいのだ！！！これなら誰でもパク八H八Ｈマネできる。ここでもまた『ア\nオイホノオ』７巻を引用しよう。\n\n｢やったもん勝ちなんや！！やらんもんは…勝たれへん！」\n\n謝辞\n\n翻訳にあたっては、ReVIEW↑・DocDiff・github・Dropbox・Ｅｍａｃｓ２３,４．\n】Wzzy・ＰＤＩＣ・英辞郎第五版・iAnnotatePDFのお世話になった。開発者のみなさ\nんに感謝したい。著者には丁寧に質問に答えていただいた。編集を担当されたオライ\nリー・ジャパンの高さんには（『ウェブオペレーション』に続いて２度めとなる）翻\n訳の機会を与えていただいた。\n\nまた、今回は尊敬するハッカーの１人に解説をお願いした。これを書いている時\n点ではまだその解説を読んでいないけど、甘いもの好きなのにコードのことになると\n辛口になる人なので、きっと手厳しい解説を書いてくれているはずだ。先に感謝して\nおきたい。須藤さんありがとう。\n\n「読みやすさ」を扱った本の翻訳が読みにくいというのではシャレにならないので、\n翻訳もできるだけ「読みやすく」かつ「優しい先輩がアドバイスするように」訳すこ\nとを心がけた。その過程で、小川伸一郎(cconceal  rs)さん・高木正弘(@takagi)\nさん・三輪晋(@miwarin)さん・鈴木則夫(@  suzuki)さん・artｏｎさん・長永健\n介(@kyanny)さん・大谷和紀(@katzchang)さん・吉羽龍太郎(@ryuzee)さ\nt       https://github.com/kmuto/review\n\n','v i 訳 者 ま え が き  なく挿絵はふざけてるけどな、先輩から「こうしたほうがいいよ」と優しくア ドバイスを受けているような感じがする。説明用のサンプルコードも豊富だし、今日 からすぐに使えるヒントも満載だ。  また、あれだけのアドバイスが詰まっていながら、ページ以内に収まっている というのもいい訳書はページを超えてしまったけど……)。持ち運びに便利だ し、これなら読み返そうと思ったときに楽に取り出せる。誰かにコードの書き方を教 えたことがある人ならわかると思うけど、これは本当にすごいことだ。  「読みやすい」コードを書くことは、「理解しやすい」コードを書くことであり、そ の結果として「優れた」コードにつながるという信念も素晴らしい。誰もが優れた コードを書きたいと思っている。だけど、そのために何をどうすればいいのかわから なくて悩んだりする。でも、その答えが本書に載っていた。「読みやすい」コードを 書けばいいのだこれなら誰でもパク八H八Ｈマネできる。ここでもまた『ア オイホノオ』巻を引用しよう。  ｢やったもん勝ちなんややらんもんは…勝たれへん」  謝辞  翻訳にあたっては、ReVIEW↑・DocDiff・github・Dropbox・Ｅｍａｃｓ, 】Wzzy・ＰＤＩＣ・英辞郎第五版・iAnnotatePDFのお世話になった。開発者のみなさ んに感謝したい。著者には丁寧に質問に答えていただいた。編集を担当されたオライ リー・ジャパンの高さんには『ウェブオペレーション』に続いて度めとなる翻 訳の機会を与えていただいた。  また、今回は尊敬するハッカーの人に解説をお願いした。これを書いている時 点ではまだその解説を読んでいないけど、甘いもの好きなのにコードのことになると 辛口になる人なので、きっと手厳しい解説を書いてくれているはずだ。先に感謝して おきたい。須藤さんありがとう。  「読みやすさ」を扱った本の翻訳が読みにくいというのではシャレにならないので、 翻訳もできるだけ「読みやすく」かつ「優しい先輩がアドバイスするように」訳すこ とを心がけた。その過程で、小川伸一郎(cconceal  rs)さん・高木正弘() さん・三輪晋()さん・鈴木則夫(  suzuki)さん・artｏｎさん・長永健 介()さん・大谷和紀()さん・吉羽龍太郎()さ t         ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(9,1,8,'訳者まえがきI   vii\n\nん・寺嶋基之(@trmmy)さんに、翻訳レビューをしていただいた。少しでも「読み\nやすい」と思ってもらえたら幸いだ。もちろん、読みにくい場合の責任はすべて訳者\nにある。何かあれば、kdmsnr@gmail.comまでご連絡いただきたい。\n\n角征典\n2012年４月\n\n','訳者まえがきI   vii  ん・寺嶋基之()さんに、翻訳レビューをしていただいた。少しでも「読み やすい」と思ってもらえたら幸いだ。もちろん、読みにくい場合の責任はすべて訳者 にある。何かあれば、kdmsnrまでご連絡いただきたい。  角征典 年月  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(10,1,9,'はじめに\n\n！\n\n■ ｄ ■\n\nある日の穂\n\n／\n\n＝\n\n­\n\n一\n\n一\n\n一\n\n一\n\n一\n\n­\n\n2週間後……\n\n可 垂三三三三三\n\n_r蕗＝《刈諭 風\n\n','はじめに    ■ ｄ ■  ある日の穂      ­  一  一  一  一  一  ­  週間後……  可 垂三三三三三  _r蕗《刈諭 風  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(11,1,10,'X は じ め に\n\nぼくたちは大成功を収めたソフトウェア企業で働いてきた。周りにはすごいエンジ\nニアたちがいた。でも、そこで目にするコードには改善の余地があった。なかには本\n当にひどいコードもあった。君も見たことあるんじゃないかな。\n\n美しいコードを見ると感動する。優れたコードは見た瞬間に何をしているかが伝\nわってくる。そういうコードは使うのが楽しいし、自分のコードもそうあるべきだと\n思わせてくれる。\n\n本書の目的は、君のコードをよくすることだ。ぼくたちが「コード」と呼んでいる\nのは、君がエディタで目にするプログラムコードのことだ。本書では、プロジェクト\nの全体アーキテクチャやデザインパターンの話はしない。そういうのも大切だけど、\nプログラマが日常的に時間を費やしているのは、もっと「基本的」なことだと思う。\n例えば、変数に名前をつけたり、ループの処理を書いたり、問題を関数のレベルまで\n分解したり。こうした活動の大部分は、既存のコードの読み書きに費やされている。\n本書が日々のプログラミングのお役に立てば幸いだ。お役に立つようなら、チームの\nメンバにも推薦しておいて欲しい。\n\n本書について\n本書の目的は、読みやすいコードを書くことである。その中心となるのは、コード\nは理解しやすくなければいけないという考えだ。具体的に言えば、誰かが君のコード\nを読んで理解する時間を最短にするということだ。\n\nこの考えを説明するために、本書では、C++・Python・JavaScript・Javaといった\nプログラミング言語を使っている。いずれも応用的な機能は使っていないので、言語\nのことをよく知らなくても難なく読み進められると思う（それに、コードを読みやす\nくする話は言語とは関係ないからね)。\n各章では、さまざまなコードを「理解しやすく」する方法を取り上げている。ま\n\nた、本書は４つの部に分かれている。\n\n第１部表面上の改善\n\n名前・コメント・見た目のようなコード全体に適用できる簡単なヒント\n\n第Ⅱ部ループとロジックの単純化\n\nプログラムのループ・ロジック・変数などを改善して理解しやすくする方法\n\n','X は じ め に  ぼくたちは大成功を収めたソフトウェア企業で働いてきた。周りにはすごいエンジ ニアたちがいた。でも、そこで目にするコードには改善の余地があった。なかには本 当にひどいコードもあった。君も見たことあるんじゃないかな。  美しいコードを見ると感動する。優れたコードは見た瞬間に何をしているかが伝 わってくる。そういうコードは使うのが楽しいし、自分のコードもそうあるべきだと 思わせてくれる。  本書の目的は、君のコードをよくすることだ。ぼくたちが「コード」と呼んでいる のは、君がエディタで目にするプログラムコードのことだ。本書では、プロジェクト の全体アーキテクチャやデザインパターンの話はしない。そういうのも大切だけど、 プログラマが日常的に時間を費やしているのは、もっと「基本的」なことだと思う。 例えば、変数に名前をつけたり、ループの処理を書いたり、問題を関数のレベルまで 分解したり。こうした活動の大部分は、既存のコードの読み書きに費やされている。 本書が日々のプログラミングのお役に立てば幸いだ。お役に立つようなら、チームの メンバにも推薦しておいて欲しい。  本書について 本書の目的は、読みやすいコードを書くことである。その中心となるのは、コード は理解しやすくなければいけないという考えだ。具体的に言えば、誰かが君のコード を読んで理解する時間を最短にするということだ。  この考えを説明するために、本書では、C++・Python・JavaScript・Javaといった プログラミング言語を使っている。いずれも応用的な機能は使っていないので、言語 のことをよく知らなくても難なく読み進められると思うそれに、コードを読みやす くする話は言語とは関係ないからね)。 各章では、さまざまなコードを「理解しやすく」する方法を取り上げている。ま  た、本書はつの部に分かれている。  第部表面上の改善  名前・コメント・見た目のようなコード全体に適用できる簡単なヒント  第Ⅱ部ループとロジックの単純化  プログラムのループ・ロジック・変数などを改善して理解しやすくする方法  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(12,1,11,'は じ め に x i\n\n第Ⅲ部コードの再構成\n\n巨大なコードブロックを再構成して問題を関数のレベルに分解する方法\n\n第Ⅳ部選抜テーマ\n\n「理解しやすさ」をテストや大きなデータ構造に適用する方法\n\n本書の読み方\n本書は楽しく気楽に読んでもらいたい。できれば１〜２週間で読んで欲しい。\n章立ては「難易度」の順番になっている。最初に基本的なテーマを取り上げて、最\n後に応用的なテーマを取り上げている。ただし、各章は独立しているので、どの章か\nらでも読み進められる。好きなように読んでもらって構わない。\n\nライセンスについて\n巻頭の「訳者まえがき」および巻末の「解説」はクリエイティブ・コモンズの表\n示一非営利一継承によって許諾されている。ライセンスの内容は、http://creative\ncommons.org/licenses/by-nc-sa/2.1/jp/で確認できる。原著作者のクレジットは\n｢オライリー・ジャパン」とする。ただし「訳者まえがき」と「解説」以外、また原\n書においてはこのライセンスにはあたらない。\nサンブルコードの使用\n本書の目的は、読者の仕事の手助けをすることだ。本書に掲載したコードは、各自\nのプログラムやドキュメントに使っても構わない。コードの大部分を転載する場合を\n除き、私たちに許可を求める必要はない。例えば、本書のコードを使ったプログラム\nを書くのに許可を求める必要はない。O\'Reillyから出版されている書籍のサンプルを\nCD-ROMとして販売したり配布したりするのには許可が必要だ。本書や本書のコー\nドを引用して質問に答える場合は、許可を求める必要はない。本書のサンプルコード\nの大部分を製品マニュアルに掲載する場合には、そのための許可が必要になる。\n\n作者の帰属を明記する必要はないが、そうしてもらえるとうれしい。帰属を明記\nする際には、\"The Art of Readable Code by Dustin Bosweil and Trevor Foucher.\nCopyright 2012 Dustin Bosweil and Trevor Foucher, 978-0-596-80229-5\"のように、\nタイトル・著者・出版社・ISBNなどを記載して欲しい。\n\nサンプルコードの使用について、正規の使用の枠を超える、またはここで許可した\n\n','は じ め に x i  第Ⅲ部コードの再構成  巨大なコードブロックを再構成して問題を関数のレベルに分解する方法  第Ⅳ部選抜テーマ  「理解しやすさ」をテストや大きなデータ構造に適用する方法  本書の読み方 本書は楽しく気楽に読んでもらいたい。できれば〜週間で読んで欲しい。 章立ては「難易度」の順番になっている。最初に基本的なテーマを取り上げて、最 後に応用的なテーマを取り上げている。ただし、各章は独立しているので、どの章か らでも読み進められる。好きなように読んでもらって構わない。  ライセンスについて 巻頭の「訳者まえがき」および巻末の「解説」はクリエイティブ・コモンズの表 示一非営利一継承によって許諾されている。ライセンスの内容は、 commons.org/licenses/by-nc-sa/./jp/で確認できる。原著作者のクレジットは ｢オライリー・ジャパン」とする。ただし「訳者まえがき」と「解説」以外、また原 書においてはこのライセンスにはあたらない。 サンブルコードの使用 本書の目的は、読者の仕事の手助けをすることだ。本書に掲載したコードは、各自 のプログラムやドキュメントに使っても構わない。コードの大部分を転載する場合を 除き、私たちに許可を求める必要はない。例えば、本書のコードを使ったプログラム を書くのに許可を求める必要はない。O\'Reillyから出版されている書籍のサンプルを CD-ROMとして販売したり配布したりするのには許可が必要だ。本書や本書のコー ドを引用して質問に答える場合は、許可を求める必要はない。本書のサンプルコード の大部分を製品マニュアルに掲載する場合には、そのための許可が必要になる。  作者の帰属を明記する必要はないが、そうしてもらえるとうれしい。帰属を明記 する際には、\"The Art of Readable Code by Dustin Bosweil and Trevor Foucher. Copyright  Dustin Bosweil and Trevor Foucher, ----\"のように、 タイトル・著者・出版社・ISBNなどを記載して欲しい。  サンプルコードの使用について、正規の使用の枠を超える、またはここで許可した  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(13,1,12,'x i i は じ め に\n\n範囲を超えると思ったときには、permissions@oreilly.comまで英語でご連絡をいた\nだきたい。\n謝辞\n貴重な時間を使って本稿のレビューをしてくれたアラン・デビッドソン、ジョン・\nエアリク、ロブ・ケーニヒスベルグ、アーチー・ラッセル、ゲイブ．Ｗ，アサフ・\nツェマックらの同僚たちに感謝したい。本書に何か間違いがあれば、すべて彼らの責\n任だ（冗談だよ)。\n\n詳細なフィードバックをくれたマイケル・フンガー、ジョージ・ヘインマン、\n\nチャック・ハドソンらのレビューアに感謝したい。\n\nまた、ジョン・ブラックバーン、ティム・デシルヴァ、デニス・ヘールズ、ス\nティーブ・ゲルディング、クリス・ハリス、ジョシュ・ハイマン、ジョエル・イング\nラム、エリック・マブリナック、グレッグ・ミラー、アナトール・ペイン、ニック・\nホワイトらからは多くのアイデアやフィードバックをいただいた。O\'Reilly  OFPSシ\nステムの草稿にコメントをくれた多くのオンラインレビューアにも感謝したい。\n\nマリー・トレセラー（エディタ)、テレサ・エルセイ（プロダクションエディタ)、\nナンシー・コタリー（コピーエディタ)、ロブ・ロマノ（イラストレータ)、ジェシ\nカ・ホスマン（ツールズ)、アビー・フォックス（ツールズ）らのO\'Reillyチームの\n辛抱強さとサポートに感謝したい。それから、挿絵を描いてくれたデイヴ・オルレッ\nドは、ぼくたちのアホみたいな考えに命を吹き込んでくれた。\n最後に、メリサとスザンナに感謝したい。終わりの見えないプログラミング談義に\n\n耐えながら、ずっとぼくたちを励ましてくれた。\n\n','x i i は じ め に  範囲を超えると思ったときには、permissionsまで英語でご連絡をいた だきたい。 謝辞 貴重な時間を使って本稿のレビューをしてくれたアラン・デビッドソン、ジョン・ エアリク、ロブ・ケーニヒスベルグ、アーチー・ラッセル、ゲイブＷアサフ・ ツェマックらの同僚たちに感謝したい。本書に何か間違いがあれば、すべて彼らの責 任だ冗談だよ)。  詳細なフィードバックをくれたマイケル・フンガー、ジョージ・ヘインマン、  チャック・ハドソンらのレビューアに感謝したい。  また、ジョン・ブラックバーン、ティム・デシルヴァ、デニス・ヘールズ、ス ティーブ・ゲルディング、クリス・ハリス、ジョシュ・ハイマン、ジョエル・イング ラム、エリック・マブリナック、グレッグ・ミラー、アナトール・ペイン、ニック・ ホワイトらからは多くのアイデアやフィードバックをいただいた。O\'Reilly  OFPSシ ステムの草稿にコメントをくれた多くのオンラインレビューアにも感謝したい。  マリー・トレセラーエディタ)、テレサ・エルセイプロダクションエディタ)、 ナンシー・コタリーコピーエディタ)、ロブ・ロマノイラストレータ)、ジェシ カ・ホスマンツールズ)、アビー・フォックスツールズらのO\'Reillyチームの 辛抱強さとサポートに感謝したい。それから、挿絵を描いてくれたデイヴ・オルレッ ドは、ぼくたちのアホみたいな考えに命を吹き込んでくれた。 最後に、メリサとスザンナに感謝したい。終わりの見えないプログラミング談義に  耐えながら、ずっとぼくたちを励ましてくれた。  ','2017-11-20 15:02:14','2017-11-20 15:02:14'),(14,1,13,'xiii\n\n目 次\n\n訳者まえがき……..….………………………………………………….…..……………………ｖ\nはじめに.………………………………………….………….…….…….……………..…..…….ix\n\n1章\n\n第１部\n２章\n\n理解しやすいコード………………………….….…….………….………...…１\n１．１「優れた」コードって何？………………………………………………………２\n１．２読みやすさの基本定理….………….………………………………………….…３\n１．３小さなことは絶対にいいこと？……….……………………….…….………４\n１．４「理解するまでにかかる時間」は競合する？……………………………４\n１．５でもやるんだよ…….……………………………………………………….………５\n\n表面上の改善……….......….……..…………………………………フ\n名前に情報を詰め込む.…….…….………………….………..………………ｇ\n2.1明確な単語を選ぶ………….…………….………………………………………10\nもっと「カラフル」な単語を探す…………………………………………11\n2.2 tmpやretvalなどの汎用的な名前を避ける…….…….………………１2\nt\nmp………………………………………………………….………………………….13\nルーープイテレータ………………………….…………………………………….１４\n汎用的な名前のまとめ………………………….………………………………15\n2.3抽象的な名前よりも具体的な名前を使う…………………………….…１６\n例: DISALLOW EVIL CONSTRUCTORS…………….……………１7\n例: -runjocally……………….…….………….………………………………18\n2.4名前に情報を追加する……………………………………………………….…１９\n値の単位….………………………………….…………….………………..………20\nその他の重要な属ʼ性を追加する….…………………………………………2１\n\n','xiii  目 次  訳者まえがき……..….………………………………………………….…..……………………ｖ はじめに.………………………………………….………….…….…….……………..…..…….ix  章  第部 章  理解しやすいコード………………………….….…….………….………...… 「優れた」コードって何……………………………………………………… 読みやすさの基本定理….………….………………………………………….… 小さなことは絶対にいいこと……….……………………….…….……… 「理解するまでにかかる時間」は競合する…………………………… でもやるんだよ…….……………………………………………………….………  表面上の改善……….......….……..…………………………………フ 名前に情報を詰め込む.…….…….………………….………..………………ｇ .明確な単語を選ぶ………….…………….……………………………………… もっと「カラフル」な単語を探す………………………………………… . tmpやretvalなどの汎用的な名前を避ける…….…….……………… t mp………………………………………………………….…………………………. ルーープイテレータ………………………….……………………………………. 汎用的な名前のまとめ………………………….……………………………… .抽象的な名前よりも具体的な名前を使う…………………………….… 例: DISALLOW EVIL CONSTRUCTORS…………….…………… 例: -runjocally……………….…….………….……………………………… .名前に情報を追加する……………………………………………………….… 値の単位….………………………………….…………….………………..……… その他の重要な属ʼ性を追加する….…………………………………………  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(15,1,14,'x i v 目 次\n\n３章\n\n４章\n\n2.5\n\n2\n.\n6\n\n2\n.\n7\n\n名前の長さを決める….…………………………………………….……………２２\nスコープが小さければ短い名前でもいい…………………………….…２３\n長い名前を入力するのは問題じゃない……….…………………………２３\n頭文字と省略形……………………………………………………………………２４\n不要な単語を投げ捨てる….……………….…………………………….……２４\n名前のフオーマツトで情報を伝える.….…………………………………２５\nその他のフオーマツト規約………………………………………………….､２６\nまとめ……………………………………………….…………….………….………2６\n\n誤解されない名前.………………….………….…..………..…………….…２９\n３．１例: filterO.………………………………….….………………………………….30\n3.2例: Clip (text, length).….….………………………………………...….……30\n3.3限界値を含めるときはminとｍａｘを使う….…………………………31\n3.4範囲を指定するときはfirstとlastを使う……….…………………….32\n3.5包含／排他的範囲にはbeginとendを使う………………..…………33\n3\n.\n6ブール値の名前……………….…………….……………………….……………33\n7ユーザの期待に合わせる.….…………………….……………………………３４\n3\n.\n例\n: get*()……………………………….………………………………………….34\n例：Ust::size()……….…………………………………………….…….….……35\n3.8例：複数の名前を検討する…………………………………….……….……36\n3\n.\n9まとめ.………………………………………….…….………………………………3９\n\n美しさ………………………………..….………………….…….….….…….….４１\n４．１なぜ美しさが大切なのか？…………….…………………….………………42\n4.2一貫\'性のある簡潔な改行位置…….……………………………….…………44\n4.3メソッドを使った整列….………………………………………………………46\n4.4縦の線をまっすぐにする……….….………………………….………………４７\n整列すべきなのか？…….……………………………………………….………48\n4.5一貫性と意味のある並び………………..……………………………….……49\n4.6宣言をブロックにまとめる.………………….………………………………50\n4.7コードを「段落」に分割する……….……………………………………….51\n4.8個人的な好みと一貫ʻ性……….………………….…………………….…….…5２\n\n','x i v 目 次  章  章  .   .    .   名前の長さを決める….…………………………………………….…………… スコープが小さければ短い名前でもいい…………………………….… 長い名前を入力するのは問題じゃない……….………………………… 頭文字と省略形…………………………………………………………………… 不要な単語を投げ捨てる….……………….…………………………….…… 名前のフオーマツトで情報を伝える.….………………………………… その他のフオーマツト規約………………………………………………….､ まとめ……………………………………………….…………….………….………  誤解されない名前.………………….………….…..………..…………….… 例: filterO.………………………………….….…………………………………. .例: Clip (text, length).….….………………………………………...….…… .限界値を含めるときはminとｍａｘを使う….………………………… .範囲を指定するときはfirstとlastを使う……….……………………. .包含排他的範囲にはbeginとendを使う………………..…………  . ブール値の名前……………….…………….……………………….…………… ユーザの期待に合わせる.….…………………….……………………………  . 例 : get*()……………………………….…………………………………………. 例Ust::size()……….…………………………………………….…….….…… .例複数の名前を検討する…………………………………….……….……  . まとめ.………………………………………….…….………………………………  美しさ………………………………..….………………….…….….….…….…. なぜ美しさが大切なのか…………….…………………….……………… .一貫\'性のある簡潔な改行位置…….……………………………….………… .メソッドを使った整列….……………………………………………………… .縦の線をまっすぐにする……….….………………………….……………… 整列すべきなのか…….……………………………………………….……… .一貫性と意味のある並び………………..……………………………….…… .宣言をブロックにまとめる.………………….……………………………… .コードを「段落」に分割する……….………………………………………. .個人的な好みと一貫ʻ性……….………………….…………………….…….…  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(16,1,15,'５章\n\nＳ章\n\n目 次 X V\n\n4\n.\n9まとめ…………………………………………………………………………………5４\n\n5\n.\n2\n\nコメントすべきことを知る…………..……………….…….…….………５５\n５．１コメントするべきでは「ない」こと…………………………….……….５７\nコメントのためのコメントをしない…….……………………………….５８\nひどい名前はコメントをつけずに名前を変える.……………………５９\n自分の考えを記録する…………………….……………………………………60\n「監督のコメンタリー」を入れる……………..……………………………６０\nコードの欠陥にコメントをつける…………………………………………６１\n定数にコメントをつける……………….…………….…………….…………62\n5.3読み手の立場になって考える…………….………….………………………６３\n質問されそうなことを想像する…………………………….………………６３\nハマリそうな良を告知する………….….……………………………………６４\n「全体像」のコメント……………………………………………………………６６\n要約コメント.….……………….….…………….………….………………….…67\n5.4ライターズブロックを乗り越える…………………………………………68\n5.5まとめ…………………………………………………………………………………6９\n\nコメントは正確で簡潔に…………………………………….…….……….フ１\n６．１コメントを簡潔にしておく…….…………………………………….………72\n6.2あいまいな代名詞を避ける………………………….…………………….…72\n6.3歯切れの悪い文章を磨く………………….…………………….…………….73\n6.4関数の動作を正確に記述する…….…………….……………………………73\n6.5入出力のコーナーケースに実例を使う……………………………….…74\n6.6コードの意図を書く….….………………………………………………………76\n6.7「名前付き引数」コメント……………………………………………….……77\n6.8情報密度の高い言葉を使う………………….…………………………….…78\n6.9まとめ……….………………………………….…………………………….………7８\n\n第Ⅱ部\nフ章\n\nループとロジックの単純化…….…………………….….….……8１\n制御フローを読みやすくする……….………..….………………………83\n7\n.\n1条件式の引数の並び順…..…….……….………………………………………8４\n\n','章  Ｓ章  目 次 X V   . まとめ…………………………………………………………………………………   .   コメントすべきことを知る…………..……………….…….…….……… コメントするべきでは「ない」こと…………………………….………. コメントのためのコメントをしない…….………………………………. ひどい名前はコメントをつけずに名前を変える.…………………… 自分の考えを記録する…………………….…………………………………… 「監督のコメンタリー」を入れる……………..…………………………… コードの欠陥にコメントをつける………………………………………… 定数にコメントをつける……………….…………….…………….………… .読み手の立場になって考える…………….………….……………………… 質問されそうなことを想像する…………………………….……………… ハマリそうな良を告知する………….….…………………………………… 「全体像」のコメント…………………………………………………………… 要約コメント.….……………….….…………….………….………………….… .ライターズブロックを乗り越える………………………………………… .まとめ…………………………………………………………………………………  コメントは正確で簡潔に…………………………………….…….……….フ コメントを簡潔にしておく…….…………………………………….……… .あいまいな代名詞を避ける………………………….…………………….… .歯切れの悪い文章を磨く………………….…………………….……………. .関数の動作を正確に記述する…….…………….…………………………… .入出力のコーナーケースに実例を使う……………………………….… .コードの意図を書く….….……………………………………………………… .「名前付き引数」コメント……………………………………………….…… .情報密度の高い言葉を使う………………….…………………………….… .まとめ……….………………………………….…………………………….………  第Ⅱ部 フ章  ループとロジックの単純化…….…………………….….….…… 制御フローを読みやすくする……….………..….………………………  . 条件式の引数の並び順…..…….……….………………………………………  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(17,1,16,'i\nf/elseブロックの並び順……………………………..………………………86\n三項演算子…………………………………………………………………….….…８８\ndo/whileループを避ける.…………………………………………………….89\n関数から早く返す……………..…………………………………………………９１\n悪名高きgoto………………………………………………………………………92\nネストを浅くする…………..……………………….…….………….…………９３\nネストが増える仕組み………………………………………………….………９３\n早めに返してネストを削除する………….…………………………………９４\nループ内部のネストを削除する..………………….………….……………９５\n実行の流れを追えるかい？……………….………………………………….９６\nまとめ…………………….……………….…………………………….……………9７\n\n●\n\nワム○一Ｊ．一一４­反Ｊ一《ｈ〉ワＪ\n７ ７ ７ ７ ７ ７\n\n●\n\n●\n\n●\n\n●\n\n●\n\n８Ｑ・〉●\n７ ７\n\n●\n\nＢ章\n\nｇ章\n\n巨大な式を分割する………….….……..…….…………………………..…９g\n８．１説明変数……………………………………………………………………………100\n8.2要約変数…………………………….………………………………….….………100\n8.3ド・モルガンの法則を使う…………………………………………………101\n8.4短絡評価の悪用……………………….……….…………………………….….102\n8.5例：複雑なロジックと格闘する………………….……………………….103\nより優雅な手法を見つける…………………………………………………105\n8.6巨大な文を分割する……………………………………………………………106\n8.7式を簡潔にするもう１つの創造的な方法…………………………….､107\n8\n.\n8まとめ………………………………………………………………….……………108\n\n変数と読みやすさ...…..….………….…………………….…….…………１１１\n９．１変数を削除する.…………………………………………………………………112\n役に立たない一時変数…………………………………………..……………112\n中間結果を削除する…………….………………………………………..……113\n制御フロー変数を削除する…………………………………………………114\n9.2変数のスコープを縮める……………………………………….……………115\nC++の祉文のスコープ…………….…………………………………………117\nJavaScriptで「プライベート」変数を作る…….……………………117\nJavaScnptのグローバルスコープ………….……………………….……119\n\nx v i 目 次\n\n','i f/elseブロックの並び順……………………………..……………………… 三項演算子…………………………………………………………………….….… do/whileループを避ける.……………………………………………………. 関数から早く返す……………..………………………………………………… 悪名高きgoto……………………………………………………………………… ネストを浅くする…………..……………………….…….………….………… ネストが増える仕組み………………………………………………….……… 早めに返してネストを削除する………….………………………………… ループ内部のネストを削除する..………………….………….…………… 実行の流れを追えるかい……………….…………………………………. まとめ…………………….……………….…………………………….……………  ●  ワム○一Ｊ一一­反Ｊ一《ｈ〉ワＪ        ●  ●  ●  ●  ●  Ｑ・〉●    ●  Ｂ章  ｇ章  巨大な式を分割する………….….……..…….…………………………..…g 説明変数…………………………………………………………………………… .要約変数…………………………….………………………………….….……… .ド・モルガンの法則を使う………………………………………………… .短絡評価の悪用……………………….……….…………………………….…. .例複雑なロジックと格闘する………………….………………………. より優雅な手法を見つける………………………………………………… .巨大な文を分割する…………………………………………………………… .式を簡潔にするもうつの創造的な方法…………………………….､  . まとめ………………………………………………………………….……………  変数と読みやすさ...…..….………….…………………….…….………… 変数を削除する.………………………………………………………………… 役に立たない一時変数…………………………………………..…………… 中間結果を削除する…………….………………………………………..…… 制御フロー変数を削除する………………………………………………… .変数のスコープを縮める……………………………………….…………… C++の祉文のスコープ…………….………………………………………… JavaScriptで「プライベート」変数を作る…….…………………… JavaScnptのグローバルスコープ………….……………………….……  x v i 目 次  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(18,1,17,'目 次 x v i i\n\nPythonとJavaScriptのネストしないスコープ….…………………119\n定義の位置を下げる…….…………………………….…….…………………121\n変数は一度だけ書き込む……….……………………………………………123\n最後の例……………………………………………………….……………….….124\nまとめ……….………………………………………………………………………126\n\n●\n\nｑ­Ｕ４４反Ｊ\n９ ９ ９\n\n●\n\n●\n\n第Ⅱ1部\n10章\n\n１１章\n\nコードの再構成………...……...……....…….…………………１２フ\n無関係の下位問題を抽出する.…………………………...…….………129\n10.1入門的な例: findClosestLocationO……………………………………130\n10.2純粋なユーティリティコード……….…………………………….……….132\n10.3その他の汎用コード……….….…………….…………………………………133\n思いも寄らない恩恵……………………………………………………………134\n10.4汎用コードをたくさん作る……………….……………….……………….135\n10.5プロジェクトに特化した機能………………………………………………136\n10.6既存のインタフェースを簡潔にする……………………………………137\n10.7必要に応じてインタフエーースを整える………………….….…………139\n10.8やりすぎ……………………………………………………………………………140\n10.9まとめ……………….………………………………………………………………141\n\n一度に\n11.1\n11.2\n\n11.3\n\n11.4\n\n１つのことを..….….……....……………….……………..….….143\nタスクは小さくできる……….……………………………………….………145\nオブジェクトから値を抽出する…………………………….………….…147\n｢一度に１つのタスク」を適用する…….….……………………………149\nその他の手法.…….………………………………………………………………151\nもつと大きな例…………………………………………………….……………151\nさらなる改善……………………….……………………….……………………154\nまとめ…………………………………………………………………….…………155\n\n１２章\n\nコードに思いを込める..………….………..……….…………….………１５フ\n12.1ロジックを明確に説明する.….……………………………….……………158\n12.2ライブラリを知る……….………………………………..……………………159\n12.3この手法を大きな問題に適用する……………………….………………161\n\n','目 次 x v i i  PythonとJavaScriptのネストしないスコープ….………………… 定義の位置を下げる…….…………………………….…….………………… 変数は一度だけ書き込む……….…………………………………………… 最後の例……………………………………………………….……………….…. まとめ……….………………………………………………………………………  ●  ｑ­Ｕ反Ｊ     ●  ●  第Ⅱ部 章  章  コードの再構成………...……...……....…….…………………フ 無関係の下位問題を抽出する.…………………………...…….……… .入門的な例: findClosestLocationO…………………………………… .純粋なユーティリティコード……….…………………………….………. .その他の汎用コード……….….…………….………………………………… 思いも寄らない恩恵…………………………………………………………… .汎用コードをたくさん作る……………….……………….………………. .プロジェクトに特化した機能……………………………………………… .既存のインタフェースを簡潔にする…………………………………… .必要に応じてインタフエーースを整える………………….….………… .やりすぎ…………………………………………………………………………… .まとめ……………….………………………………………………………………  一度に . .  .  .  つのことを..….….……....……………….……………..….…. タスクは小さくできる……….……………………………………….……… オブジェクトから値を抽出する…………………………….………….… ｢一度につのタスク」を適用する…….….…………………………… その他の手法.…….……………………………………………………………… もつと大きな例…………………………………………………….…………… さらなる改善……………………….……………………….…………………… まとめ…………………………………………………………………….…………  章  コードに思いを込める..………….………..……….…………….………フ .ロジックを明確に説明する.….……………………………….…………… .ライブラリを知る……….………………………………..…………………… .この手法を大きな問題に適用する……………………….………………  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(19,1,18,'xviii  I目次\n\n解決策を言葉で説明する…………………………………………………….163\n手法を再帰的に適用する.……………………………………………………163\nまとめ………………………………………………………….……………………165\n\n12.4\n\n1 3 S 短いコードを書く….……….….……………….………….…………….…16フ\n\n13.1その機能の実装について悩まないで\n\n­きっと必要ないから….…………………….…………………….168\n13.2質問と要求の分割….………….………………………………….……………168\n例：店舗検索システム……….………………………………………….……168\n例：キャッシュを追加する…………………………………………………169\n13.3コードを小さく保つ……………………………………………………………170\n13.4身近なライブラリに親しむ…………………………………………………172\n例: Pythonのリストとセット……………….…..……………………….172\nライブラリの再利用はなぜいいことなのか………….………………173\n13.5例：コーディングするよりも….…….………………………………….…173\nUnixツールボックスを使う……………………………………………..…173\n13.6まとめ…………………….…………………………………………………………175\n\n第IV部\n１４章\n\n選抜テーマ…..…………………….…..…………..…….…...…１フフ\nテストと読みやすさ.……….………………………………………………1フｇ\n14.1テストを読みやすくて保守しやすいものにする……………..……180\n14.2このテストのどこがダメなの？…….………………………….…………180\n14.3テストを読みやすくする…………….………………………………………181\n最小のテストを作る……………………………………………………………183\n独自の「ミニ言語」を実装する……..……………………………………183\n14.4エラーメッセージを読みやすくする……………….…….….…………185\nもつといいassert()を使う………….…………………………………….185\n手作りのエラーメッセージ…………………………………………………187\n14.5テストの適切な入力値を選択する.………………………………………188\n入力値を単純化する………….………………………………………….…….188\n１つの機能に複数のテスト……….…….……………………………..……190\n14.6テストの機能に名前をつける….….………………………….……………190\n\n','xviii  I目次  解決策を言葉で説明する……………………………………………………. 手法を再帰的に適用する.…………………………………………………… まとめ………………………………………………………….……………………  .    S 短いコードを書く….……….….……………….………….…………….…フ  .その機能の実装について悩まないで  ­きっと必要ないから….…………………….……………………. .質問と要求の分割….………….………………………………….…………… 例店舗検索システム……….………………………………………….…… 例キャッシュを追加する………………………………………………… .コードを小さく保つ…………………………………………………………… .身近なライブラリに親しむ………………………………………………… 例: Pythonのリストとセット……………….…..………………………. ライブラリの再利用はなぜいいことなのか………….……………… .例コーディングするよりも….…….………………………………….… Unixツールボックスを使う……………………………………………..… .まとめ…………………….…………………………………………………………  第IV部 章  選抜テーマ…..…………………….…..…………..…….…...…フフ テストと読みやすさ.……….………………………………………………フｇ .テストを読みやすくて保守しやすいものにする……………..…… .このテストのどこがダメなの…….………………………….………… .テストを読みやすくする…………….……………………………………… 最小のテストを作る…………………………………………………………… 独自の「ミニ言語」を実装する……..…………………………………… .エラーメッセージを読みやすくする……………….…….….………… もつといいassert()を使う………….……………………………………. 手作りのエラーメッセージ………………………………………………… .テストの適切な入力値を選択する.……………………………………… 入力値を単純化する………….………………………………………….……. つの機能に複数のテスト……….…….……………………………..…… .テストの機能に名前をつける….….………………………….……………  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(20,1,19,'１５章\n\n目 次 x i x\n\n14.7\n14.8\n14.9\n14.10\n\nこのテストのどこがダメだったのか？….…………………….………192\nテストに優しい開発……………………………………………………………193\nやりすぎ…….……………………….………….…………………………………195\nまとめ…………………………………….…………………………………………196\n\n｢分／時間カウンタ」を設計・実装する…….…….…….……..…igフ\n15.1問題点.…….…………………………………..……………………………………198\n15.2クラスのインタフェースを定義する.……….………….………………198\n名前を改善する……………………………………………….…………………199\nコメントを改善する……………………….….………………………….……200\n15.3試案１：素朴な解決策…………………………………………………………202\nこのコードは理解しやすいか？….…….…………………………………203\n読みやすいバージヨン………………………….……………….……………203\nパフォーマンスの問題……….…….……….……………….……….………205\n15.4試案２：ベルトコンベヤー設計……………………………………………205\n二段階ベルトコンベヤーの実装…….…….………………………………2Ｏ６\nこれで終わり？………...…….……………….……….……………….………208\n15.5試案３：時間バケツの設計…………….……….……………………….….208\n時間バケツの実装..:.………………………….………….……………………209\nTrailingBucketCounterを実装する…………………………………….211\nConveyorQueueの実装..………………….……….……………….………213\n15.6３つの解決策を比較する………………………….…………………….……214\n15.7まとめ………………….……………………………………………………………215\n\n付録\n\nあわせて読みたい……………….….………….……………………………２１フ\n高品質のコードを書くための書籍………………………………………………….…218\nプログラミングに関する書籍……………………………………………………………219\n歴史的記録..…………………….…………..………….……………………….…………..…220\n\n解説（須藤功平)…….….……………………….…………………………….｡…………223\n実際にやる.………………………………………………………………….……………….…224\n実際にやるとぶつかること….…………………………………………….………224\n\n','章  目 次 x i x  . . . .  このテストのどこがダメだったのか….…………………….……… テストに優しい開発…………………………………………………………… やりすぎ…….……………………….………….………………………………… まとめ…………………………………….…………………………………………  ｢分時間カウンタ」を設計・実装する…….…….…….……..…igフ .問題点.…….…………………………………..…………………………………… .クラスのインタフェースを定義する.……….………….……………… 名前を改善する……………………………………………….………………… コメントを改善する……………………….….………………………….…… .試案素朴な解決策………………………………………………………… このコードは理解しやすいか….…….………………………………… 読みやすいバージヨン………………………….……………….…………… パフォーマンスの問題……….…….……….……………….……….……… .試案ベルトコンベヤー設計…………………………………………… 二段階ベルトコンベヤーの実装…….…….………………………………Ｏ これで終わり………...…….……………….……….……………….……… .試案時間バケツの設計…………….……….……………………….…. 時間バケツの実装..:.………………………….………….…………………… TrailingBucketCounterを実装する……………………………………. ConveyorQueueの実装..………………….……….……………….……… .つの解決策を比較する………………………….…………………….…… .まとめ………………….……………………………………………………………  付録  あわせて読みたい……………….….………….……………………………フ 高品質のコードを書くための書籍………………………………………………….… プログラミングに関する書籍…………………………………………………………… 歴史的記録..…………………….…………..………….……………………….…………..…  解説須藤功平)…….….……………………….…………………………….｡………… 実際にやる.………………………………………………………………….……………….… 実際にやるとぶつかること….…………………………………………….………  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(21,1,20,'X X 目 次\n\n他の人に読んでもらう……….……………………………..………………………225\nおさらい……………………………………………….…………….……………………225\n当たり前にする………………………………………………….……………………………226\n既存のコードを読みやすくする前にやること…..…………………………226\n続けることが大事…………………………………………….……………………….227\nコードで伝える………………………………………….……………………………………227\n読みやすいコードがもっと当たり前であり続けるために….…………227\nコミットメールのススメ……………………………………………………………228\nまずはあなたが読む……..……………………………….………………………….228\n添削コミット………….……………………………………………………….…….…229\nおさらい………………………………………………………….…………………….…230\n最後に………….……………………………….………………………….…………………….231\n\n索引………….………..……….…….………….…..……….….………………….……….….233\n\n','X X 目 次  他の人に読んでもらう……….……………………………..……………………… おさらい……………………………………………….…………….…………………… 当たり前にする………………………………………………….…………………………… 既存のコードを読みやすくする前にやること…..………………………… 続けることが大事…………………………………………….………………………. コードで伝える………………………………………….…………………………………… 読みやすいコードがもっと当たり前であり続けるために….………… コミットメールのススメ…………………………………………………………… まずはあなたが読む……..……………………………….…………………………. 添削コミット………….……………………………………………………….…….… おさらい………………………………………………………….…………………….… 最後に………….……………………………….………………………….…………………….  索引………….………..……….…….………….…..……….….………………….……….….  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(22,1,21,'1   １\n\n１章\n理解しやすいコード\n\n','     章 理解しやすいコード  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(23,1,22,'２１１章理解しやすいコード\n\nこの５年間で「ひどいコード」をたくさん集めてきた（その多くは自分たちのも\nのだけど)。そして、なぜそのコードがひどいのか、それを改善するにはどんな原則\nや技法が使えるのかを調べてみた。そこからわかったのは、すべての原則はたった１\nつのテーマから生じているということだ。\n\n(cid:20276)となる考え\nコードは理解しやすくなければいけない。\n\nこれがコードを書く上でいちばん大切な原則だ。これからこの原則を日々のコー\nディングのさまざまな場面に当てはめる方法を紹介していきたいと思う。でもその前\nに、この原則のことをもっと詳しく説明しよう。どうしてこの原則がそんなに大切な\nんだろうか。\n\n1.1『優れた」コードって何？\nプログラマというのは（ぼくたちもそうだけど)、何となく直感でプログラミング\n\nのことを決めていることが多い。例えば、このようなコードのほうが、\n\nfor (Node* node = list->head; node != NULL: node = node->next)\n\nPrint(node->data):\n\n以下のコードよりも優れているとみんな思っている。\n\n（どちらも動作は全く同じなのに）\nでも、どちらが優れているかわからないことも多い。例えば、このようなコード\n\nは\n、\n\nu\ne\nr\nt\nr\nnexponent＞＝０？、antissa＊（１〈〈exponent）：mantissa／（１〈〈-exponent)；\n\n (node != NULL) Print(node->data):\n\n｝if\n\nNode* node = list->head:\ni\nf (node == NULL) return:\nwhile (node->next != NULL) {\n\nPrint(node->data);\nnode = node->next:\n\n','章理解しやすいコード  この年間で「ひどいコード」をたくさん集めてきたその多くは自分たちのも のだけど)。そして、なぜそのコードがひどいのか、それを改善するにはどんな原則 や技法が使えるのかを調べてみた。そこからわかったのは、すべての原則はたった つのテーマから生じているということだ。  (cid:)となる考え コードは理解しやすくなければいけない。  これがコードを書く上でいちばん大切な原則だ。これからこの原則を日々のコー ディングのさまざまな場面に当てはめる方法を紹介していきたいと思う。でもその前 に、この原則のことをもっと詳しく説明しよう。どうしてこの原則がそんなに大切な んだろうか。  .『優れた」コードって何 プログラマというのはぼくたちもそうだけど)、何となく直感でプログラミング  のことを決めていることが多い。例えば、このようなコードのほうが、  for (Node* node = list->head; node != NULL: node = node->next)  Print(node->data):  以下のコードよりも優れているとみんな思っている。  どちらも動作は全く同じなのに でも、どちらが優れているかわからないことも多い。例えば、このようなコード  は 、  u e r t r nexponent、antissa〈〈exponentmantissa〈〈-exponent)   (node != NULL) Print(node->data):  ｝if  Node* node = list->head: i f (node == NULL) return: while (node->next != NULL) {  Print(node->data); node = node->next:  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(24,1,23,'１２読みやすさの基本定理ʼ３\n\n以下のコードよりも優れているのだろうか。\n\n者のほうが簡潔だ。でも、後者のほうが安心できる。「簡潔」と「安心」はどち\n\nらが大切なことなんだろう？君ならどうやって決めるだろうか？\n1.2読みやすさの基本定理\nさっき見たようなコードをたくさん調査してみたら、読みやすさの基準となるもの\nにたどり着くことができた。これはどんな基準よりも大切なものなんだ。すごく大切\nなので「読みやすさの基本定理」と呼ぶことにしよう。\n\n(cid:20276)となる考え\nコードは他の人が最短時間で理解できるように書かなければいけない。\n\nこれってどういう意味だと思う？そのまんまの意味だ。例えば、同僚にコードを\n読んでもらって、彼が理解するまでにかかる時間を計測するとしよう。この「理解す\nるまでにかかる時間」という数値を最短にするってことだ。\n\nそれから「理解する」っていう言葉には、高いハードルを設けてある。「コードを\n理解する」というのは、変更を加えたりバグを見つけたりできるという意味だ。他の\nコードと連携する方法も理解しておかなければいけない。\n\nもしかすると、こんなふうに考えているかもしれないね。「他の人が理解できるっ\nて、誰が得するんだよ？このコードを使ってるのはオレだけなんだぞ！」でもね、\nたとえ君ひとりのプロジェクトだったとしても、この目標には取り組むだけの価値\nがあるんだ。「他の人」というのは、自分のコードに見覚えのない６か月後の「君自\n身」かもしれない。君のプロジェクトに途中から誰かが参加しないとも言い切れな\nい。「使い捨てのコード」が他のプロジェクトで再利用される可能ʻ性だってある。\n\n｝ 前\n\ni\nf (exponent >= 0) {\n\n} else {\n\nreturn mantissa * (l  exponent);\nreturn mantissa / (l  -exponent);\n\n','読みやすさの基本定理ʼ  以下のコードよりも優れているのだろうか。  者のほうが簡潔だ。でも、後者のほうが安心できる。「簡潔」と「安心」はどち  らが大切なことなんだろう君ならどうやって決めるだろうか .読みやすさの基本定理 さっき見たようなコードをたくさん調査してみたら、読みやすさの基準となるもの にたどり着くことができた。これはどんな基準よりも大切なものなんだ。すごく大切 なので「読みやすさの基本定理」と呼ぶことにしよう。  (cid:)となる考え コードは他の人が最短時間で理解できるように書かなければいけない。  これってどういう意味だと思うそのまんまの意味だ。例えば、同僚にコードを 読んでもらって、彼が理解するまでにかかる時間を計測するとしよう。この「理解す るまでにかかる時間」という数値を最短にするってことだ。  それから「理解する」っていう言葉には、高いハードルを設けてある。「コードを 理解する」というのは、変更を加えたりバグを見つけたりできるという意味だ。他の コードと連携する方法も理解しておかなければいけない。  もしかすると、こんなふうに考えているかもしれないね。「他の人が理解できるっ て、誰が得するんだよこのコードを使ってるのはオレだけなんだぞ」でもね、 たとえ君ひとりのプロジェクトだったとしても、この目標には取り組むだけの価値 があるんだ。「他の人」というのは、自分のコードに見覚えのないか月後の「君自 身」かもしれない。君のプロジェクトに途中から誰かが参加しないとも言い切れな い。「使い捨てのコード」が他のプロジェクトで再利用される可能ʻ性だってある。  ｝ 前  i f (exponent >= ) {  } else {  return mantissa * (l  exponent); return mantissa / (l  -exponent);  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(25,1,24,'４１１章理解しやすいコード\n\n1.3小さなことは絶対にいいこと？\n問題を解決するコードは短いほうがいい（｢１３章短いコードを書く」参照)。\n2,000行のクラスのほうが5,000行のクラスよりも理解するまでにかかる時間は短い\nはずだ。\n\nでも、短ければいいってもんじゃない！このような１行のコードは、\n\nassert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());\n\n以下のような２行のコードを理解するよりも時間がかかることが多い。\n\nbucket = FindBucket(key);\ni\nf (bucket != NULL) assert(!bucket->IsOccupied());\n\nコメントをつけると「コードが長く」なるけど、そのほうが理解しやすいこともあ\n\n/ \"hash = (65599 * hash) + c\"の高速版\nhash = (hash  6) + (hash  16) - hash + c;\nコードは短くしたほうがいい。だけど、「理解するまでにかかる時間」を短くする\n\n。 /\n\nる\n\nほうが大切だ。\n\n1.4「理解するまでにかかる時間」は競合する？\n「それじゃあ、その他の条件は？コードを効率化するとか、設計をうまくやると\nか、テストしやすいとか、いろいろあるじゃん？そういうのは理解しやすさと競合\nしないわけ？」そんなことを考えるかもしれないね。\nでも、その他の目標とは全く競合しないんだ。高度に最適化されたコードであって\nも、もっと理解しやすくできるはずだ。それに、理解しやすいコードというのは、優\nれた設計やテストのしやすさにつながることが多い。\n\n本書では、いろんな状況に「読みやすさ」を当てはめる方法を紹介している。どう\nすればいいかわからなくなったときは、本書で紹介する規則や原則よりも「読みやす\nさの基本定理」を最優先に考えて欲しい。コードを見たらすぐにリファクタリングし\nたくなるプログラマもいるだろうけど、常に一歩下がって「このコードは理解しやす\nいだろうか？」と自問自答してみることが大切だ。理解しやすいコードになってか\n\n','章理解しやすいコード  .小さなことは絶対にいいこと 問題を解決するコードは短いほうがいい｢章短いコードを書く」参照)。 ,行のクラスのほうが,行のクラスよりも理解するまでにかかる時間は短い はずだ。  でも、短ければいいってもんじゃないこのような行のコードは、  assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());  以下のような行のコードを理解するよりも時間がかかることが多い。  bucket = FindBucket(key); i f (bucket != NULL) assert(!bucket->IsOccupied());  コメントをつけると「コードが長く」なるけど、そのほうが理解しやすいこともあ  / \"hash = ( * hash) + c\"の高速版 hash = (hash  ) + (hash  ) - hash + c; コードは短くしたほうがいい。だけど、「理解するまでにかかる時間」を短くする  。 /  る  ほうが大切だ。  .「理解するまでにかかる時間」は競合する 「それじゃあ、その他の条件はコードを効率化するとか、設計をうまくやると か、テストしやすいとか、いろいろあるじゃんそういうのは理解しやすさと競合 しないわけ」そんなことを考えるかもしれないね。 でも、その他の目標とは全く競合しないんだ。高度に最適化されたコードであって も、もっと理解しやすくできるはずだ。それに、理解しやすいコードというのは、優 れた設計やテストのしやすさにつながることが多い。  本書では、いろんな状況に「読みやすさ」を当てはめる方法を紹介している。どう すればいいかわからなくなったときは、本書で紹介する規則や原則よりも「読みやす さの基本定理」を最優先に考えて欲しい。コードを見たらすぐにリファクタリングし たくなるプログラマもいるだろうけど、常に一歩下がって「このコードは理解しやす いだろうか」と自問自答してみることが大切だ。理解しやすいコードになってか  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(26,1,25,'1 . 5 で も や る ん だ よ ʼ ５\n\nら、次のコードを書き始めてもいいんじゃないかな。\n\n1.5でもやるんだよ\n想像上の誰かが自分のコードを理解しやすいかなんて考えるのは大変なことだ。こ\n\nれまでとは違う脳ミソを回転させなきゃいけない。\n\nでも、この目標を（ぼくたちみたいに）受け入れたら、君はきっと優秀なプログラ\nマになれるはずだ。自分の仕事に誇りを持ち、周囲のみんなが喜んで使ってくれるよ\nうな、バグの少ないコードを作り出せるようになる。さあ、始めよう！\n\n',' .  で も や る ん だ よ ʼ   ら、次のコードを書き始めてもいいんじゃないかな。  .でもやるんだよ 想像上の誰かが自分のコードを理解しやすいかなんて考えるのは大変なことだ。こ  れまでとは違う脳ミソを回転させなきゃいけない。  でも、この目標をぼくたちみたいに受け入れたら、君はきっと優秀なプログラ マになれるはずだ。自分の仕事に誇りを持ち、周囲のみんなが喜んで使ってくれるよ うな、バグの少ないコードを作り出せるようになる。さあ、始めよう  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(27,1,26,'第；部\n表面上の改善\n\n読みやすさの旅の始まりは「表面上」の改善だ。適切に名前を選んだり、優れたコ\nメントを書いたり、コードをキレイにフオーマットしたり。こうした変更は簡単にで\nきる。プログラムの変更やリファクタリングをしなくても「入れ替え」可能だ。それ\nに、時間をかけずに少しずつ変更することもできる。\n\nこのテーマはすごく大切だ。コードのすべての行に影響するからね。個々の変更は\n小さいかもしれないけど、それらを合わせれば、コードに大きな改善をもたらせる。\nコードに適切な名前をつければ、優れたコメントを書けば、空白の使い方をキレイに\nすれば、コードはもっと読みやすくなる。\n\n読みやすさを改善する方法は「表面下」にもたくさんある（それらについてはあと\nで説明する)。でも、「表面上」の改善は手間のかからない割に幅広く適用できるもの\nなので、最初に触れておくのがいいだろう。\n\n','第部 表面上の改善  読みやすさの旅の始まりは「表面上」の改善だ。適切に名前を選んだり、優れたコ メントを書いたり、コードをキレイにフオーマットしたり。こうした変更は簡単にで きる。プログラムの変更やリファクタリングをしなくても「入れ替え」可能だ。それ に、時間をかけずに少しずつ変更することもできる。  このテーマはすごく大切だ。コードのすべての行に影響するからね。個々の変更は 小さいかもしれないけど、それらを合わせれば、コードに大きな改善をもたらせる。 コードに適切な名前をつければ、優れたコメントを書けば、空白の使い方をキレイに すれば、コードはもっと読みやすくなる。  読みやすさを改善する方法は「表面下」にもたくさんあるそれらについてはあと で説明する)。でも、「表面上」の改善は手間のかからない割に幅広く適用できるもの なので、最初に触れておくのがいいだろう。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(28,1,27,'ʼ ９\n\n憲章\n名前にI情報を詰め込む\n\nＩ\n\n','ʼ   憲章 名前にI情報を詰め込む  Ｉ  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(29,1,28,'１０１２章名前に情報を詰め込む\n\n名前をつけるときには、それが変数であっても、関数であっても、クラスであって\nも、同じ原則を当てはめることができる。名前は短いコメントだと思えばいい。短く\nてもいい名前をつければ、それだけ多くの情報を伝えることができる。\n\n(cid:20276)となる考え\n名前に情報を詰め込む。\n\nプログラムに使われる名前というのはハッキリしないものが多い。例えば、tmpな\nんかがそうだ。でも、sizeやgetみたいに一見すると問題がなさそうな名前であっ\nても、情報が含まれていないことがある。\n\nこれから情報を詰め込んだ名前のつけ方を紹介する。本章は、以下の６つのテー\n\nマで構成されている。\n\n●明確な単語を選ぶ\n\n●汎用的な名前を避ける（あるいは、使う状況を選ぶ）\n\n●抽象的な名前よりも具体的な名前を使う\n\n●接尾辞や接頭辞を使って情報を追加する\n\n●名前の長さを決める\n\n●名前のフオーマットで情報を伝える\n\n２１明確な単語を選ぶ\n「名前に情報を詰め込む」には、明確な単語を選ばなければいけない。「空虚な」単\n\n語は避けるべきだ。\n\n例えば、「get」はあまり明確な単語ではない。\n\ndef CetPage url :\n\n● ● ●\n\n「get」という単語からは何も伝わってこない。このメソッドはページをどこか\nら取ってくるのだろう？ローカルキャッシュから？データベースから？イ\nンターネットから？インターネットから取ってくるのであれば、FetchPageQや\n\n','章名前に情報を詰め込む  名前をつけるときには、それが変数であっても、関数であっても、クラスであって も、同じ原則を当てはめることができる。名前は短いコメントだと思えばいい。短く てもいい名前をつければ、それだけ多くの情報を伝えることができる。  (cid:)となる考え 名前に情報を詰め込む。  プログラムに使われる名前というのはハッキリしないものが多い。例えば、tmpな んかがそうだ。でも、sizeやgetみたいに一見すると問題がなさそうな名前であっ ても、情報が含まれていないことがある。  これから情報を詰め込んだ名前のつけ方を紹介する。本章は、以下のつのテー  マで構成されている。  ●明確な単語を選ぶ  ●汎用的な名前を避けるあるいは、使う状況を選ぶ  ●抽象的な名前よりも具体的な名前を使う  ●接尾辞や接頭辞を使って情報を追加する  ●名前の長さを決める  ●名前のフオーマットで情報を伝える  明確な単語を選ぶ 「名前に情報を詰め込む」には、明確な単語を選ばなければいけない。「空虚な」単  語は避けるべきだ。  例えば、「get」はあまり明確な単語ではない。  def CetPage url :  ● ● ●  「get」という単語からは何も伝わってこない。このメソッドはページをどこか ら取ってくるのだろうローカルキャッシュからデータベースからイ ンターネットからインターネットから取ってくるのであれば、FetchPageQや  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(30,1,29,'ｗ\n０\n\nr\n,\n／も略１１­全\n\n全もﾉʼ鑑心 身 全\n\n媒\n亥\n_\n入\nこ\n\nﾊ .\n､職Ｍ\n\n(cid:7645)ハʻｎワ\nーイlワ言I｢坊\n\n̅ 我\n\n賢公\n\n̅\n̅\n\n》\n》\n\n2.1明確な単語を選ぶI  11\n\nDownloadPageQのほうが明確だ。\n\n次は、BinaryTreeクラスの例だ蓮\n\nc\nl\nass BinaryTree i\n\nint SizeQ;\n\n}\n；\nこのSizeQメソッドは何を返すのだろうか？ツリーの尚さ？ノードの数？\n\nツリーのメモリ消甜量？Size()では何も情報が伝わらない。目的に適した|ﾘ1碓な\n名前をつけるなら、それぞれHeight()・NumNodes()・NemoryBytes()になるだろう。\n\nもう１つの例は、とあるThreadクラスだ。\n\ntop()という名前でもいいけど、動作に合わせてもっと\'ﾘl確な名前をつけたほ号\nがいいと思う。例えば、取り消しができない重い操作なら、KillQにするといい-\nあとからResumeQできるなら、PauseQにしてもいいかもしれない。\n\n．J】 S\n\n１\n\nc\nl\nass Thread {\nvoid Stop()』\n\nもっと「カラフル」な単語を探す\n\n､\n減』\n\nＬ\n\n一\n\n1\n,\n》\n〆\n\n(cid:20276)\n\n参 宿 ら ロ 盛 り 屋 U 今\nステゴサウルス\n\nＢ “ Ｃ Ｈ ﾉ ･ 鐸 Ｕ 屋 Ｕ 今\nブ､ラキオサウルス\n\n帳 挙 り 庭 Ｕ 今\nシソーラス\n\n','ｗ   r , も略­全  全もﾉʼ鑑心 身 全  媒 亥 _ 入 こ  ﾊ . ､職Ｍ  (cid:)ハʻｎワ ーイlワ言I｢坊  ̅ 我  賢公  ̅ ̅  》 》  .明確な単語を選ぶI    DownloadPageQのほうが明確だ。  次は、BinaryTreeクラスの例だ蓮  c l ass BinaryTree i  int SizeQ;  }  このSizeQメソッドは何を返すのだろうかツリーの尚さノードの数  ツリーのメモリ消甜量Size()では何も情報が伝わらない。目的に適した|ﾘ碓な 名前をつけるなら、それぞれHeight()・NumNodes()・NemoryBytes()になるだろう。  もうつの例は、とあるThreadクラスだ。  top()という名前でもいいけど、動作に合わせてもっと\'ﾘl確な名前をつけたほ号 がいいと思う。例えば、取り消しができない重い操作なら、KillQにするといい- あとからResumeQできるなら、PauseQにしてもいいかもしれない。  J】 S    c l ass Thread { void Stop()』  もっと「カラフル」な単語を探す  ､ 減』  Ｌ  一   , 》 〆  (cid:)  参 宿 ら ロ 盛 り 屋 U 今 ステゴサウルス  Ｂ “ Ｃ Ｈ ﾉ ･ 鐸 Ｕ 屋 Ｕ 今 ブ､ラキオサウルス  帳 挙 り 庭 Ｕ 今 シソーラス  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(31,1,30,'１２１２章名前に情報を詰め込む\n\nシソーラス（類語辞典）を使って調べよう。友達にもっといい名前がないかと聞い\n\nてみよう。英語は豊かな言語だから、選べる単語はたくさんあるはずだ。\n\n例として、いくつかの単語と状況に合わせて使えるもっと「カラフル」なバージョ\n\nンの単語を紹介しておこう。\n\n|単語\n単\nsen〔i\nﬁnd\nS\nt\na\nI\n･ｔ\nｍａｋｅ\n\n出\n\n….?､粥･ぜ.､\n\n案\n\n#代替案.ʻ\ndeliver, dispatch, announce, distribute, route\nsea１℃h, exti●act, locate, recover\nlaunch, create, begin, open\ncreate, set up, build, generate, compose, add, new\n\nただし、やりすぎはいけない。PHPには、文字列をexplodeQする関数があ\nる。カラフルな名前だし、何かを分割する様子がうまく表現できている。だけど、\nspiitnと何が通うんだろう？（2つの関数は別物だけど、名前からその違いはわか\nらない）\n\n(cid:20276) と な る 考 え\n気取った言い回しよりも明確で正確なほうがいい陸．\n\n2.2   tmp ^retvalなどの汎用的な名前を避ける\ntmp・retval  fooのような名前をつけるのは、「名前のことなんて考えていません」\nと言っているようなものだ。このような「空虚な名前」をつけるのではなく、エン\nティティの値や目的を表した名前を選ぼう。\n\n例えば、retvalを使っているJavaScriptの関数があるとする。\n\nvar euclidean norm = function (v) {\n\nvar retval = 0.0;\nfor (var i = 0; i < v.length; i += ll\n\nretval += v[i] * v[i]:\nreturn Hath､sqrt(retval):\n\n};\n\n','章名前に情報を詰め込む  シソーラス類語辞典を使って調べよう。友達にもっといい名前がないかと聞い  てみよう。英語は豊かな言語だから、選べる単語はたくさんあるはずだ。  例として、いくつかの単語と状況に合わせて使えるもっと「カラフル」なバージョ  ンの単語を紹介しておこう。  |単語 単 sen〔i ﬁnd S t a I ･ｔ ｍａｋｅ  出  ….?､粥･ぜ.､  案  #代替案.ʻ deliver, dispatch, announce, distribute, route sea℃h, exti●act, locate, recover launch, create, begin, open create, set up, build, generate, compose, add, new  ただし、やりすぎはいけない。PHPには、文字列をexplodeQする関数があ る。カラフルな名前だし、何かを分割する様子がうまく表現できている。だけど、 spiitnと何が通うんだろうつの関数は別物だけど、名前からその違いはわか らない  (cid:) と な る 考 え 気取った言い回しよりも明確で正確なほうがいい陸  .   tmp ^retvalなどの汎用的な名前を避ける tmp・retval  fooのような名前をつけるのは、「名前のことなんて考えていません」 と言っているようなものだ。このような「空虚な名前」をつけるのではなく、エン ティティの値や目的を表した名前を選ぼう。  例えば、retvalを使っているJavaScriptの関数があるとする。  var euclidean norm = function (v) {  var retval = .; for (var i = ; i < v.length; i += ll  retval += v[i] * v[i]: return Hath､sqrt(retval):  };  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(32,1,31,'2.2     tmpや｢etvalなどの汎用的な名前を避ける１3\n\nいい名前が思いつかなかったら、戻り値にretvalとつけたくなる。でも、retval\n\nには「これは戻り値です」以外の情報はない（戻り値なのは当たり前だ)。\n\nいい名前というのは、変数の目的や値を表すものだ。ここでは、ｖの２乗の合計を\n表しているわけだから、sum squaresという名前がいいだろう。こうしておけば、変\n数の目的を事前に伝えることができるし、バグの発見にも役立つはずだ。\n\n例えば、ループ内の処理を間違えて以下のように書いたとする。\n\nretval += vﬁl;\n\n変数名がsum squaresだったら、バグを見つけやすい。\n\nsum squares += v[i]; //合計する「square (2乗)」がない。バグだ！\n\nア ド バ イ ス\nretvalという名前には情報がない。変数の値を表すような名前を使おう。\n\nただし、汎用的な名前に意味がないわけではない。汎用的な名前をうまく使った例\n\nを見ていこう。\n\ntmp\n２つの変数を入れ替える古典的な例を考えてみよう。\n\nのような場合は、tmpという名前で全く問題ない。この変数の目的は、ʻ情報の一\n時的な保管だ。しかも、生存期間はわずか数行である。tmpという名前で「この変数\nには他に役割がない」という明確な意味を伝えている。つまり、他の関数に渡された\nり、何度も書き換えられたりしない、ということだ。\n\n｝ こ\n\nでも、以下のtmpは単なる怠慢だ。\n\nif (right < left) {\n\ntmp = right;\nright = left;\nleft = tmp;\n\n','.     tmpや｢etvalなどの汎用的な名前を避ける  いい名前が思いつかなかったら、戻り値にretvalとつけたくなる。でも、retval  には「これは戻り値です」以外の情報はない戻り値なのは当たり前だ)。  いい名前というのは、変数の目的や値を表すものだ。ここでは、ｖの乗の合計を 表しているわけだから、sum squaresという名前がいいだろう。こうしておけば、変 数の目的を事前に伝えることができるし、バグの発見にも役立つはずだ。  例えば、ループ内の処理を間違えて以下のように書いたとする。  retval += vﬁl;  変数名がsum squaresだったら、バグを見つけやすい。  sum squares += v[i]; //合計する「square (乗)」がない。バグだ  ア ド バ イ ス retvalという名前には情報がない。変数の値を表すような名前を使おう。  ただし、汎用的な名前に意味がないわけではない。汎用的な名前をうまく使った例  を見ていこう。  tmp つの変数を入れ替える古典的な例を考えてみよう。  のような場合は、tmpという名前で全く問題ない。この変数の目的は、ʻ情報の一 時的な保管だ。しかも、生存期間はわずか数行である。tmpという名前で「この変数 には他に役割がない」という明確な意味を伝えている。つまり、他の関数に渡された り、何度も書き換えられたりしない、ということだ。  ｝ こ  でも、以下のtmpは単なる怠慢だ。  if (right < left) {  tmp = right; right = left; left = tmp;  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(33,1,32,'１４１２章名前に情報を詰め込む\n\nString tmp = user.nameQ;\nt\nmp += \" \" + user・phone number();\nt叩+= \" \" + user・emailQ;\ntemplate.set(\"user info\", tmp);\n\n生存期間は短いけど、この変数にとっていちばん大切なことは「一時的な保管」で\nはない。これをわかりやすくするには、user  infoのような名前に変えるといいだろ\nｏ\nう\n以下の例では、名前の一部にtmpを使っている。\n\ntmpjile = tempﬁle.NamedTemporaryFileQ\n● ● ●SaveData(tmp file,…）\n\nファイルオブジェクトなので、ただのtmpではなくtmp  fileという名前になって\n\nいる。これをtmpにしていたら、どうなっていただろうか。\n\nSaveData(t叩，…）\n\nこの行だけを見ると、tmpがファイルなのか、ファイル名なのか、データなのかが\n\nわからない。\n\nア ド バ イ ス\ntmpという名前は、生存期間が短くて、一時的な保管が最も大切な変数にだけ使おうʻ\n\nルーブイテレータ\nｉ・』．ｋ・iterなどの名前は、インデックスやループイテレータでよく使われてい\nる。汎用的な名前だけど、これだけで「ぼくはイテレータ」という意味になるので匿\n題ない（それ以外の目的に使うとまぎらわしくなるのでやめよう！）\n\nでも、ｉ・j-kよりいい名前がある。例えば、クラブに所属しているユーザを調べ\n\nるループを見てみよう。\n\nfor (int i = 0; i < clubs.sizeQ; i++)\n\nfor (int j = 0; j < clubs[i]・members.sizeQ; i++)\n\nfor (int k = 0; k < users.sizeQ; k++)\n\n','章名前に情報を詰め込む  String tmp = user.nameQ; t mp += \" \" + user・phone number(); t叩+= \" \" + user・emailQ; template.set(\"user info\", tmp);  生存期間は短いけど、この変数にとっていちばん大切なことは「一時的な保管」で はない。これをわかりやすくするには、user  infoのような名前に変えるといいだろ ｏ う 以下の例では、名前の一部にtmpを使っている。  tmpjile = tempﬁle.NamedTemporaryFileQ ● ● ●SaveData(tmp file,…  ファイルオブジェクトなので、ただのtmpではなくtmp  fileという名前になって  いる。これをtmpにしていたら、どうなっていただろうか。  SaveData(t叩…  この行だけを見ると、tmpがファイルなのか、ファイル名なのか、データなのかが  わからない。  ア ド バ イ ス tmpという名前は、生存期間が短くて、一時的な保管が最も大切な変数にだけ使おうʻ  ルーブイテレータ ｉ・』ｋ・iterなどの名前は、インデックスやループイテレータでよく使われてい る。汎用的な名前だけど、これだけで「ぼくはイテレータ」という意味になるので匿 題ないそれ以外の目的に使うとまぎらわしくなるのでやめよう  でも、ｉ・j-kよりいい名前がある。例えば、クラブに所属しているユーザを調べ  るループを見てみよう。  for (int i = ; i < clubs.sizeQ; i++)  for (int j = ; j < clubs[i]・members.sizeQ; i++)  for (int k = ; k < users.sizeQ; k++)  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(34,1,33,'2.2   tmpや｢etvalなどの汎用的な名前を避ける１５\n\ni\nf (clubs[i].members[k] == usersn])\n\neout   \"user[\"   j   \"] is in club[\"   i   \"]\"   endl;\n\nif文にあるmembers[]とusers[1のインデックスが逆になっている。そこだけ見\n\nると問題がなさそうに見えるので、バグを見つけるのが難しい。\n\ni\nf (clubsﬁl.membersfkl == usersHl)\n\nイテレータが複数あるときには、インデックスにもっと明確な名前をつけるといい\nだろう。i-j-kではなく、説明的な名前（clubi･membersi・usersi）にするの\nだ。あるいは、もっと簡潔なもの（ｃｉ・ｍｉ・ｕｉ）でもいいだろう。こうすればバグが\n目立ちやすくなる。\n\ni\nf (clubsfcil・members[ui] == users[mi])   #バグだ!最初の文字が違ってる。\n\nインデックスの最初の文字は、配列の名前の最初の文字と同じになるのが正しい。\n\ni\nf (clubsfcil.members[mi] == users[ui]) # OK.最初の文字が同じだ。\n\n汎用的な名前のまとめ\n\nこれまで見てきたように、汎用的な名前が役に立つこともある。\n\nア ド バ イ ス\ntmp・it・retvalのような汎用的な名前を使うときは、それ相応の理由を用意しよう。\n\nただし、単なる怠\'慢で使われていることも多い。いい名前が思いつかなかったら、\nfooのような意味のない名前を使いたくなってしまうものだ。だけど、少しでも時間\nを使っていい名前を考える習慣をつけるようにすれば、すぐに「命名力」の高まりが\n感じられるようになるだろう。\n\n','.   tmpや｢etvalなどの汎用的な名前を避ける  i f (clubs[i].members[k] == usersn])  eout   \"user[\"   j   \"] is in club[\"   i   \"]\"   endl;  if文にあるmembers[]とusers[のインデックスが逆になっている。そこだけ見  ると問題がなさそうに見えるので、バグを見つけるのが難しい。  i f (clubsﬁl.membersfkl == usersHl)  イテレータが複数あるときには、インデックスにもっと明確な名前をつけるといい だろう。i-j-kではなく、説明的な名前clubi･membersi・usersiにするの だ。あるいは、もっと簡潔なものｃｉ・ｍｉ・ｕｉでもいいだろう。こうすればバグが 目立ちやすくなる。  i f (clubsfcil・members[ui] == users[mi])   #バグだ!最初の文字が違ってる。  インデックスの最初の文字は、配列の名前の最初の文字と同じになるのが正しい。  i f (clubsfcil.members[mi] == users[ui]) # OK.最初の文字が同じだ。  汎用的な名前のまとめ  これまで見てきたように、汎用的な名前が役に立つこともある。  ア ド バ イ ス tmp・it・retvalのような汎用的な名前を使うときは、それ相応の理由を用意しよう。  ただし、単なる怠\'慢で使われていることも多い。いい名前が思いつかなかったら、 fooのような意味のない名前を使いたくなってしまうものだ。だけど、少しでも時間 を使っていい名前を考える習慣をつけるようにすれば、すぐに「命名力」の高まりが 感じられるようになるだろう。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(35,1,34,'１６１２章名前に情報を詰め込む\n\n２３抽象的な名前よりも具体的な名前を使う\n\n９\n\n、\n、\n\n変数や関数などの構成要素の名前は、抽象的ではなく具体的なものにしよう。\n例えば､ServerCanStartf)という名前のメソッドがあったとする。任意\nのTCP/IPポートをサーバがリッスンできるかを確認するメソッドである。で\nも、ServerCanStartf)という名前はちょっと抽象的だ。具体的な名前にすれば、\nCanListenOnPort()になるだろう。これならメソッドの動作をそのまま表している。\n\n以下の２つの例は、この考えを詳しく示したものだ。\n\n','章名前に情報を詰め込む  抽象的な名前よりも具体的な名前を使う    、 、  変数や関数などの構成要素の名前は、抽象的ではなく具体的なものにしよう。 例えば､ServerCanStartf)という名前のメソッドがあったとする。任意 のTCP/IPポートをサーバがリッスンできるかを確認するメソッドである。で も、ServerCanStartf)という名前はちょっと抽象的だ。具体的な名前にすれば、 CanListenOnPort()になるだろう。これならメソッドの動作をそのまま表している。  以下のつの例は、この考えを詳しく示したものだ。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(36,1,35,'２３抽象的な名前よりも具体的な名前を使うʼ１７\n\n例:  DISALLOW  EVIL  CONSTRUCTORS\nこれはGoogle社から持ってきたコードだ。C++のクラスでは、コピーコンストラ\nクタと代入演算子を再定義しないと、デフオルトの設定が使われてしまう。お手軽な\nのはいいけれど、デフオルトのメソッドだとメモリリークなどの問題につながる可能\nʼ性がある。みんなが気づかない「舞台裏」で実行されてしまうからだ。\n\nそのためGoogle社では、こうした「悪の」コンストラクタを許可しない規約を作\n\nり、マクロを使って対応している。\n\nc\nl\nass ClassName {\nprivate:\nD\nI\nSALLOW EVIL CONSTRUCTORS(ClassName)\n\npublic:\n\nのマクロは以下のように定義されている\n\n； こ\n\n}\n\n#deﬁne DISALLOW EVIL CONSTRUCTORS(ClassName >\n\nC\nl\nassName(const ClassName&)ハ\nvoid operator=(const ClassNameS);\n\nこのマクロをクラスのprivate:に置くと、２つのメソッドがプライベートになる。\n\nこうすれば、間違ってメソッドを使うことはない。\n\nでも、DISALLOW EVIL CONSTRUCTORSという名前があまりよくない。「EVIL (悪の)」\nという言葉には、必要以上に強い意志を感じてしまう。そんなことよりも、このマク\nロが「許可していないもの」を明確にするほうが大切だ。実際にはoperator=()メ\nソッドも許可していない。このメソッドは「CONSTRUCTORS (コンストラクタ)」\nではないのだ！\n\n長年使用されてきた名前だったけど、最終的にはあまり刺激的ではなく、より具体\n\n的な名前に変更されることになった。\n\n#define DISALLOW COPY_AND_ASSIGN(ClassName)．.ʻ\n\n','抽象的な名前よりも具体的な名前を使うʼ  例:  DISALLOW  EVIL  CONSTRUCTORS これはGoogle社から持ってきたコードだ。C++のクラスでは、コピーコンストラ クタと代入演算子を再定義しないと、デフオルトの設定が使われてしまう。お手軽な のはいいけれど、デフオルトのメソッドだとメモリリークなどの問題につながる可能 ʼ性がある。みんなが気づかない「舞台裏」で実行されてしまうからだ。  そのためGoogle社では、こうした「悪の」コンストラクタを許可しない規約を作  り、マクロを使って対応している。  c l ass ClassName { private: D I SALLOW EVIL CONSTRUCTORS(ClassName)  public:  のマクロは以下のように定義されている   こ  }  #deﬁne DISALLOW EVIL CONSTRUCTORS(ClassName >  C l assName(const ClassName&)ハ void operator=(const ClassNameS);  このマクロをクラスのprivate:に置くと、つのメソッドがプライベートになる。  こうすれば、間違ってメソッドを使うことはない。  でも、DISALLOW EVIL CONSTRUCTORSという名前があまりよくない。「EVIL (悪の)」 という言葉には、必要以上に強い意志を感じてしまう。そんなことよりも、このマク ロが「許可していないもの」を明確にするほうが大切だ。実際にはoperator=()メ ソッドも許可していない。このメソッドは「CONSTRUCTORS (コンストラクタ)」 ではないのだ  長年使用されてきた名前だったけど、最終的にはあまり刺激的ではなく、より具体  的な名前に変更されることになった。  #define DISALLOW COPY_AND_ASSIGN(ClassName).ʻ  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(37,1,36,'１８       2章名前に情報を詰め込む\n\n例:  -run  locally\nぼくたちのプログラムには、--run  locallyという名前のコマンドオプションが\nあった。このオプションをつけると、プログラムがデバッグ情報を印字するようにな\nる。ただし、動作は遅くなってしまう。このオプションは、デスクトップなどのロー\nカルマシンでテストをするときに使っていた。リモートサーバで動かすときにはパ\nフォーマンスが重要になるので使わなかった。\n\n--runJLocallyの名前の由来はわかったと思う。でも、これには問題があった。\n\n●\n\n●\n\n●\n\nまず、新しいチームメンバがこのオプションを理解できなかった。ローカル\nで動かすときには使っていたようだけど（名前から推測したのだろう)、ど\nうしてこれが必要なのかはわかっていなかった。\n\nリモートで動かすときにデバッグ情報を印字したいこともある。そんなとき\nは、リモートで動いているプログラムに--run_locallyオプションを渡す。\nリモートなのに「locally」ってなんだか変な感じだ。すごくまぎらわしい。\n\nローカルでパフォーマンステストをしたいこともある。そんなときは、動\n作の遅くなるロギング機能は使いたくない。だから、ローカルで動かすけ\nど、--run  locallyは使わない。\n\n--run  locallyに環境の名前が入っているのが問題なのだ。--extra_loggingとい\n\nう名前のほうが直接的で明確だ。\n\nでも、--run_locallyの機能がロギングだけじゃなかったらどうしよう？例えば、\nローカル用の特別なデータベースを設定して使う必要があったとしよう。それなら両\n方の機能を表現できている--run  locallyでもいいような気がしてくる。\n\nでも、名前と目的が合っていない。あいまいだし間接的だ。ここでは、--use\nlocal  databaseのようなオプションを用意するといいだろう。オプションは２つに\n増えるけど、それぞれの意味は明確だ。直交する概念は無理に１つにまとめようと\nせずに、別々に使えるようにするといい。\n\n','       章名前に情報を詰め込む  例:  -run  locally ぼくたちのプログラムには、--run  locallyという名前のコマンドオプションが あった。このオプションをつけると、プログラムがデバッグ情報を印字するようにな る。ただし、動作は遅くなってしまう。このオプションは、デスクトップなどのロー カルマシンでテストをするときに使っていた。リモートサーバで動かすときにはパ フォーマンスが重要になるので使わなかった。  --runJLocallyの名前の由来はわかったと思う。でも、これには問題があった。  ●  ●  ●  まず、新しいチームメンバがこのオプションを理解できなかった。ローカル で動かすときには使っていたようだけど名前から推測したのだろう)、ど うしてこれが必要なのかはわかっていなかった。  リモートで動かすときにデバッグ情報を印字したいこともある。そんなとき は、リモートで動いているプログラムに--run_locallyオプションを渡す。 リモートなのに「locally」ってなんだか変な感じだ。すごくまぎらわしい。  ローカルでパフォーマンステストをしたいこともある。そんなときは、動 作の遅くなるロギング機能は使いたくない。だから、ローカルで動かすけ ど、--run  locallyは使わない。  --run  locallyに環境の名前が入っているのが問題なのだ。--extra_loggingとい  う名前のほうが直接的で明確だ。  でも、--run_locallyの機能がロギングだけじゃなかったらどうしよう例えば、 ローカル用の特別なデータベースを設定して使う必要があったとしよう。それなら両 方の機能を表現できている--run  locallyでもいいような気がしてくる。  でも、名前と目的が合っていない。あいまいだし間接的だ。ここでは、--use local  databaseのようなオプションを用意するといいだろう。オプションはつに 増えるけど、それぞれの意味は明確だ。直交する概念は無理につにまとめようと せずに、別々に使えるようにするといい。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(38,1,37,'２４名前に情報を追加するʼ１９\n\n２４名前に情報を追加する\n\n３\n\n|\n①\n砺\n\n劃瑚\n\n前にも言ったけど、名前は短いコメントのようなものだ。変数名に詰め込める情報\nはあまり多くない。だけど、名前につけた情報は変数を見るたびに目に入ってくる。\nだから、もし絶対に知らせなきゃいけない大切な情報があれば、「単語」を変数名\n\nに追加すればいい。例えば、１６進数の文字列を持つ変数について考えてみよう。\n\n','名前に情報を追加するʼ  名前に情報を追加する    | ① 砺  劃瑚  前にも言ったけど、名前は短いコメントのようなものだ。変数名に詰め込める情報 はあまり多くない。だけど、名前につけた情報は変数を見るたびに目に入ってくる。 だから、もし絶対に知らせなきゃいけない大切な情報があれば、「単語」を変数名  に追加すればいい。例えば、進数の文字列を持つ変数について考えてみよう。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(39,1,38,'２０１２章名前に情報を詰め込む\n\nstring id;   //例: \"af84ef845cd8\"\n\nIDのフォーマットが大切なら、名前をhex  idにするといい\n\n値の単位\n時間やバイト数のように計;\"Iできるものであれば、変数名に単位を入れるといいだ\n\n例えば、ウェブページの読み込み時間を計測するJavaScriptのコードを見てみよ\n\nar start = (new Date()).getTime():   //ページの上部\nvar elapsed = (new Date()).getTime() - start:   //ページの下部\ndocument.writeln(Ⅲ読み込み時間: \" + elapsed +Ⅲ秒Ⅲ;\n\n。 v\n\nう\n\nこのコードは間違っていないように見える。でも、これではうまく動かない［\n\nget!加e()が秒ではなく、ミリ秒を返すからだ。\n\n変数名にmsを迫力I!すればlﾘ1碓になる。\n\nvar startjis = (new Date()).getTime():   //ページの上部\nvar elapsedjns = (new Date()).getTime() - start ms;   //ページの下部\ndocument.writeln(\"読み込み時間: \" + elapsed ms / 1000 +Ⅲ秒Ⅲ)l\n\n時間以外にもプログラミングで使う単位はたくさんある。以下の表は、単位のない\n\n仮引数と、単位を追加したよりよいバージョンの仮引数を示したものだ。\n\n箪教の仮冨 数\n|\n単位を 追加した仮引数\nStart(int delay)\ndelay→delay sees\nCreateCache(intsize)\nＳ１ｚｅ→size mb\nThrottleDownload(float limit) limit→max kbps\nRotate(ﬂoat angle)\nangle→degrees cw\n\n­\n\n夕\n\n画わつｏ\n\n','章名前に情報を詰め込む  string id;   //例: \"afefcd\"  IDのフォーマットが大切なら、名前をhex  idにするといい  値の単位 時間やバイト数のように計;\"Iできるものであれば、変数名に単位を入れるといいだ  例えば、ウェブページの読み込み時間を計測するJavaScriptのコードを見てみよ  ar start = (new Date()).getTime():   //ページの上部 var elapsed = (new Date()).getTime() - start:   //ページの下部 document.writeln(Ⅲ読み込み時間: \" + elapsed +Ⅲ秒Ⅲ;  。 v  う  このコードは間違っていないように見える。でも、これではうまく動かない［  get!加e()が秒ではなく、ミリ秒を返すからだ。  変数名にmsを迫力I!すればlﾘ碓になる。  var startjis = (new Date()).getTime():   //ページの上部 var elapsedjns = (new Date()).getTime() - start ms;   //ページの下部 document.writeln(\"読み込み時間: \" + elapsed ms /  +Ⅲ秒Ⅲ)l  時間以外にもプログラミングで使う単位はたくさんある。以下の表は、単位のない  仮引数と、単位を追加したよりよいバージョンの仮引数を示したものだ。  箪教の仮冨 数 | 単位を 追加した仮引数 Start(int delay) delay→delay sees CreateCache(intsize) Ｓｚｅ→size mb ThrottleDownload(float limit) limit→max kbps Rotate(ﬂoat angle) angle→degrees cw  ­  夕  画わつｏ  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(40,1,39,'２４名前に情報を追加するʼ２\n\nその他の重要な属Ｉ性を追加する\n変数名に追加する情州は単位だけではない。危険や注意を喚起する情報も迫力IIした\n\nほうがいい。\n\n例えば、セキュリティ問題の多くは、プログラムの受信するデータが安全で\nはないことが原因で発生している。このようなデータには、untrustedUrl  ^\nunsafeMessageBodyなどの変数名を使うといいだろう。データを安全にする関数を呼\nび出したあとは、変数*ＩをtrustedUrl ^ safeMessageBodyにするといい。\n\n以下の表は、情報を変数名に追加したほうがいい例を示している。\n\n|\n鞍況\npasswordはプレインテキストなので、処JI1をする前に\n暗号化すべきである。\nユーザが人ﾉJしたcommentは衣示するilHにエスケープ\nする必典がある：\nhtmlの文字コードをUTF-8に変えた\n入力されたdataをURI,エンコードした。\n\n変 数 名 Ｉ 改 善 後\ns\na\np\ns\nword\n\nplaintext_password\n\nｃｏｍｍｅ、之\n\nunescaped comment\n\nhtml\nd\na\nt\na\n\nhtml utf8\ndata urlenc\n\nすべての変数名にunescaped-やーutf8などの屈性を追加しろということではない曇\n変数の意味を間違えてしまったときにバグになりそうなところにだけ使うことが大切\nだ。特にセキュリティのバグのような深刻な被害が川るところに使うといいだろう。韮\n本的には、変数の意味を理解してもらわなければ困るところに属性を追加しておこう。\n\nこれってハンガリアン記法なの？\n\nハンガリアン記法というのは、Microsoft社で広く使われていた命名規則だ。すべての\n\n変数名の接頭辞に「型」をつける。例えば、こんな感じだ。\n|変数名#意味\n\nptastあるデータ構造の雌後の要素を指すポインタ(p)\npszBufferゼロ終端(z)の文字列(s)バッファを脂すポインタ(p)\ncch\nmpcopx\n\nX-i-  (ch)のカウントc\nカラーのポインタ(pco>からX  \'Illlのポインタ(px)を脂すマップm\n\n','名前に情報を追加するʼ  その他の重要な属Ｉ性を追加する 変数名に追加する情州は単位だけではない。危険や注意を喚起する情報も迫力IIした  ほうがいい。  例えば、セキュリティ問題の多くは、プログラムの受信するデータが安全で はないことが原因で発生している。このようなデータには、untrustedUrl  ^ unsafeMessageBodyなどの変数名を使うといいだろう。データを安全にする関数を呼 び出したあとは、変数*ＩをtrustedUrl ^ safeMessageBodyにするといい。  以下の表は、情報を変数名に追加したほうがいい例を示している。  | 鞍況 passwordはプレインテキストなので、処JIをする前に 暗号化すべきである。 ユーザが人ﾉJしたcommentは衣示するilHにエスケープ する必典がある htmlの文字コードをUTF-に変えた 入力されたdataをURI,エンコードした。  変 数 名 Ｉ 改 善 後 s a p s word  plaintext_password  ｃｏｍｍｅ、之  unescaped comment  html d a t a  html utf data urlenc  すべての変数名にunescaped-やーutfなどの屈性を追加しろということではない曇 変数の意味を間違えてしまったときにバグになりそうなところにだけ使うことが大切 だ。特にセキュリティのバグのような深刻な被害が川るところに使うといいだろう。韮 本的には、変数の意味を理解してもらわなければ困るところに属性を追加しておこう。  これってハンガリアン記法なの  ハンガリアン記法というのは、Microsoft社で広く使われていた命名規則だ。すべての  変数名の接頭辞に「型」をつける。例えば、こんな感じだ。 |変数名#意味  ptastあるデータ構造の雌後の要素を指すポインタ(p) pszBufferゼロ終端(z)の文字列(s)バッファを脂すポインタ(p) cch mpcopx  X-i-  (ch)のカウントc カラーのポインタ(pco>からX  \'Illlのポインタ(px)を脂すマップm  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(41,1,40,'２２１２章名前に情報を詰め込む\n\nこれも「名前に属性を追加」しているけれど、もっと厳密で規律のあるシステムだ。\n一方、本節でぼくたちが提唱しているのは、もっと大まかで規律の緩いシステムだ。必\n要なときにだけ変数の大切な属性を見つけ出して、それを読みやすくして名前に追加する．\nこれをハンガリアンならぬ「イングリッシュ記法」と呼んでもいいだろう。\n\n2.5名前の長さを決める\n\n９ ３\n\n(cid:7726)庸，司墨\n\nすごく長い名前の\nの\n\n道って宴紫\n道って宴業\n\nfﾐﾐﾐ^これだなこれ\n\n­\n\n： - ： ． ʼ\n\nロ\nロ\n\nー\n\n血一一一蝿\n園\n|\n\nロ\n\n一\n一\n一\n\n一室斑\n\nロ 回\n\n(cid:20291)百F\n\n＝ 蝋\n量\n臭量妥臭\n妥\n\nロ 画 ロ\n\n謁凹情=帝舌\nロ 『 詞 ｡ ０，０１こ競赫\n\n蹄埼玉吟忌恥;壁\n\nー\n\n１­１ 一\n\nいい名前を選ぶときには、「長い名前を避ける」という暗黙的な制約がある。以下\n\nのような識別子は、誰もが嫌がるだろう。\n\nnewNavigationControllerWrappingViewControllerForDataSourceOf Class\n\n長い名前は覚えにくいし、画面を大きく占領してしまう。折り返しが必要になれ\n\nば、コード行が無駄に増えてしまう。\n\nだけど、「長い名前を避ける」を真に受けてしまったら、１つの単語（あるいは１\n文字）だけの名前になってしまう。それじゃあ、どのあたりに線を引けばいいのだろ\nう？ｄ・ｄａｙｓ・days-Since-laSt-uPdateのなかから１つを選ぶにはどうすればいい\nだろう？\n\n','章名前に情報を詰め込む  これも「名前に属性を追加」しているけれど、もっと厳密で規律のあるシステムだ。 一方、本節でぼくたちが提唱しているのは、もっと大まかで規律の緩いシステムだ。必 要なときにだけ変数の大切な属性を見つけ出して、それを読みやすくして名前に追加する これをハンガリアンならぬ「イングリッシュ記法」と呼んでもいいだろう。  .名前の長さを決める     (cid:)庸司墨  すごく長い名前の の  道って宴紫 道って宴業  fﾐﾐﾐ^これだなこれ  ­   -   ʼ  ロ ロ  ー  血一一一蝿 園 |  ロ  一 一 一  一室斑  ロ 回  (cid:)百F   蝋 量 臭量妥臭 妥  ロ 画 ロ  謁凹情=帝舌 ロ 『 詞 ｡ こ競赫  蹄埼玉吟忌恥;壁  ー  ­ 一  いい名前を選ぶときには、「長い名前を避ける」という暗黙的な制約がある。以下  のような識別子は、誰もが嫌がるだろう。  newNavigationControllerWrappingViewControllerForDataSourceOf Class  長い名前は覚えにくいし、画面を大きく占領してしまう。折り返しが必要になれ  ば、コード行が無駄に増えてしまう。  だけど、「長い名前を避ける」を真に受けてしまったら、つの単語あるいは 文字だけの名前になってしまう。それじゃあ、どのあたりに線を引けばいいのだろ うｄ・ｄａｙｓ・days-Since-laSt-uPdateのなかからつを選ぶにはどうすればいい だろう  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(42,1,41,'２５名前の長さを決めるʼ２３\n\nそれは、変数の使い方によって違ってくる。でも、ガイドラインはある。\n\nス コ ー プ が 小 さ け れ ば 短 い 名 前 で も い い\n\n長期休暇よりも短期でどこかへ行くときのほうが荷物は少ないはずだ。それと伺じ\nで、識別子の「スコープ」（その名前が「見える」コードの行数）が小さければ、多\nくの情報を詰め込む必要はない。すべての情報（変数の型・初期値・破棄方法など）\nが見えるので、変数の名前は短くていい。\n\nという変数名にはあまり情報が含まれていない。でも、大丈夫。コードを理解す\n\nるのに必要な情報がすぐそばにあるからだ。\n\n、がクラスのメンバ変数やグローバル変数ならどうだろう。以下のようなコードを\n\n目にするかもしれない。\n\nLookUpNamesNumbers(&m);\nPrint(m);\n\nこのコードは読みにくい。ｍの型や目的がよくわからないからだ。\n識別子のスコープが大きければ、名前に十分な情報を詰め込んで明確にする必要が\n\nある。\n\n長い名前を入力するのは問題じゃない\n長い名前を避ける理由はいくつもある。でも、「入力しにくい」というのは、もは\nや理由にならない。プログラミングに使うテキストエディタには「単語補完」機能が\nついている。この機能を知らないプログラマは意外と多い。まだ使ったことがないな\nら、本書をひとまず横に置いて、すぐに試してみて欲しい。\n\n1．名前の最初の１文字を入力する。\n\n2．単語補完のコマンドを実行する（以下参照)。\n\ni\nf (debug) {\n\nmap<string,int> m;\nLookUpNamesNumbers(&m);\nPrint(m);\n\n｝ 、\n\n','名前の長さを決めるʼ  それは、変数の使い方によって違ってくる。でも、ガイドラインはある。  ス コ ー プ が 小 さ け れ ば 短 い 名 前 で も い い  長期休暇よりも短期でどこかへ行くときのほうが荷物は少ないはずだ。それと伺じ で、識別子の「スコープ」その名前が「見える」コードの行数が小さければ、多 くの情報を詰め込む必要はない。すべての情報変数の型・初期値・破棄方法など が見えるので、変数の名前は短くていい。  という変数名にはあまり情報が含まれていない。でも、大丈夫。コードを理解す  るのに必要な情報がすぐそばにあるからだ。  、がクラスのメンバ変数やグローバル変数ならどうだろう。以下のようなコードを  目にするかもしれない。  LookUpNamesNumbers(&m); Print(m);  このコードは読みにくい。ｍの型や目的がよくわからないからだ。 識別子のスコープが大きければ、名前に十分な情報を詰め込んで明確にする必要が  ある。  長い名前を入力するのは問題じゃない 長い名前を避ける理由はいくつもある。でも、「入力しにくい」というのは、もは や理由にならない。プログラミングに使うテキストエディタには「単語補完」機能が ついている。この機能を知らないプログラマは意外と多い。まだ使ったことがないな ら、本書をひとまず横に置いて、すぐに試してみて欲しい。  名前の最初の文字を入力する。  単語補完のコマンドを実行する以下参照)。  i f (debug) {  map<string,int> m; LookUpNamesNumbers(&m); Print(m);  ｝ 、  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(43,1,42,'２４１２章名前に情報を詰め込む\n\n3．補完された単語が正しくなければ、正しい名前が出現するまでコマンドを実\n\n行し続ける。\n\nこれがビックリするほど正確なんだ。どんなファイル形式でも、どんな言語でもう\nまくいく。それにどんなトークンにも使える。コメントを入力しているときでも大丈\n夫だ。\n\n!\n:\n熟鎮静\n\n|遥蕊ダ(cid:7767)繁wl譲弓毎Ｆ\nV\nｉ\nCtrl-p\nEmacs\nMela-/   (ESCをmしてから/)\nAll-/\nEclipse\nIntellU  IDEA All-/\n\'IExtMate\nESC\n\n頭文字と省略形\nプログラマは頭文字や省略形を使って名前を短くすることがある。例えば、クラス\n名をBackEndManagerじゃなくてBEManagerにしたりする。このように情報を圧縮す\nると混乱の元になるだろうか？\n\nぼくたちの経ʻ験からすると、プロジェクトIiVI有の省Un形はダメだ。新しくプロジェ\nクトに参加した人は、II普号みたいに見えて怖いと思うだろう。しばらくすると、それ\nを書いた人ですらII音号みたいで怖いと思うようになる。\n\n新しいチームメイトはその名前の意味を理解できるだろうか？剛ﾘｷできるなら|川\n\n題ない。\n\nプログラマは、evaluationの代わりにevalを使う。documentの代わりにdocを\n使う。stringの代わりにstrを使う。だから、新しいチームメイトもFormatStr(》\nの意味は理解できる。でも、BEManagerの意味は理解できない。\n\n不要な単語を投げ捨てる\n\n名前に含まれる単語を削除しても情報が全く損なわれないこともある。例えば、\nConvertToStringOを短くしてToStringOにしても、必要な情報は何も損なわれて\nいない。同様に、DoServeLoop()をServeLoop()に変えても明確さは|両lじだ。\n\n','章名前に情報を詰め込む  補完された単語が正しくなければ、正しい名前が出現するまでコマンドを実  行し続ける。  これがビックリするほど正確なんだ。どんなファイル形式でも、どんな言語でもう まくいく。それにどんなトークンにも使える。コメントを入力しているときでも大丈 夫だ。  ! : 熟鎮静  |遥蕊ダ(cid:)繁wl譲弓毎Ｆ V ｉ Ctrl-p Emacs Mela-/   (ESCをmしてから/) All-/ Eclipse IntellU  IDEA All-/ \'IExtMate ESC  頭文字と省略形 プログラマは頭文字や省略形を使って名前を短くすることがある。例えば、クラス 名をBackEndManagerじゃなくてBEManagerにしたりする。このように情報を圧縮す ると混乱の元になるだろうか  ぼくたちの経ʻ験からすると、プロジェクトIiVI有の省Un形はダメだ。新しくプロジェ クトに参加した人は、II普号みたいに見えて怖いと思うだろう。しばらくすると、それ を書いた人ですらII音号みたいで怖いと思うようになる。  新しいチームメイトはその名前の意味を理解できるだろうか剛ﾘｷできるなら|川  題ない。  プログラマは、evaluationの代わりにevalを使う。documentの代わりにdocを 使う。stringの代わりにstrを使う。だから、新しいチームメイトもFormatStr(》 の意味は理解できる。でも、BEManagerの意味は理解できない。  不要な単語を投げ捨てる  名前に含まれる単語を削除しても情報が全く損なわれないこともある。例えば、 ConvertToStringOを短くしてToStringOにしても、必要な情報は何も損なわれて いない。同様に、DoServeLoop()をServeLoop()に変えても明確さは|両lじだ。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(44,1,43,'２６名前のフオーマットで情報を伝えるʼ２５\n\n2.6名前のフオーマツトで情報を伝える\nアンダースコア・ダッシュ・大文字を使って、名前に情報を詰め込むこともでき\nる。例えば、Google社のオープンソースプロジェクトで使っているC++のフォー\nマット規約を見てみよう。\n\nstatic const int kMaxOpenFiles = IOO;\n\nass LogReader {\nc\nl\npublic:\nvoid OpenFile(string local_ﬁle);\n\nンティティごとに異なるフォーマットを使っている。一種のシンタックスハイラ\n\nイトと言えるかもしれない。これでコードが読みやすくなっている。\n\nこのフォーマットはよく使われているものだ。クラス名はCamelCase  (キャメル\nケース）で、変数名はlower separated (小文字をアンダースコアで区切ったもの)。\nでも、その他の規約にはビックリするかもしれない。\n\n例えば、定数はCONSTANT NAMEではなくkConstantNameになっている。MACRO\n\nNAMEのような#defineマクロと簡単に区別できるからだ。\n\nクラスのメンバ変数は、一見普通の変数のように見えるけど、offsetのように最\n後の文字がアンダースコアになっている。ぼくたちも最初は奇妙に思ったけど、普通\nの変数と区別できるので便利だ。例えば、長いメソッドを読んでいると、以下のよう\nなコードが目に入ってくる。\n\nstats・clear\n\n普通なら「statsはクラスのメンバ変数かな？これはクラスの内部状態を変える\nコードなんだろうか？」などと考えるだろう。メンバ変数をmemberにする規約を\n守っていれば、「メンバ変数じゃない。このstatsはローカル変数だ」とすぐにわか\nる。クラスのメンバ変数ならstatsになるからだ。\n\nprivate:\nint  oﬀset  ;\nD\nI\nSALLOW COPY AND ASSICN(LogReader):\n\n） エ\n\n','名前のフオーマットで情報を伝えるʼ  .名前のフオーマツトで情報を伝える アンダースコア・ダッシュ・大文字を使って、名前に情報を詰め込むこともでき る。例えば、Google社のオープンソースプロジェクトで使っているC++のフォー マット規約を見てみよう。  static const int kMaxOpenFiles = IOO;  ass LogReader { c l public: void OpenFile(string local_ﬁle);  ンティティごとに異なるフォーマットを使っている。一種のシンタックスハイラ  イトと言えるかもしれない。これでコードが読みやすくなっている。  このフォーマットはよく使われているものだ。クラス名はCamelCase  (キャメル ケースで、変数名はlower separated (小文字をアンダースコアで区切ったもの)。 でも、その他の規約にはビックリするかもしれない。  例えば、定数はCONSTANT NAMEではなくkConstantNameになっている。MACRO  NAMEのような#defineマクロと簡単に区別できるからだ。  クラスのメンバ変数は、一見普通の変数のように見えるけど、offsetのように最 後の文字がアンダースコアになっている。ぼくたちも最初は奇妙に思ったけど、普通 の変数と区別できるので便利だ。例えば、長いメソッドを読んでいると、以下のよう なコードが目に入ってくる。  stats・clear  普通なら「statsはクラスのメンバ変数かなこれはクラスの内部状態を変える コードなんだろうか」などと考えるだろう。メンバ変数をmemberにする規約を 守っていれば、「メンバ変数じゃない。このstatsはローカル変数だ」とすぐにわか る。クラスのメンバ変数ならstatsになるからだ。  private: int  oﬀset  ; D I SALLOW COPY AND ASSICN(LogReader):   エ  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(45,1,44,'２６１２章名前に情報を詰め込む\n\nその他のフォーマット規約\nプロジェクトや言語によって使えるフオーマット規約は違ってくる。なかにはより\n\n多くの情報を詰め込める規約もある。\n\n例えば、fJavaScript: The Good PartsJ  (Douglas Crocl(cid:8267)brd, O\'Reilly, 2008)↑で\nは、「コンストラクタ」(newを使って呼び出される関数）は大文字で始め、通常の関\n数は小文字で始めるように著者が提唱している。\n\nvar x = new DatePickerQ: // DatePickerQは「コンストラクタ」関数\nvar y = pageHeightQ;\n\n// pageHeightQは通常の関数\n\nその他にもJavaScriptでは、jQueryのライブラリ関数($だけの関数）を呼び出\nしたときには、変数名の頭に＄をつけるというものがある。\n\nvar $all_images = $(\"img\"); // $all imagesはjQueryのオブジエクト\nvar  height  =  250; //  heightは違う\n\nこうすれば、$all imagesがjQueryのオブジェクトだと明確にわかる。\n最後にHTMLとCSSの例を紹介しよう。HTMLタグのidやclassなどの属性名\nには、アンダースコアやハイフンも妥当な文字として使うことができる。ただし、id\nの区切り文字にはアンダースコアを、classの区切り文字にはハイフンを使う規約が\n有力だ。\n\n<div id= middle column\" class=\"main-content\"> ...\n\nー\n\n以上のような規約を使うかどうかは、自分自身やチームで決めるといい。どんなも\n\nのを使うにしても、プロジェクトで一貫性を持たせることが大切だ。\n\n2 . 7 ま と め\n本章のテーマは「名前に情報を詰め込む」だった。つまり、名前を見ただけで情報\n\nを読み取れるようにすることだ。\n\n以下は、ぼくたちが説明したヒントだ。\n\n↑訳注[JavaScript:  The  Good  Parts-「良いパーツ」によるベストプラクテイス」（ダグラス・クロック\n\nフォード著、水野貴明訳、オライリー・ジャパン）\n\n','章名前に情報を詰め込む  その他のフォーマット規約 プロジェクトや言語によって使えるフオーマット規約は違ってくる。なかにはより  多くの情報を詰め込める規約もある。  例えば、fJavaScript: The Good PartsJ  (Douglas Crocl(cid:)brd, O\'Reilly, )↑で は、「コンストラクタ」(newを使って呼び出される関数は大文字で始め、通常の関 数は小文字で始めるように著者が提唱している。  var x = new DatePickerQ: // DatePickerQは「コンストラクタ」関数 var y = pageHeightQ;  // pageHeightQは通常の関数  その他にもJavaScriptでは、jQueryのライブラリ関数($だけの関数を呼び出 したときには、変数名の頭にをつけるというものがある。  var $all_images = $(\"img\"); // $all imagesはjQueryのオブジエクト var  height  =  ; //  heightは違う  こうすれば、$all imagesがjQueryのオブジェクトだと明確にわかる。 最後にHTMLとCSSの例を紹介しよう。HTMLタグのidやclassなどの属性名 には、アンダースコアやハイフンも妥当な文字として使うことができる。ただし、id の区切り文字にはアンダースコアを、classの区切り文字にはハイフンを使う規約が 有力だ。  <div id= middle column\" class=\"main-content\"> ...  ー  以上のような規約を使うかどうかは、自分自身やチームで決めるといい。どんなも  のを使うにしても、プロジェクトで一貫性を持たせることが大切だ。   .  ま と め 本章のテーマは「名前に情報を詰め込む」だった。つまり、名前を見ただけで情報  を読み取れるようにすることだ。  以下は、ぼくたちが説明したヒントだ。  ↑訳注[JavaScript:  The  Good  Parts-「良いパーツ」によるベストプラクテイス」ダグラス・クロック  フォード著、水野貴明訳、オライリー・ジャパン  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(46,1,45,'２７まとめʼ２】\n\n●明確な単語を選ぶ。­例えば、Getではなく、状況に応じてFetch  <\n\nDownloadなどを使う。\n\n●tmpやretvalなどの汎用的な名前を避ける。­ただし、明確な理由があ\n\n●\n\n●\n\n●\n\nれば話は別だ。\n具体的な名前を使って、物事を詳細に説明する。­ServerCanStartf) J:\nりもCanListenOnPort()のほうが明確だ。\n変数名に大切な情報を追加する。­ミリ秒を表す変数名には、後ろにｍｓ\nをつける。これからエスケープが必要な変数名には、前にrawをつける。\n\nスコープの大きな変数には長い名前をつける。­スコープが数画面に及ぶ\n変数に１〜２文字の短い暗号めいた名前をつけてはいけない。短い名前は\nスコープが数行の変数につけるべきだ。\n\n●大文字やアンダースコアなどに意味を含める。­例えば、クラスのメンノ\n\n変数にアンダースコアをつけて、ローカル変数と区別する。\n\n','まとめʼ】  ●明確な単語を選ぶ。­例えば、Getではなく、状況に応じてFetch  <  Downloadなどを使う。  ●tmpやretvalなどの汎用的な名前を避ける。­ただし、明確な理由があ  ●  ●  ●  れば話は別だ。 具体的な名前を使って、物事を詳細に説明する。­ServerCanStartf) J: りもCanListenOnPort()のほうが明確だ。 変数名に大切な情報を追加する。­ミリ秒を表す変数名には、後ろにｍｓ をつける。これからエスケープが必要な変数名には、前にrawをつける。  スコープの大きな変数には長い名前をつける。­スコープが数画面に及ぶ 変数に〜文字の短い暗号めいた名前をつけてはいけない。短い名前は スコープが数行の変数につけるべきだ。  ●大文字やアンダースコアなどに意味を含める。­例えば、クラスのメンノ  変数にアンダースコアをつけて、ローカル変数と区別する。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(47,1,46,'ʼ２９\n\n零章\n誤解されない名前\n\n','ʼ  零章 誤解されない名前  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(48,1,47,'３０１３章誤解されない名前\n\n前章では、名前に情報を詰め込むことについて触れた。本章では、また違った話題\n\nに触れたいと思う。それは「誤解される名前に気を付けろ」だ。\n\n(cid:20276)となる考え\n名前が「他の意味と間違えられることはないだろうか？」と何度も自問自答する。\n\nここではクリエイティブになって欲しい。積極的に「誤解」を探していくのだ。そ\n\nうすれば変更が必要なあいまいな名前が見つかるだろう。\n\n本章に登場する例では、誤解する可能性を「ひとりごと」で確認してから、名前を\n\n選ぶようにしている。\n3.1例: filter()\nデータベースの問い合わせ結果を処理するコードを書いているとしよう。\n\nresults = Database・all_objects.filter(\"year <= 2011\")\n\nこのresultsには何が含まれているだろうか？\n\n●「year <= 2011」のオブジエクト\n\n●「year <= 2011」ではないオブジェクト\n\nどちらかよくわからないのは、filterがあいまいな言葉だからだ。これでは「選\n択する」のか「除外する」のかわからない。filterという名前は避けるべきだ。簡\n単に誤解を招いてしまう。\n\n「選択する」のであれば､select()にしたほうがいい。「除外する」のであれば、\n\nexcludeQにしたほうがいい。\n3.2例: Clip(text, length)\n\n段落の内容を切り抜く関数があるとしよう。\n\n# textの最後を切り落として、「…」をつける\ndef Clip(text, length):\n\n● ● ●\n\n','章誤解されない名前  前章では、名前に情報を詰め込むことについて触れた。本章では、また違った話題  に触れたいと思う。それは「誤解される名前に気を付けろ」だ。  (cid:)となる考え 名前が「他の意味と間違えられることはないだろうか」と何度も自問自答する。  ここではクリエイティブになって欲しい。積極的に「誤解」を探していくのだ。そ  うすれば変更が必要なあいまいな名前が見つかるだろう。  本章に登場する例では、誤解する可能性を「ひとりごと」で確認してから、名前を  選ぶようにしている。 .例: filter() データベースの問い合わせ結果を処理するコードを書いているとしよう。  results = Database・all_objects.filter(\"year <= \")  このresultsには何が含まれているだろうか  ●「year <= 」のオブジエクト  ●「year <= 」ではないオブジェクト  どちらかよくわからないのは、filterがあいまいな言葉だからだ。これでは「選 択する」のか「除外する」のかわからない。filterという名前は避けるべきだ。簡 単に誤解を招いてしまう。  「選択する」のであれば､select()にしたほうがいい。「除外する」のであれば、  excludeQにしたほうがいい。 .例: Clip(text, length)  段落の内容を切り抜く関数があるとしよう。  # textの最後を切り落として、「…」をつける def Clip(text, length):  ● ● ●  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(49,1,48,'３３限界値を含めるときはminとmaxを使う31\n\nl\nC\ni\npの動作は２つ考えられる。\n\n●最後からlength文字を削除する(remove)\n\n●最大length文字まで切り詰める(truncate)\n\n後者のような気もするけど、確実なことは言えない。読み手に疑問を抱かせるより\nも、関数名をTruncateftext, length)に変えるほうがいい。\n\nそれから、lengthという名前もダメだ。max lengthにしたほうが明確になる。\nこれで終わりじゃない。max lengthもいろんな解釈ができる。\n\n● バ イ ト 数\n\n● 文 字 数\n\n● 単 語 数\n\n前章で触れたように、ここでは名前に単位をつけたほうがいい。この場合は「文字\n\n数」を意味しているので、max lengthではなくmax_charsにするといいだろう。\n3.3限界値を含めるときはminとmaxを使う\nショッピングカートには商品が１０点までしか入らないとしよう。\n\n一\n\n一\n\nCART TOO BIG LIMIT = 10\ni\nf shopping_cart.num_items() >= CART_TOO_BIC_LIMIT:\n\n一\n\n­\n\nError(\"カートにある商品数が多すぎます。\"\n\nー\n\n­\n\nこのコードには古典的な「off-by-oneエラー↑」のバグがある。これを修正するに\n\nは＞＝を＞に変えればいい。\n\ni\nf shopping cart.num items() > CART_TOO_BIG_LIMIT:\n\n一\n\n一\n\nー\n\n(あるいはCART TOO BIG LIMITを11に変えてもいい｡）だけど、ここでの根本的\n\n■\n\n­\n\n■\n\n■\n\n■\n\n■\n\n■\n\n■\n\n■\n\n↑訳注境界条件の判定に関するエラー（参考: http://ia.wikipedia.org/wiki/Off-by-oneエラー)。\n\n','限界値を含めるときはminとmaxを使う  l C i pの動作はつ考えられる。  ●最後からlength文字を削除する(remove)  ●最大length文字まで切り詰める(truncate)  後者のような気もするけど、確実なことは言えない。読み手に疑問を抱かせるより も、関数名をTruncateftext, length)に変えるほうがいい。  それから、lengthという名前もダメだ。max lengthにしたほうが明確になる。 これで終わりじゃない。max lengthもいろんな解釈ができる。  ● バ イ ト 数  ● 文 字 数  ● 単 語 数  前章で触れたように、ここでは名前に単位をつけたほうがいい。この場合は「文字  数」を意味しているので、max lengthではなくmax_charsにするといいだろう。 .限界値を含めるときはminとmaxを使う ショッピングカートには商品が点までしか入らないとしよう。  一  一  CART TOO BIG LIMIT =  i f shopping_cart.num_items() >= CART_TOO_BIC_LIMIT:  一  ­  Error(\"カートにある商品数が多すぎます。\"  ー  ­  このコードには古典的な「off-by-oneエラー↑」のバグがある。これを修正するに  はをに変えればいい。  i f shopping cart.num items() > CART_TOO_BIG_LIMIT:  一  一  ー  (あるいはCART TOO BIG LIMITをに変えてもいい｡だけど、ここでの根本的  ■  ­  ■  ■  ■  ■  ■  ■  ■  ↑訳注境界条件の判定に関するエラー参考: エラー)。  ','2017-11-20 15:02:15','2017-11-20 15:02:15'),(50,1,49,'３２１３章誤解されない名前\n\nな問題は、CART TOO BIG LIMITという名前があいまいなことだ。これでは「未湖（限\n界値を含まない)」なのか「以下（限界値を含む)」なのかがわからない。\n\nアドバイス\n限界値を明確にするには、名前の前にmax  ¥> minをつけよう二\n\nこの場合は、MAX ITEMS IN CARTという名前にするべきだ。こうすればコードがよ\n\nり明確になる。\n\nMAX ITEMS IN CART = 10\n\ni\nf shopping_cart.nLiin itemsQ > MAX ITEMS IN CART\n\nError(Ⅲカートにある商品数が多すぎます。Ⅲ）\n\n3国４範囲を指定するときはfirstとlastを使う\n\nﬁ r s t\n\nlasす\n\na bｺﾆdコ\n↓\n\n↓\n\n｢未(cid:7665)」と「以下」の例は他にもある\n\nprint integer range(start=2, stop=4)\n＃これが印字するのは、［2,3］？それとも[2,3,4]？（あるいはその他？＞\n\nstartは適切な名前だ。でも、stopは複数の意味に解釈できる。\n包含的な範囲を表すのであれば（終端を範囲に含めるのであれば)、firstとlast\n\nを使うのがいい。例えば、以下のようになる。\n\nset.PrintKeys(ﬁrst=\"Bart\", last=\"Maggie\")\n\nstopではなくlastを使えば、包含していることがIﾘ1確になる。\n意味的に「正しく聞こえる」のであれば､firstとlast以外にもminとｍａｘを使っ\n\nて包含的範囲を表すことができる。\n\n','章誤解されない名前  な問題は、CART TOO BIG LIMITという名前があいまいなことだ。これでは「未湖限 界値を含まない)」なのか「以下限界値を含む)」なのかがわからない。  アドバイス 限界値を明確にするには、名前の前にmax  ¥> minをつけよう二  この場合は、MAX ITEMS IN CARTという名前にするべきだ。こうすればコードがよ  り明確になる。  MAX ITEMS IN CART =   i f shopping_cart.nLiin itemsQ > MAX ITEMS IN CART  Error(Ⅲカートにある商品数が多すぎます。Ⅲ  国範囲を指定するときはfirstとlastを使う  ﬁ r s t  lasす  a bｺﾆdコ ↓  ↓  ｢未(cid:)」と「以下」の例は他にもある  print integer range(start=, stop=) これが印字するのは、［,］それとも[,,]あるいはその他  startは適切な名前だ。でも、stopは複数の意味に解釈できる。 包含的な範囲を表すのであれば終端を範囲に含めるのであれば)、firstとlast  を使うのがいい。例えば、以下のようになる。  set.PrintKeys(ﬁrst=\"Bart\", last=\"Maggie\")  stopではなくlastを使えば、包含していることがIﾘ確になる。 意味的に「正しく聞こえる」のであれば､firstとlast以外にもminとｍａｘを使っ  て包含的範囲を表すことができる。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(51,1,50,'3.6プール値の名前３:\n\n3.5包含／排他的範囲にはbeginとendを使う\n\nbegin\n\nｅ\nｎ\nｌ\n\n包含／排他的な範囲は便利だ。例えば、１０月１６日に開催されたイベントをすべて\n\n印字したいとする。以下のように書くほうが、\n\nn\nr\nP\ni\nt\nEventsInRange(\"OCT 16 12:OOam\", \"OCT 17 12:00am\"\n\n以下のように書くよりも簡単だく\n\nn\nr\nP\ni\nt\nEventsInRange(\"OCT 16 12:OOam\", \"OCT 16 11:59:59.9999pm\"\n\nここに使う仮引数の名前は何がいいだろうか？プログラミングの命名規約では、\n\n包含／排他的範囲にbeginとendを使うことが多い。\n\nでも、endは少しあいまいだ。例えば、「本の終盤(the end of the book)を読人\nでいる」の「end」は包含的だ。残念ながら英語には「ちょうど最後の値を超えたと\nころ」を意味する簡潔な言葉がない。\n\nbeginとendの対はイディオムになっている（少なくともC++の標準ライブラリ\nではこれが使われている。また、配列がこのように「スライス」されることも多い）\nので、これが最善の選択と言える。\n３６プール値の名前\nブール値の変数やプール値を返す関数の名前を選ぶときには、trueとfalseの意\n\n味を明確にしなければいけない。\n\n以下は危険な例だ。\n\nbool read password = true;\n\n「read」をどう「読む」かになるけど（ギャグじゃないよ)、これには２つの解釈\n\nの仕方がある。\n\n','.プール値の名前:  .包含排他的範囲にはbeginとendを使う  begin  ｅ ｎ ｌ  包含排他的な範囲は便利だ。例えば、月日に開催されたイベントをすべて  印字したいとする。以下のように書くほうが、  n r P i t EventsInRange(\"OCT  :OOam\", \"OCT  :am\"  以下のように書くよりも簡単だく  n r P i t EventsInRange(\"OCT  :OOam\", \"OCT  ::.pm\"  ここに使う仮引数の名前は何がいいだろうかプログラミングの命名規約では、  包含排他的範囲にbeginとendを使うことが多い。  でも、endは少しあいまいだ。例えば、「本の終盤(the end of the book)を読人 でいる」の「end」は包含的だ。残念ながら英語には「ちょうど最後の値を超えたと ころ」を意味する簡潔な言葉がない。  beginとendの対はイディオムになっている少なくともC++の標準ライブラリ ではこれが使われている。また、配列がこのように「スライス」されることも多い ので、これが最善の選択と言える。 プール値の名前 ブール値の変数やプール値を返す関数の名前を選ぶときには、trueとfalseの意  味を明確にしなければいけない。  以下は危険な例だ。  bool read password = true;  「read」をどう「読む」かになるけどギャグじゃないよ)、これにはつの解釈  の仕方がある。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(52,1,51,'３4       3章誤解されない名前\n\n●パスワードをこれから読み取る必要がある。\n\n●パスワードをすでに読み取っている。\n\nここでは「read」を避けるべきだろう。代わりに、need passwordやuser is\n\nauthenticatedを使ったほうがいい。\n\nブール値の変数名は、頭にis・ｈａｓ・ｃａｎ・shouldなどをつけてわかりやすくする\n\nことが多い↑。\n\n例えば､SpaceLeftという名前は数値を返すように聞こえる。ブール値を返した\n\nいのであれば､HasSpaceLeftという名前にしたほうがいい。\n\nそれから、名前を否定形にするのは避けたほうがいい。例えば、\n\nbool disable ssl = false:\n\nではなく、肯定形にしたほうが声に出して読みやすい（それに短くて済む)。\n\nbool use ssl = true:\n3.7ユーザの期待に合わせる\nたとえ別の意味で使っていたとしても、ユーザが先入観を持っているために誤解を\n招いてしまうことがある。こういうときは「負けを認めて｣、誤解されない名前に変\nえたほうがいい。\n\n■例\n\n己\n一\n画\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n一\n(cid:9357)\n\n〃\nロ\n■\n■\n■\nｎ\n画\n\n★■》■■ｐｅｑ》■\n多くのプログラマは、getで始まるメソッドはメンバの値を返すだけの「軽量アク\nセサ」であるという規約にʻ慣れ親しんでいる。この規約を守らなければ、誤解を招く\n可能ʻ性がある。\n\n以下は、やってはいけない例だ。コードはJavaで書いている。\n\npublic class StatisticsCollector {\n\npublic void addSample(double x) {…｝\n\n↑訳注RubyのメソッドやＳｃｈｅｍｅには名前の後ろに？をつける慣習がある（例: authenticated?)。また、\n\nLispにはｐをつける慣習がある（例: authenticatedp)。\n\n','       章誤解されない名前  ●パスワードをこれから読み取る必要がある。  ●パスワードをすでに読み取っている。  ここでは「read」を避けるべきだろう。代わりに、need passwordやuser is  authenticatedを使ったほうがいい。  ブール値の変数名は、頭にis・ｈａｓ・ｃａｎ・shouldなどをつけてわかりやすくする  ことが多い↑。  例えば､SpaceLeftという名前は数値を返すように聞こえる。ブール値を返した  いのであれば､HasSpaceLeftという名前にしたほうがいい。  それから、名前を否定形にするのは避けたほうがいい。例えば、  bool disable ssl = false:  ではなく、肯定形にしたほうが声に出して読みやすいそれに短くて済む)。  bool use ssl = true: .ユーザの期待に合わせる たとえ別の意味で使っていたとしても、ユーザが先入観を持っているために誤解を 招いてしまうことがある。こういうときは「負けを認めて｣、誤解されない名前に変 えたほうがいい。  ■例  己 一 画 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 (cid:)  〃 ロ ■ ■ ■ ｎ 画  ★■》■■ｐｅｑ》■ 多くのプログラマは、getで始まるメソッドはメンバの値を返すだけの「軽量アク セサ」であるという規約にʻ慣れ親しんでいる。この規約を守らなければ、誤解を招く 可能ʻ性がある。  以下は、やってはいけない例だ。コードはJavaで書いている。  public class StatisticsCollector {  public void addSample(double x) {…｝  ↑訳注RubyのメソッドやＳｃｈｅｍｅには名前の後ろにをつける慣習がある例: authenticated?)。また、  Lispにはｐをつける慣習がある例: authenticatedp)。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(53,1,52,'３７ユーザの期待に合わせるʼ３５\n\ndouble getfteanQ {\nすべてのサンプルをイテレー卜して、total / num samplesを返す\n\npublic\n／\n／\n\n｝ ●\n\n● ●\n\ngetMeanQは過去のデータをすべてイテレートして、その場で平均値を計算する実\n装になっている。データが大量にあったらものすごいコストだ！そのことを知らな\nいプログラマは、コストが高いとは思わずにgetMeanQを呼び出してしまうだろう。\nコストの高さが事前にわかるように、このメソッドはcomputeMeanQなどの名前に\n\n変えるべきだろう（あるいは、コストの高くない実装に変えるべきだろう)。\n例: list::size()\nC++の標準ライブラリの例を挙げよう。以下のコードには見つけにくいバグが存\n\n在する。これが原因でサーバの速度がめちゃくちゃ遅くなったことがある。\n\nの「バグ」が発生しているのは、list.sizeQの計算量が0(n)であることを作\n者が知らなかったからだ。リンクトリストのノード数を事前計算をせずに順番にカウ\nントしているので、ShrinkList()全体の計算量が0(2)になっている。\n\nこのコードは技術的に「正しい」し、ユニットテストもすべて成功している。で\nも、要素数が100万個のリストをShrinkListOに渡したら、終了までに１時間以上\nかかってしまう！\n\n「そんなの呼び出し側の責任だよ。事前にドキュメントをちゃんと読むべきだ」な\nんて思うかもしれない。もちろん君が正しい。でもこの場合は、list・sizeに時間が\nかかりすぎるのが問題だ。C++には他にもコンテナがあるけど、どれも一定時間で\n終了するsize()メソッドを持っている。\n\nsizeQという名前がcountSizeQやcount Element sQだったら、このような問題\nは起きなかったはずだ。C++の標準ライブラリの作者は、vectorやmapなどのコン\n\n｝\n\n｝ こ\n\nvoid ShrinkList(list<Node>& list, int max_size) {\n\nwhile (list､sizeQ > max size) {\n\nFreeNode(list.back());\nl\ni\nst.pop backQ;\n\n','ユーザの期待に合わせるʼ  double getfteanQ { すべてのサンプルをイテレー卜して、total / num samplesを返す  public    ｝ ●  ● ●  getMeanQは過去のデータをすべてイテレートして、その場で平均値を計算する実 装になっている。データが大量にあったらものすごいコストだそのことを知らな いプログラマは、コストが高いとは思わずにgetMeanQを呼び出してしまうだろう。 コストの高さが事前にわかるように、このメソッドはcomputeMeanQなどの名前に  変えるべきだろうあるいは、コストの高くない実装に変えるべきだろう)。 例: list::size() C++の標準ライブラリの例を挙げよう。以下のコードには見つけにくいバグが存  在する。これが原因でサーバの速度がめちゃくちゃ遅くなったことがある。  の「バグ」が発生しているのは、list.sizeQの計算量が(n)であることを作 者が知らなかったからだ。リンクトリストのノード数を事前計算をせずに順番にカウ ントしているので、ShrinkList()全体の計算量が()になっている。  このコードは技術的に「正しい」し、ユニットテストもすべて成功している。で も、要素数が万個のリストをShrinkListOに渡したら、終了までに時間以上 かかってしまう  「そんなの呼び出し側の責任だよ。事前にドキュメントをちゃんと読むべきだ」な んて思うかもしれない。もちろん君が正しい。でもこの場合は、list・sizeに時間が かかりすぎるのが問題だ。C++には他にもコンテナがあるけど、どれも一定時間で 終了するsize()メソッドを持っている。  sizeQという名前がcountSizeQやcount Element sQだったら、このような問題 は起きなかったはずだ。C++の標準ライブラリの作者は、vectorやmapなどのコン  ｝  ｝ こ  void ShrinkList(list<Node>& list, int max_size) {  while (list､sizeQ > max size) {  FreeNode(list.back()); l i st.pop backQ;  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(54,1,53,'３６１３章誤解されない名前\n\nテナに合わせてメソッド名をsize()にしたのだと思う。でも、そのことが原因で、\n他のコンテナと同じ高速な操作と間違えられるようになってしまった。なお、最新の\nC++標準では、size )の計算量を0(1)にすることが定められている。\n\nウィザードは誰だ？\n\nOpenBSDをインストールしていたときのことだ。ディスクのフォーマット中に難解な\nメニューが表示されて、ディスクパラメータを選択せよと言われた。オプションには「ウィ\nザードモード」があった。ユーザに優しいオプションが見つかったので、安心してそれを\n選んだ。すると、インストーラが終了して、プロンプトが表示された。ディスクフォーマッ\nトのコマンドを手入力せよと言っている。ここから脱出することもできなかった。「ウィ\nザード」とは、ユーザ自身のことだったんだ！\n\n3画Ｂ例：複数の名前を検討する\n名前を決めるときには、複数の候補を検討すると思う。最終的に決める前に、それ\nぞれ長所について話し合うのが普通だ。以下の例は、この選考過程について示したも\nのだ。\n\n高トラフイックのウェブサイトでは、ウェブサイトの変更によってビジネスがどの\nくらい改善できるかを調べる「実験」をすることが多い。以下の例は、実験用の設定\nファイルだ。\n\nexperiment id: 100\ndescription: \"フオントサイズを14ptに上げるⅢ\ntraﬃc  fraction:  5%\n\n● ● ●\n\n設定ファイルには、属性と値のベアが１５個ほど定義されている。同じような実験\n\nをするときには、設定ファイルの大部分をコピペしなくてはいけない。\n\nexperiment id: 101\ndescription: \"フオントサイズをユ3ptに上げる\'１\n１以預exper加ent id 100と同じノ\n\n','章誤解されない名前  テナに合わせてメソッド名をsize()にしたのだと思う。でも、そのことが原因で、 他のコンテナと同じ高速な操作と間違えられるようになってしまった。なお、最新の C++標準では、size )の計算量を()にすることが定められている。  ウィザードは誰だ  OpenBSDをインストールしていたときのことだ。ディスクのフォーマット中に難解な メニューが表示されて、ディスクパラメータを選択せよと言われた。オプションには「ウィ ザードモード」があった。ユーザに優しいオプションが見つかったので、安心してそれを 選んだ。すると、インストーラが終了して、プロンプトが表示された。ディスクフォーマッ トのコマンドを手入力せよと言っている。ここから脱出することもできなかった。「ウィ ザード」とは、ユーザ自身のことだったんだ  画Ｂ例複数の名前を検討する 名前を決めるときには、複数の候補を検討すると思う。最終的に決める前に、それ ぞれ長所について話し合うのが普通だ。以下の例は、この選考過程について示したも のだ。  高トラフイックのウェブサイトでは、ウェブサイトの変更によってビジネスがどの くらい改善できるかを調べる「実験」をすることが多い。以下の例は、実験用の設定 ファイルだ。  experiment id:  description: \"フオントサイズをptに上げるⅢ traﬃc  fraction:  %  ● ● ●  設定ファイルには、属性と値のベアが個ほど定義されている。同じような実験  をするときには、設定ファイルの大部分をコピペしなくてはいけない。  experiment id:  description: \"フオントサイズをユptに上げる\' 以預exper加ent id と同じノ  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(55,1,54,'3.8例：複数の名前を検討する3】\n\n既存の設定ファイルを他の実験でも使えるようにしたい（これは「プロトタイプ継\n\n承」パターンと呼ばれる手法だ)。そうすれば、以下のように書ける。\n\nexperiment id: 101\nthe other experiment_id_I_want_to_reuse: IOC\n1以下､蕊動泌要な情報だけ書き換えるノ\n\nここで考えなければいけないのは、「the other experiment id I want to reuse\n\n(再利用したい実験のIDの名前を何にするか？」だ。\n\n以下の４つの名前を検討してみよう。\n\nの名前もぼくたちには適切に思える。新しい機能を追加したのは、ぼくたち自傷\nだからだ。でも、この機能を知らない人が見たらどうなるかを想像しなければいけと\nい。それぞれの名前を調べていこう。他の誰かが誤解する可能性を考えるんだ。\n\n１\n\nまずは、templateから考えよう。\n\nexperimented: 101\ntemplate: 100\n\ntemplateにはいくつかの問題がある。まず、「これはテンプレートだ」なのか「こ\nのテンプレートを使っている」なのかがわかりにくい。次に、「テンプレート」とい\nう言葉は、抽象的なものに何かを「埋め込」んで、具体的なものにするために使うも\nのだ。テンプレートに使う実験のことを「本物」の実験ではない抽象的なものと誤噸\nする人がいるかもしれない。この状況でtemplateを使うには意味があいまいすぎる\nのだ。\n\nｅ\n\nⅢ\n\nｐ\n\nｌ\n\nｅｔ\nａ\n\nｅ\n\nｕ\n\nＯ\n\nｐ\n\nｎ\n\nｈ\n\nＳ\n\nｅ\n\nｙ\n\nｒ\n\nｅ\n\nｔ\n・\n１\n\nｔ ｒ Ｃ ・ １\n\n●\n\n●\n\n■\n\n●\n\n１ ２ ３ ４ ど\n\n','.例複数の名前を検討する】  既存の設定ファイルを他の実験でも使えるようにしたいこれは「プロトタイプ継  承」パターンと呼ばれる手法だ)。そうすれば、以下のように書ける。  experiment id:  the other experiment_id_I_want_to_reuse: IOC 以下､蕊動泌要な情報だけ書き換えるノ  ここで考えなければいけないのは、「the other experiment id I want to reuse  (再利用したい実験のIDの名前を何にするか」だ。  以下のつの名前を検討してみよう。  の名前もぼくたちには適切に思える。新しい機能を追加したのは、ぼくたち自傷 だからだ。でも、この機能を知らない人が見たらどうなるかを想像しなければいけと い。それぞれの名前を調べていこう。他の誰かが誤解する可能性を考えるんだ。    まずは、templateから考えよう。  experimented:  template:   templateにはいくつかの問題がある。まず、「これはテンプレートだ」なのか「こ のテンプレートを使っている」なのかがわかりにくい。次に、「テンプレート」とい う言葉は、抽象的なものに何かを「埋め込」んで、具体的なものにするために使うも のだ。テンプレートに使う実験のことを「本物」の実験ではない抽象的なものと誤噸 する人がいるかもしれない。この状況でtemplateを使うには意味があいまいすぎる のだ。  ｅ  Ⅲ  ｐ  ｌ  ｅｔ ａ  ｅ  ｕ  Ｏ  ｐ  ｎ  ｈ  Ｓ  ｅ  ｙ  ｒ  ｅ  ｔ ・   ｔ ｒ Ｃ ・   ●  ●  ■  ●      ど  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(56,1,55,'38       3章誤解されない名前\n\n２\n\nreuseはどうだろう。\nexperiment id: 101\nr\neuse：１００\n\n● ●\n\nreuseは悪くない言葉だ。でも、文字だけを見ると「この実験は１0０回再利用でき\nる」と誤解される可能性もある。名前をreuse idに変えたほうがいいだろう。でも、\nreuse  id:    100のことを「この実験の再利用idは１00だ」と誤解するユーザがいる\nかもしれない。\n\n3\nʻ\n\ncopyについて考えてみよう。\n\nexperiment id: 101\ncopy: 100\n\n● ● ●\n\ncopyはいい名前だ。でも、copy: 100だけでは、「この実験を100回コピーする」\nなのか「これは100回めのコピーだ」なのかがわからない。他の実験を参照してい\nる言葉だということを明確にするには､copy experimentという名前に変えるといい。\n今までのところ、これが最善の名前だ。\n\n４\n\n最後にinheritを検討しよう《\n\nexperiment id: 101\ninherit: 100\n\n● ● ●\n\ninheritという言葉はプログラマにはなじみがある。何かを継承するというのは\n新たに変更を加えるという意味だ。クラスを継承すれば、そのクラスのメソッドとメ\nンバがすべて手に入り、それらを変更したり新しく追加したりできる。現実の世界て\n考えてみても、身内の財産を継承するというのは、その財産を自分で好きなように偶\n有したり売却したりできるという意味だ。\n\nただし、他の実験から継承していることは明確にしておこう。名前をinherit\n\nfromやinherit_from experiment idに変えるといいだろう。\n\n以上の検討結果から、最善の名前はcopy  experimentとinherit  from\n\n','       章誤解されない名前    reuseはどうだろう。 experiment id:  r euse  ● ●  reuseは悪くない言葉だ。でも、文字だけを見ると「この実験は回再利用でき る」と誤解される可能性もある。名前をreuse idに変えたほうがいいだろう。でも、 reuse  id:    のことを「この実験の再利用idはだ」と誤解するユーザがいる かもしれない。   ʻ  copyについて考えてみよう。  experiment id:  copy:   ● ● ●  copyはいい名前だ。でも、copy: だけでは、「この実験を回コピーする」 なのか「これは回めのコピーだ」なのかがわからない。他の実験を参照してい る言葉だということを明確にするには､copy experimentという名前に変えるといい。 今までのところ、これが最善の名前だ。    最後にinheritを検討しよう《  experiment id:  inherit:   ● ● ●  inheritという言葉はプログラマにはなじみがある。何かを継承するというのは 新たに変更を加えるという意味だ。クラスを継承すれば、そのクラスのメソッドとメ ンバがすべて手に入り、それらを変更したり新しく追加したりできる。現実の世界て 考えてみても、身内の財産を継承するというのは、その財産を自分で好きなように偶 有したり売却したりできるという意味だ。  ただし、他の実験から継承していることは明確にしておこう。名前をinherit  fromやinherit_from experiment idに変えるといいだろう。  以上の検討結果から、最善の名前はcopy  experimentとinherit  from  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(57,1,56,'3 . 9 ま と め 3 9\n\nexperiment  idということになった。その理由は、何が起きるかを明確に表していて\n誤解を生む可能\'性が低いからだ。\n\n3 . 9 ま と め\n最善の名前とは、誤解されない名前である。つまり、君のコードを読んでいる人\nが、君の意図を正しく理解できるということだ。英語の単語は、filter・length・\nlimitのように、プログラミングに使うには意味があいまいなものが多い。\n\n名前を決める前に反対意見を考えるなどして、誤解されない名前かどうかを想像し\n\nてみよう。最善の名前というのは、誤解されない名前である。\n\n上下の限界値を決めるときには、maxやminを前につけるといい。包含的範囲で\nあれば、firstやlastを使うといいだろう。包含／排他的範囲であれば、beginと\nendがイディオムなのでそれを使う。ブール値に名前をつけるときには、それがブー\nル値だとわかるようにisやhasなどの単語を使う。disable  sslのような否定形は\n避ける。\n\n単語に対するユーザの期待にも注意する。例えば､getやsizeQには軽量なメ\n\nソッドが期待されている。\n\n',' .  ま と め    experiment  idということになった。その理由は、何が起きるかを明確に表していて 誤解を生む可能\'性が低いからだ。   .  ま と め 最善の名前とは、誤解されない名前である。つまり、君のコードを読んでいる人 が、君の意図を正しく理解できるということだ。英語の単語は、filter・length・ limitのように、プログラミングに使うには意味があいまいなものが多い。  名前を決める前に反対意見を考えるなどして、誤解されない名前かどうかを想像し  てみよう。最善の名前というのは、誤解されない名前である。  上下の限界値を決めるときには、maxやminを前につけるといい。包含的範囲で あれば、firstやlastを使うといいだろう。包含排他的範囲であれば、beginと endがイディオムなのでそれを使う。ブール値に名前をつけるときには、それがブー ル値だとわかるようにisやhasなどの単語を使う。disable  sslのような否定形は 避ける。  単語に対するユーザの期待にも注意する。例えば､getやsizeQには軽量なメ  ソッドが期待されている。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(58,1,57,'ʼ\n４１\n\n鶏葦\n美しさ\n\n','ʼ   鶏葦 美しさ  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(59,1,58,'４２１４章美しさ\n\n雑誌のレイアウトには多くの考えが詰め込まれている。段落の長さ。横Ifei・記事の\n順番。表紙。優れた雑誌というのは、ページを飛ばして読めるようになっているし、\n順番に読めるようにもなっている。\n\n優れたソースコードは「目に優しい」ものでなければいけない。本章では、コード\n\nを読みやすくするための余白・配置・順序について説明しよう。\n\n具体的には、ぼくたちが使っている３つの原則についてだ。\n\n●読み手が慣れているパターンと一貫性のあるレイアウトを使う息\n\n●似ているコードは似ているように見せる。\n\n●関連するコードをまとめてブロックにする。\n\n美しさと設計\n\n本章では、コードの単純な「美しさ」の改善を扱う。こうした変更は取り組みやすいし、\nコードがすごく読みやすいものになる。大きなリファクタリング（新しい関数やクラスの\n導入など）がもっとうまくいくようになることも多い。ぼくたちは、美しさと優れた設計\nは独立した考えだと思っている。できればその両方を追求してもらいたい。\n\n4.１なぜ美しさが大切なのか？\n\n','章美しさ  雑誌のレイアウトには多くの考えが詰め込まれている。段落の長さ。横Ifei・記事の 順番。表紙。優れた雑誌というのは、ページを飛ばして読めるようになっているし、 順番に読めるようにもなっている。  優れたソースコードは「目に優しい」ものでなければいけない。本章では、コード  を読みやすくするための余白・配置・順序について説明しよう。  具体的には、ぼくたちが使っているつの原則についてだ。  ●読み手が慣れているパターンと一貫性のあるレイアウトを使う息  ●似ているコードは似ているように見せる。  ●関連するコードをまとめてブロックにする。  美しさと設計  本章では、コードの単純な「美しさ」の改善を扱う。こうした変更は取り組みやすいし、 コードがすごく読みやすいものになる。大きなリファクタリング新しい関数やクラスの 導入などがもっとうまくいくようになることも多い。ぼくたちは、美しさと優れた設計 は独立した考えだと思っている。できればその両方を追求してもらいたい。  .なぜ美しさが大切なのか  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(60,1,59,'４１なぜ美しさが大切なのか？ʼ４３\n\n以下のようなコードを使わなければいけないとしよう。\n\nこれを理解するには時間がかかると思う。では、以下のキレイなバージョンならど\n\nた目が美しいコードのほうが使いやすいのは明らかだ。考えてみれば、プログラ\nミングの時間のほとんどはコードを読む時間なのだッ！さっと流し読みができれ\nば、誰にとっても使いやすいコードだと言えるだろう。\n\nＩ 見\n\nうだろう。\n\n// doubleを記録するクラスと\n/／すばやく統計を出すメソッド\nass StatsKeeper {\nc\nl\npublic:\nvoid Add(double d);\ndouble AverageQ;\n\nprivate:\n\nlist<double> past items;\nint count;   //それまでの個数\n\ndouble minimum:\ndouble maximum:\n\ndouble AverageQ;\n\nprivate:  double minimum;\nlist<double>\npast items\n\n;\ndouble maximum;\n\n}\n；\n\nclass:class StatsKeeper {\npublic:\n// doubleを記録するクラス\n\nvoid Add(double d); //とすばやく統計を出すメソッド\n／＊それまでの個数\nprivate:     int count;\n\n*/ public:\n\n','なぜ美しさが大切なのかʼ  以下のようなコードを使わなければいけないとしよう。  これを理解するには時間がかかると思う。では、以下のキレイなバージョンならど  た目が美しいコードのほうが使いやすいのは明らかだ。考えてみれば、プログラ ミングの時間のほとんどはコードを読む時間なのだッさっと流し読みができれ ば、誰にとっても使いやすいコードだと言えるだろう。  Ｉ 見  うだろう。  // doubleを記録するクラスと /すばやく統計を出すメソッド ass StatsKeeper { c l public: void Add(double d); double AverageQ;  private:  list<double> past items; int count;   //それまでの個数  double minimum: double maximum:  double AverageQ;  private:  double minimum; list<double> past items  ; double maximum;  }   class:class StatsKeeper { public: // doubleを記録するクラス  void Add(double d); //とすばやく統計を出すメソッド それまでの個数 private:     int count;  */ public:  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(61,1,60,'４４１４章美しさ\n\n4.2一貫Ｉ性のある簡潔な改行位置\n\nとあるJavaのコードを書いているとしよう。任意の速度のネット『\nに接続したときに、プログラムがどのように動くかを評価するコー\nTcpConnectionSimulatorクラスのコンストラクタには４つの仮引数がある。\n\nトワーク\nードだ。\n\n1．接続速度(Kbps)\n\n2．平均遅延時間(ms)\n\n3．遅延「イライラ」時間(ms)\n\n4．パケツトロス率（%）\n\nこのコードにはTcpConnectionSimulatorのインスタンスが３つ必要だ。\n\npublic class PerformanceTester {\n\npublic static final TcpConnectionSimulator wifi = new T叩ConnectionSimulatorf\n\n500, /* Kbps */\n80, /* millisecs latency */\n200, /* jitter */\n1 /* packet loss % */);\n\nt3 ﬁber =\n\n一\n\npublic static ﬁnal TcpConnectionSimulator\n\nnew TcpConnectionSimulator(\n\n45000, /* Kbps */\n10, /* millisecs latency */\n0, /* jitter */\n0 /* packet loss % */);\n\npublic static final TcpConnectionSimulator cell = new T印ConnectionSimulaton\n\n100, /* Kbps */\n400, /* millisecs latency */\n250, /* jitter */\n5 /* packet loss % */);\n\n横幅８０文字に合わせるために（これは会社のコーディング標準なのだ）余計な改\n行が入っている。その結果、t3  fiberの見た目が他と違って残念なことになってい\n\n１■■■■\n\n','章美しさ  .一貫Ｉ性のある簡潔な改行位置  とあるJavaのコードを書いているとしよう。任意の速度のネット『 に接続したときに、プログラムがどのように動くかを評価するコー TcpConnectionSimulatorクラスのコンストラクタにはつの仮引数がある。  トワーク ードだ。  接続速度(Kbps)  平均遅延時間(ms)  遅延「イライラ」時間(ms)  パケツトロス率%  このコードにはTcpConnectionSimulatorのインスタンスがつ必要だ。  public class PerformanceTester {  public static final TcpConnectionSimulator wifi = new T叩ConnectionSimulatorf  , /* Kbps */ , /* millisecs latency */ , /* jitter */  /* packet loss % */);  t ﬁber =  一  public static ﬁnal TcpConnectionSimulator  new TcpConnectionSimulator(  , /* Kbps */ , /* millisecs latency */ , /* jitter */  /* packet loss % */);  public static final TcpConnectionSimulator cell = new T印ConnectionSimulaton  , /* Kbps */ , /* millisecs latency */ , /* jitter */  /* packet loss % */);  横幅文字に合わせるためにこれは会社のコーディング標準なのだ余計な改 行が入っている。その結果、t  fiberの見た目が他と違って残念なことになってい  ■■■■  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(62,1,61,'４２­買性のある簡潔な改行位置ʼ４５\n\nる。コードの「シルエット」が変なので、自然とt3  fiberに目が向いてしまう。そ\nれに「似ているコードは似ているように見せる」の原則も守られていない。\n\nコードの見た目を一貫\'性のあるものにするには、適切な改行を入れるようにしよう\n\n(それからコメントも整列させよう)。\n\nのコードには一貫性があり、楽に目を通すことができる。でも、縦に長くなって\n\n．． こ\n\nlatency, jitter, packet loss)\n[ms]      [ms]       [percent]\n\nc\nl\nass PerformanceTester {\nTcpConnectionSimulator(throughputj\n[\nKbps]\n\nノ／ノ\n\npublic\n／\n\npublic static ﬁnal TcpConnectionSimulator wiﬁ =\n\nnew T叩ConnectionSimulator(500,      80,        200,      i);\n\nいるし、同じコメントが３回も繰り返されている。\nこのクラスを簡潔に書いたら以下のようになる。\n\npublic static ﬁnal TcpConnectionSimulator cell =\n\nnew T叩ConnectionSimulator(\n\n100,     /* Kbps */\n400,  /* millisecs latency */\n250,     /* jitter */\n5 /* packet loss % */);\n\npublic static ﬁnal TcpConnectionSimulator t3_ﬁber \n\nnew T印ConnectionSimulator(\n\n45000, /* Kbps */\n10,  /* millisecs latency */\n0,       /* jitter */\n0 /* packet loss % */);\n\npublic class PerformanceTester {\n\npublic static ﬁnal TcpConnectionSimulator wiﬁ =\n\nnew TcpConnectionSimulator(\n\n500,     /* Kbps */\n80,  /* millisecs latency */\n200,    /* jitter */\n1 /* packet loss % */);\n\n','­買性のある簡潔な改行位置ʼ  る。コードの「シルエット」が変なので、自然とt  fiberに目が向いてしまう。そ れに「似ているコードは似ているように見せる」の原則も守られていない。  コードの見た目を一貫\'性のあるものにするには、適切な改行を入れるようにしよう  (それからコメントも整列させよう)。  のコードには一貫性があり、楽に目を通すことができる。でも、縦に長くなって   こ  latency, jitter, packet loss) [ms]      [ms]       [percent]  c l ass PerformanceTester { TcpConnectionSimulator(throughputj [ Kbps]  ノノ  public   public static ﬁnal TcpConnectionSimulator wiﬁ =  new T叩ConnectionSimulator(,      ,        ,      i);  いるし、同じコメントが回も繰り返されている。 このクラスを簡潔に書いたら以下のようになる。  public static ﬁnal TcpConnectionSimulator cell =  new T叩ConnectionSimulator(  ,     /* Kbps */ ,  /* millisecs latency */ ,     /* jitter */  /* packet loss % */);  public static ﬁnal TcpConnectionSimulator t_ﬁber   new T印ConnectionSimulator(  , /* Kbps */ ,  /* millisecs latency */ ,       /* jitter */  /* packet loss % */);  public class PerformanceTester {  public static ﬁnal TcpConnectionSimulator wiﬁ =  new TcpConnectionSimulator(  ,     /* Kbps */ ,  /* millisecs latency */ ,    /* jitter */  /* packet loss % */);  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(63,1,62,'４６１４章美しさ\n\npublic static ﬁnal TcpConnectionSimulator t3 ﬁber =\n\nnew TcpConnectionSimulator(45000,   10,       0, o);\n\npublic static ﬁnal TcpConnectionSimulator cell =\n\nnew TcpConnectionSimulator(100,      400,      250,      5);\n\nコメントを最上部に移動して、仮引数を一行で書くようにした。数値の右隣からコ\n\nメントがいなくなったけど、より簡潔な表組みに「データ」が並ぶようになった。\n4.3メソッドを使った整列\n人事データベースがあるとしよう。以下の関数が提供されている。\n\n// IDoug Adams」のようなpartial nameを「Mr. Douglas Adams」に変える。\n/／それができなければ、errorに説明文を入れる。\nstring ExpandFullName(DatabaseConnection dc, string partialjiame, string* error);\n\nこの関数は実例を使ってテストしている。\n\nDatabaseConnection database connection;\nstring error;\nassert(ExpandFullName(database_connection, \"Doug Adams\", Serror)\n\n== \"Mr・Douglas Adams\");\n\nassert(error == \"\");\nassert(ExpandFullName(database_connection, \" 3ake Brown \", &error)\n\n== \"Mr. Jacob Brown III\");\n\nassert(error == \"\");\nassert(ExpandFullName(database_connection, \"No Such Guy\", Serror) == \"\");\nassert(error == \"no match found\");\nassert(ExpandFullName(database_connection, \"John\", &error) == \"\");\nassert(error == \"more than one result\");\n\n見た目が美しくない。長すぎて折り返されているところもある。シルエットは不細\n\n工だし一貫\'性のあるパターンがない。\n\nこれは改行の位置を変えなければいけない。でも、「assert(ExpandFullName(data\nbase connection…,」や「error」などの文字列が何度も登場して邪魔をしている。\nこのコードを本当の意味で改善するには、ヘルパーメソッドを使う必要がある。\n\n','章美しさ  public static ﬁnal TcpConnectionSimulator t ﬁber =  new TcpConnectionSimulator(,   ,       , o);  public static ﬁnal TcpConnectionSimulator cell =  new TcpConnectionSimulator(,      ,      ,      );  コメントを最上部に移動して、仮引数を一行で書くようにした。数値の右隣からコ  メントがいなくなったけど、より簡潔な表組みに「データ」が並ぶようになった。 .メソッドを使った整列 人事データベースがあるとしよう。以下の関数が提供されている。  // IDoug Adams」のようなpartial nameを「Mr. Douglas Adams」に変える。 /それができなければ、errorに説明文を入れる。 string ExpandFullName(DatabaseConnection dc, string partialjiame, string* error);  この関数は実例を使ってテストしている。  DatabaseConnection database connection; string error; assert(ExpandFullName(database_connection, \"Doug Adams\", Serror)  == \"Mr・Douglas Adams\");  assert(error == \"\"); assert(ExpandFullName(database_connection, \" ake Brown \", &error)  == \"Mr. Jacob Brown III\");  assert(error == \"\"); assert(ExpandFullName(database_connection, \"No Such Guy\", Serror) == \"\"); assert(error == \"no match found\"); assert(ExpandFullName(database_connection, \"John\", &error) == \"\"); assert(error == \"more than one result\");  見た目が美しくない。長すぎて折り返されているところもある。シルエットは不細  工だし一貫\'性のあるパターンがない。  これは改行の位置を変えなければいけない。でも、「assert(ExpandFullName(data base connection…,」や「error」などの文字列が何度も登場して邪魔をしている。 このコードを本当の意味で改善するには、ヘルパーメソッドを使う必要がある。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(64,1,63,'４４縦の線をまっすぐにするʼ４７\n\nCheckFullName(叩Doug Adams\", \"Mr. Douglas Adams\", \"\");\nCheckFullName(\" Dake   Brown \", \"Mr．]ake Brown III\", \"\");\nCheckFullNamefNo Such Guy\", \"\", \"no match found\");\nCheckFullName(\"Dohn\", \"\", \"more than one result\");\n\nこれなら引数の異なる４つのテストがあることがよくわかる。「面倒な仕事」はす\n\nべてCheckFullNameQに隠されることになったけど、このメソッドも悪くはない。\n\nvoid CheckFullName(string partialjiame,\n\nstring expected full name,\nstring expected_error) {\n\n// database connectionはクラスのメンバになっている。\nstring error;\nstring fulljiame = ExpandFullName(database_connection, partialjame, &error).\nassert(error == expected error);\nassert(full name == expected_full_name);\n\nこでの目標はコードの見た目を美しくすることだったけど、この変更によってｊ\n\nれしい副作用がもたらされることになった。\n\n●重複を排除したことでコードが簡潔になった。\n\n●\n\nテストケースの大切な部分（名前やエラー文字列）が見やすくなった。以前\nは、database  connectionやerrorなどのトークンに囲まれていて、コード\nを見て「飲み込む」のが難しかった。\n\n●テストの追加が簡単になった。\n\nこの話の教訓は、コードの「見た目をよく」すれば、表面上の改善だけではなく、\n\nコードの構造も改善できるということだ。\n\n4.4縦の線をまっすぐにする\n縦の線をまつすぐにすれば、文章に目を通しやすくなる。\n列を「整列」させれば、コードが読みやすくなることがある。例えば、前節の\n\nCheckFullNameQ引数は、空白を使って整列できる。\n\n｝ こ\n\n','縦の線をまっすぐにするʼ  CheckFullName(叩Doug Adams\", \"Mr. Douglas Adams\", \"\"); CheckFullName(\" Dake   Brown \", \"Mr]ake Brown III\", \"\"); CheckFullNamefNo Such Guy\", \"\", \"no match found\"); CheckFullName(\"Dohn\", \"\", \"more than one result\");  これなら引数の異なるつのテストがあることがよくわかる。「面倒な仕事」はす  べてCheckFullNameQに隠されることになったけど、このメソッドも悪くはない。  void CheckFullName(string partialjiame,  string expected full name, string expected_error) {  // database connectionはクラスのメンバになっている。 string error; string fulljiame = ExpandFullName(database_connection, partialjame, &error). assert(error == expected error); assert(full name == expected_full_name);  こでの目標はコードの見た目を美しくすることだったけど、この変更によってｊ  れしい副作用がもたらされることになった。  ●重複を排除したことでコードが簡潔になった。  ●  テストケースの大切な部分名前やエラー文字列が見やすくなった。以前 は、database  connectionやerrorなどのトークンに囲まれていて、コード を見て「飲み込む」のが難しかった。  ●テストの追加が簡単になった。  この話の教訓は、コードの「見た目をよく」すれば、表面上の改善だけではなく、  コードの構造も改善できるということだ。  .縦の線をまっすぐにする 縦の線をまつすぐにすれば、文章に目を通しやすくなる。 列を「整列」させれば、コードが読みやすくなることがある。例えば、前節の  CheckFullNameQ引数は、空白を使って整列できる。  ｝ こ  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(65,1,64,'４８１４章美しさ\n\nCheckFullName(\"Doug Adams\"  , \"Mr. Douglas Adams\" ,\nCheckFullNameP Jake   Brown \", \"Mr.Jake Brown III\".\nCheckFullName(\"No Such Guy\" , \"\"\nCheckFullNamePJohn\"\n\n０\n１\n１\n０\n\n》\n\n伽\n；\nʻ\n!\n)\n\'\nʻ\n伽\n)\nj\n\"\nno match found\");\n\"more than one result\");\n\nCheckFullNameQの２番めと３番めの引数がわかりやすくなった。\n以下の例では、複数の変数を定義している。\n\n# POSTのパラメータをローカル変数に割り当てる\ndetails   = request.POST.get(\'details\')\nl\nocation = request.POST.get(\'location\')\nphone      = equest・POST.get(\'phone\')\nemail      = request.POST・get(\'email\')\nurl = request.POST.get(\'url\')\n\nもう気づいたかもしれないけど、３つめの定義でタイプミスをしている(request\nがequestになっている)。コードを整列しておけば、こういうミスが見つけやすくな\nる\n。\nwgetのコードでは、利用可能なコマンドラインオプションが100個以上ある)、\n\n以下のように並べられている。\n\ncommands[] = {\n\n{ \"timeout\",\n{ \"timestamping\",\n{ \"tries\",\n{ \"useproxy\",\n{ \"useragent\",\n\nN\nL\nU\nL\n》\n&opt・timestamping,\n&opt.ntry,\n&opt･use proxy,\nNULL,\n\ncmd spec timeout },\ncmd boolean },\ncmd number inf },\ncmd boolean },\ncmd spec useragent },\n\n１\n\n■\n。\n■\n■\nＦ\n\nこうしておけば、次から次へと楽に流し読みできる。\n\n整列すべきなのか？\n縦の線が「視覚的な手すり」になれば、流し読みが楽にできるようになる。これは\n\n｢似ているコードは似ているように見せる」のいい例だ。\n\nでも、これが好きではないプログラマもいる。整列やその維持に手間がかかるとい\n\n','章美しさ  CheckFullName(\"Doug Adams\"  , \"Mr. Douglas Adams\" , CheckFullNameP Jake   Brown \", \"Mr.Jake Brown III\". CheckFullName(\"No Such Guy\" , \"\" CheckFullNamePJohn\"       》  伽  ʻ ! ) \' ʻ 伽 ) j \" no match found\"); \"more than one result\");  CheckFullNameQの番めと番めの引数がわかりやすくなった。 以下の例では、複数の変数を定義している。  # POSTのパラメータをローカル変数に割り当てる details   = request.POST.get(\'details\') l ocation = request.POST.get(\'location\') phone      = equest・POST.get(\'phone\') email      = request.POST・get(\'email\') url = request.POST.get(\'url\')  もう気づいたかもしれないけど、つめの定義でタイプミスをしている(request がequestになっている)。コードを整列しておけば、こういうミスが見つけやすくな る 。 wgetのコードでは、利用可能なコマンドラインオプションが個以上ある)、  以下のように並べられている。  commands[] = {  { \"timeout\", { \"timestamping\", { \"tries\", { \"useproxy\", { \"useragent\",  N L U L 》 &opt・timestamping, &opt.ntry, &opt･use proxy, NULL,  cmd spec timeout }, cmd boolean }, cmd number inf }, cmd boolean }, cmd spec useragent },    ■ 。 ■ ■ Ｆ  こうしておけば、次から次へと楽に流し読みできる。  整列すべきなのか 縦の線が「視覚的な手すり」になれば、流し読みが楽にできるようになる。これは  ｢似ているコードは似ているように見せる」のいい例だ。  でも、これが好きではないプログラマもいる。整列やその維持に手間がかかるとい  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(66,1,65,'４５­貢性と意味のある並びʼ４９\n\nうのだ。１行だけ変更したいのに、他の行も（それも空白だけ）変更しなければいけ\nないので、「差分」が増えるという人もいる。\n\nでも、試しにやってみてはどうだろうか。ぼくたちの経験では、プログラマが心節\nするほどの手間にはならない。もし手間になるようだったら、そのときは止めればｖ\nいｏ\n\n４ｓ一貫性と意味のある並び\nコードの並びがコードの正しさに影響を及ぼすことは少ない。例えば、以下の５\n\nつの変数の定義はどんな順番で並べても構わない。\n\ndetails = request･POST.get(\'details\')\nl\nocation = request.POST.get(\'location\'\nphone      = request・POST.get(\'phone\')\nemail  = request.POST.get(\'email\')\nurl = request.POST.get(\'urr)\n\nであれば、ランダムに並べるのではなく、意味のある順番に並べるといい。例貞\n\nば、こんな感じだ。\n\n●対応するHTMLフオームの<input>フィールドと同じ並び順にする。\n\n●「最重要」なものから重要度順に並べる。\n\n●アルファベット順に並べる。\n\nどの並び順を選ぶにしても、一連のコードでは同じ並び順を使うべきだ。並び順を\n\n変えてしまうと、あとでわかりにくくなる。\n\nif details:     rec・details = details\nif phone:      rec･phone      = phone\nif email:      rec.email      = email\ni f  u r l :   r e c , u r l   =  u r l\nif location: rec・location = location   #なんで\'location\'が下にあるの？\n\n＃あれ、\'location\'はどこ？\n\n','­貢性と意味のある並びʼ  うのだ。行だけ変更したいのに、他の行もそれも空白だけ変更しなければいけ ないので、「差分」が増えるという人もいる。  でも、試しにやってみてはどうだろうか。ぼくたちの経験では、プログラマが心節 するほどの手間にはならない。もし手間になるようだったら、そのときは止めればｖ いｏ  ｓ一貫性と意味のある並び コードの並びがコードの正しさに影響を及ぼすことは少ない。例えば、以下の  つの変数の定義はどんな順番で並べても構わない。  details = request･POST.get(\'details\') l ocation = request.POST.get(\'location\' phone      = request・POST.get(\'phone\') email  = request.POST.get(\'email\') url = request.POST.get(\'urr)  であれば、ランダムに並べるのではなく、意味のある順番に並べるといい。例貞  ば、こんな感じだ。  ●対応するHTMLフオームの<input>フィールドと同じ並び順にする。  ●「最重要」なものから重要度順に並べる。  ●アルファベット順に並べる。  どの並び順を選ぶにしても、一連のコードでは同じ並び順を使うべきだ。並び順を  変えてしまうと、あとでわかりにくくなる。  if details:     rec・details = details if phone:      rec･phone      = phone if email:      rec.email      = email i f  u r l :   r e c , u r l   =  u r l if location: rec・location = location   #なんで\'location\'が下にあるの  あれ、\'location\'はどこ  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(67,1,66,'50       4章美しさ\n\n4.6宣言をブロックにまとめる\n人間の脳はグループや階層を１つの単位として考える。コードの概要をすばやく\n\n把握してもらうには、このような「単位」を作ればいい。\n\n例えば、フロントエンドサーバ用のC++のクラスがあるとする。メソッド宣言は\n\n以下のようになっている。\n\nass FrontendServer {\nc\nl\npublic:\nFrontendServer();\nvoid ViewProﬁle(HttpRequest* request);\nvoid OpenDatabase(string location, string user);\nvoid SaveProﬁle(HttpRequest* request);\nstring ExtractOueryParam(HttpRequest* request, string param);\nvoid ReplyOK(HttpRequest* request, string html);\nvoid FindFriends(HttpRequest* request);\nvoid ReplyNotFound(HttpRequest* request, string error);\nvoid CloseDatabase(string location);\n\"FrontendServer();\n\nにひどいコードというわけではない。でも、メソッドの概要をすぐに把握できる\nような配置にはなっていない。すべてのメソッドを１つの大きなブロックにまとめ\nるのではなく、論理的なグループに分けてあげるといいだろう。例えば、こんな感じ\nだ\n。\n\n； 特\n\n}\n\nc\nl\nass FrontendServer {\npublic:\nFrontendServerQ;\n̅FrontendServer();\n\n/／八ンドラ\nvoid ViewProﬁle(HttpRequest*\nvoid SaveProﬁle(HttpRequest*\nvoid FindFriends(HttpRequest*\n\nrequest);\nrequest);\nrequest);\n\n/／リクエストとリプライのユーティリティ\nstring ExtractOueryParam(HttpRequest* request, string param);\nvoid ReplyOK(HttpRequest* request, string html);\nvoid ReplyNotFound(HttpRequest* request, string error);\n\n','       章美しさ  .宣言をブロックにまとめる 人間の脳はグループや階層をつの単位として考える。コードの概要をすばやく  把握してもらうには、このような「単位」を作ればいい。  例えば、フロントエンドサーバ用のC++のクラスがあるとする。メソッド宣言は  以下のようになっている。  ass FrontendServer { c l public: FrontendServer(); void ViewProﬁle(HttpRequest* request); void OpenDatabase(string location, string user); void SaveProﬁle(HttpRequest* request); string ExtractOueryParam(HttpRequest* request, string param); void ReplyOK(HttpRequest* request, string html); void FindFriends(HttpRequest* request); void ReplyNotFound(HttpRequest* request, string error); void CloseDatabase(string location); \"FrontendServer();  にひどいコードというわけではない。でも、メソッドの概要をすぐに把握できる ような配置にはなっていない。すべてのメソッドをつの大きなブロックにまとめ るのではなく、論理的なグループに分けてあげるといいだろう。例えば、こんな感じ だ 。   特  }  c l ass FrontendServer { public: FrontendServerQ; ̅FrontendServer();  /八ンドラ void ViewProﬁle(HttpRequest* void SaveProﬁle(HttpRequest* void FindFriends(HttpRequest*  request); request); request);  /リクエストとリプライのユーティリティ string ExtractOueryParam(HttpRequest* request, string param); void ReplyOK(HttpRequest* request, string html); void ReplyNotFound(HttpRequest* request, string error);  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(68,1,67,'４７コードを「段落」に分割するʼ５１\n\n/／データベースのヘルパー\nvoid OpenDatabase(string location, string user);\nvoid CloseDatabase(string location);\n\n｝ こ\n\nれで概要が把握しやすくなった。コード行は増えたけど、ずっと読みやすくなっ\nたと思う。グループに分けたことで、最初に４つのグループを把握して、あとから\n必要になったときに詳細を読めるようになった。\n4.7コードを「段落」に分割する\n文章は複数の段落に分割されている。それは\n\n●似ている考えをグループにまとめて、他の考えと分けるためだく\n\n●視覚的な「踏み石」を提供できるからだ。これがなければ、ページのなかて\n\n自分の場所を見失ってしまう。\n\n●段落単位で移動できるようになるからだｃ\n\nこれと同じ理由で、コードも「段落」に分けるべきだ。例えば、以下のようなひと\n\n塊りのコードは誰も読む気がしない。\n\n＃ユーザのメール帳をインポートして、システムのユーザと照合する。\n＃そして、まだ友達になっていないユーザの一覧を表示する。\ndef suggest_new_friends(user, email_password):\n\nfriends = user・friends()\nfriend emails = set(f.email for f in friends)\ncontacts = import contacts(user.email, email_password)\ncontact emails = set(c.email for c in contacts)\nnon friend emails = contact emails - friend emails\nsuggestedjriends = User, objects, select (email__in=non_friend_emails\ndisplay[\'user\'] = user\ndisplay!\'friends\'] = friends\nd\ni\nsplay [\'suggested Jriends\' ] = suggestedjriends\nreturn render(\"suggested friends.html\", display)\n\nわかりにくかもしれないけど、この関数はいくつかの手順で成り立っているので、\n\n','コードを「段落」に分割するʼ  /データベースのヘルパー void OpenDatabase(string location, string user); void CloseDatabase(string location);  ｝ こ  れで概要が把握しやすくなった。コード行は増えたけど、ずっと読みやすくなっ たと思う。グループに分けたことで、最初につのグループを把握して、あとから 必要になったときに詳細を読めるようになった。 .コードを「段落」に分割する 文章は複数の段落に分割されている。それは  ●似ている考えをグループにまとめて、他の考えと分けるためだく  ●視覚的な「踏み石」を提供できるからだ。これがなければ、ページのなかて  自分の場所を見失ってしまう。  ●段落単位で移動できるようになるからだｃ  これと同じ理由で、コードも「段落」に分けるべきだ。例えば、以下のようなひと  塊りのコードは誰も読む気がしない。  ユーザのメール帳をインポートして、システムのユーザと照合する。 そして、まだ友達になっていないユーザの一覧を表示する。 def suggest_new_friends(user, email_password):  friends = user・friends() friend emails = set(f.email for f in friends) contacts = import contacts(user.email, email_password) contact emails = set(c.email for c in contacts) non friend emails = contact emails - friend emails suggestedjriends = User, objects, select (email__in=non_friend_emails display[\'user\'] = user display!\'friends\'] = friends d i splay [\'suggested Jriends\' ] = suggestedjriends return render(\"suggested friends.html\", display)  わかりにくかもしれないけど、この関数はいくつかの手順で成り立っているので、  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(69,1,68,'５２１４章美しさ\n\nコードを段落に分割するといいく\n\ndef suggest neﾚ^friends(user, email password):\n＃ユーザの友達のメールアドレスを取得する。\nfriends = user・friends()\nfriend emails = set(f.email for f in friends\n\n＃ユーザのメールアカウントからすべてのメールアドレスをインポートする。\ncontacts = import_contacts(user.email, email password)\ncontact_emails = set(c・email for c in contacts)\n\n＃まだ友達になっていないユーザを探す。\nnon friend emails = contact emails - friend emails\nsuggested_friends = User.objects.select(email in=non friend emails\'\n\n＃それをページに表示する。\nd\ni\nsplay[\'user\'] = user\ndisplay[\'friends\'] = friends\nd\ni\nsplay [\'suggestedjriends\'] = suggested friends\nreturn render(\"suggested friends・html\", display)\n\n段落ごとに要約コメントを追加した。これでコードにざっと目を通せるようになっ\n\nた（｢5章コメントすべきことを知る」参照)。\n\n文章と同じように、コードを分割する方法もいろいろある。長い段落が好きなプロ\n\nグラマもいれば、短い段落が好きなプログラマもいるだろう。\n4.8個人的な好みと一貫ʻ性\n最終的には個人の好みになってしまうこともある。例えば、クラス定義の開き括弧\n\nの位置がそうだ。\n\nc\nl\nass Logger {\n\n● ● ●\n\nたは\n\n}\n\n； ま\n\n','章美しさ  コードを段落に分割するといいく  def suggest neﾚ^friends(user, email password): ユーザの友達のメールアドレスを取得する。 friends = user・friends() friend emails = set(f.email for f in friends  ユーザのメールアカウントからすべてのメールアドレスをインポートする。 contacts = import_contacts(user.email, email password) contact_emails = set(c・email for c in contacts)  まだ友達になっていないユーザを探す。 non friend emails = contact emails - friend emails suggested_friends = User.objects.select(email in=non friend emails\'  それをページに表示する。 d i splay[\'user\'] = user display[\'friends\'] = friends d i splay [\'suggestedjriends\'] = suggested friends return render(\"suggested friends・html\", display)  段落ごとに要約コメントを追加した。これでコードにざっと目を通せるようになっ  た｢章コメントすべきことを知る」参照)。  文章と同じように、コードを分割する方法もいろいろある。長い段落が好きなプロ  グラマもいれば、短い段落が好きなプログラマもいるだろう。 .個人的な好みと一貫ʻ性 最終的には個人の好みになってしまうこともある。例えば、クラス定義の開き括弧  の位置がそうだ。  c l ass Logger {  ● ● ●  たは  }   ま  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(70,1,69,'４８個人的な好みと一貫性ʼ５３\n\nclass Logger\n\nちらを選んだとしても、コードの抗みやすさに大きな影紳はない。でも、この２\n\n; ど\n\n「１ }\n\nつのスタイルを混ぜてしまうと、すごく読みにくいものになってしまう。\n\nぼくたちは「|H1違った」スタイルを仙っているプロジェクトに数多く携わってき\nた。でも、そこではプロジェクトの規約にしたがうようにした。一貫性のほうが大切\nなことだからだ。\n\n(cid:20276) と な る 考 え\n一貫性のあるスタイルは「正しい」スタイルよりも大切だ：\n\n','個人的な好みと一貫性ʼ  class Logger  ちらを選んだとしても、コードの抗みやすさに大きな影紳はない。でも、この  ; ど  「 }  つのスタイルを混ぜてしまうと、すごく読みにくいものになってしまう。  ぼくたちは「|H違った」スタイルを仙っているプロジェクトに数多く携わってき た。でも、そこではプロジェクトの規約にしたがうようにした。一貫性のほうが大切 なことだからだ。  (cid:) と な る 考 え 一貫性のあるスタイルは「正しい」スタイルよりも大切だ  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(71,1,70,'５４１４章美しさ\n\n4 . 9 ま と め\n\n誰もが美しいコードを見るのが好きだ。一貫性と意味のあるやり方でコードを「整\n\n形」すれば、すばやく簡単にコードを読むことができる。\n\nここで紹介した技法をまとめよう。\n\n●複数のコードブロックで同じようなことをしていたら、シルエットも同じよ\n\nうなものにする。\n\n●コードの「列」を整列すれば、概要が把握しやすくなる。\n\n●ある場所でA-B-Cのように並んでいたものを、他の場所でB-C-Aの\nように並べてはいけない。意味のある順番を選んで、常にその順番を守る。\n\n●空行を使って大きなブロックを論理的な「段落」に分ける。\n\n','章美しさ   .  ま と め  誰もが美しいコードを見るのが好きだ。一貫性と意味のあるやり方でコードを「整  形」すれば、すばやく簡単にコードを読むことができる。  ここで紹介した技法をまとめよう。  ●複数のコードブロックで同じようなことをしていたら、シルエットも同じよ  うなものにする。  ●コードの「列」を整列すれば、概要が把握しやすくなる。  ●ある場所でA-B-Cのように並んでいたものを、他の場所でB-C-Aの ように並べてはいけない。意味のある順番を選んで、常にその順番を守る。  ●空行を使って大きなブロックを論理的な「段落」に分ける。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(72,1,71,'｜ 雛\n\n５章\nコメントすべきことを知る\n\n取扱説明書\n\n)\n）\n\n必要!(cid:106)\n\n不要\n\n','｜ 雛  章 コメントすべきことを知る  取扱説明書  )   必要!(cid:)  不要  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(73,1,72,'５６１５章コメントすべきことを知を\n\n本章の目標は、コメントすべきことを知ってもらうことだ。コメントの目的閲\n｢コードの動作を説明する」ことだと思っているかもしれない。でもそれは、目的α\nごく一部でしかない。\n\n(cid:20276)となる考え\nコメントの目的は、書き手の意図を読み手に知らせることである。\n\nコードを書いているときには、君の頭のなかに大切な情報がたくさんあると思う。\nでも、誰かが君のコードを読むときには、その情報は失われてしまう。コードを読む\n人が持っているのは、目の前にあるコードだけだ。\n\n本章では、頭のなかにある情報をいつ書き出せばいいのかという例を数多く紹介し\nている。コメントに関してよく言われるようなことには触れていない。もっと興味深\nくて「注目されていない」側面に集中した。\n本章では、以下の話題を取り上げる。\n\n●コメントするべきでは「ない」ことを知る。\n\n●コードを書いているときの自分の考えを記録する。\n\n●読み手の立場になって何が必要になるかを考える。\n\n','章コメントすべきことを知を  本章の目標は、コメントすべきことを知ってもらうことだ。コメントの目的閲 ｢コードの動作を説明する」ことだと思っているかもしれない。でもそれは、目的α ごく一部でしかない。  (cid:)となる考え コメントの目的は、書き手の意図を読み手に知らせることである。  コードを書いているときには、君の頭のなかに大切な情報がたくさんあると思う。 でも、誰かが君のコードを読むときには、その情報は失われてしまう。コードを読む 人が持っているのは、目の前にあるコードだけだ。  本章では、頭のなかにある情報をいつ書き出せばいいのかという例を数多く紹介し ている。コメントに関してよく言われるようなことには触れていない。もっと興味深 くて「注目されていない」側面に集中した。 本章では、以下の話題を取り上げる。  ●コメントするべきでは「ない」ことを知る。  ●コードを書いているときの自分の考えを記録する。  ●読み手の立場になって何が必要になるかを考える。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(74,1,73,'5］コメントするべきでは「ない」こと｜５７\n\n5.1コメントするべきでは「ない」こと\n\n一\n●\n心\n陣\n\n一\n一\n《\n\n＝＆＝\n\n〜\n\n竺 ﾏ o x\n\n鼠\n/\n1\n１\n\n(cid:7783)(cid:7761)\n\n言悟i蕊\n\n梨蕊\n\nコメントを読むとその分だけコードを読む時間がなくなる。コメントは、面を占弧\nしてしまう。言い換えれば、コメントにはそれだけのfllll仙を持たせるべきなんだ。そ\nれでは、価仙のないコメンl､と価仙のあるコメントの違いは何だろうか？\n\n以|､̅のコードに書かれたコメンI､には1Illl値がない。\n\n// Accountクラスの定義\nclass Account I\n\npublic:\n／／コンストラクタ\nAccountQ:\n\n','］コメントするべきでは「ない」こと｜  .コメントするべきでは「ない」こと  一 ● 心 陣  一 一 《    〜  竺 ﾏ o x  鼠 /    (cid:)(cid:)  言悟i蕊  梨蕊  コメントを読むとその分だけコードを読む時間がなくなる。コメントは、面を占弧 してしまう。言い換えれば、コメントにはそれだけのfllll仙を持たせるべきなんだ。そ れでは、価仙のないコメンl､と価仙のあるコメントの違いは何だろうか  以|､̅のコードに書かれたコメンI､にはIlll値がない。  // Accountクラスの定義 class Account I  public: コンストラクタ AccountQ:  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(75,1,74,'５８１１５章コメントすべきことを知る\n\n// profitに新しい値を設定する\nvoid SetProﬁt(double proﬁt);\n\n/／このAccountからprofitを返す\ndouble CetProﬁtQ:\n\n新しい情報を提供するわけでもなく、読み手がコードを理解しやすくなるわけでも\n\nない。全く価値がない。\n\n(cid:20276)となる考え\nコードからすぐにわかることをコメントに書かない。\n\nこの「すぐに」が大切だ。以下のPythonのコードのコメントについて考えてみよ\n\nう\n。\n\n＃２番めの!*\'以降をすべて削除する\nname = \'*\'.ioin(line・sPlit(!*!)[:2]〉\n\n厳密に言えばこのコメントも「新しい情報」を提供していない。コードを見ればど\nのように動くかはわかる。でも、コードを理解するよりも、コメントを読んだほうか\n早く理解できる。\n\nコメントのためのコメントをしない\n\n','章コメントすべきことを知る  // profitに新しい値を設定する void SetProﬁt(double proﬁt);  /このAccountからprofitを返す double CetProﬁtQ:  新しい情報を提供するわけでもなく、読み手がコードを理解しやすくなるわけでも  ない。全く価値がない。  (cid:)となる考え コードからすぐにわかることをコメントに書かない。  この「すぐに」が大切だ。以下のPythonのコードのコメントについて考えてみよ  う 。  番めの!*\'以降をすべて削除する name = \'*\'.ioin(line・sPlit(!*!)[:]〉  厳密に言えばこのコメントも「新しい情報」を提供していない。コードを見ればど のように動くかはわかる。でも、コードを理解するよりも、コメントを読んだほうか 早く理解できる。  コメントのためのコメントをしない  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(76,1,75,'５１コメントするべきでは「ない」こと｜５９\n\n「宿題に出したコードの関数には必ずコメントをつけろ」学生たちにこんなことを\n言う大学教授がいる。そんなことを言われたら、コメントをつけていない裸の関数に\n罪悪感を抱き、関数の名前と引数をそのまま文章形式でコメントに書き直すように\nなってしまう。\n\n/／与えられたsubtreeに含まれるnameとdepthに合致したNodeを見つける。\nNode* FindNodeInSubtree(Node* subtree, string name, int depth);\n\nこれは「価値のないコメント」だ（関数宣言とほぼ同じだ)。このコメントは削除\n\nするか改善すべきだろう。\n\nコメントをつけたければ、もっと大切なことを説明したほうがいい。\n\n/／与えられた\'name\'に合致したNodeかNULLを返す。\n/／もしdepth <= 0ならば、\'subtree\'だけを調べる。\n/／もしdepth == Nならば、\'subtree\'とその下のＮ階層まで調べる。\nNode* FindNodeInSubtree(Node* subtree, string name, int depth);\n\nひどい名前はコメントをつけずに名前を変える\n\nコメントはひどい名前の埋め合わせに使うものではない。例えば､CleanReplyQ\n\nという関数につけたコメントがある。\n\n// Replyに対してRequestで記述した制限を課す。\n/／例えば、返ってくる項目数や合計バイト数など。\nvoid CleanReply(Request request, Reply reply);\n\nこのコメントは「クリーン(clean)」の意味をわかりやすく説明しているだけだ。\n\n｢制限を課す(enforce limit)」という言葉を関数名に入れたほうがいい。\n\n//  \'reply\'を\'request\'にある項目数やバイト数の制限に合わせる。\nvoid EnforceLimitsFromRequest(Request request, Reply reply);\n\nこの関数名は「自己文書化」されている。関数名はいろんなところで使用されるの\n\nだから、優れたコメントよりも名前のほうが大切だ。\n\nひどい名前の関数にコメントをつけた例をもう１つ挙げよう。\n\n','コメントするべきでは「ない」こと｜  「宿題に出したコードの関数には必ずコメントをつけろ」学生たちにこんなことを 言う大学教授がいる。そんなことを言われたら、コメントをつけていない裸の関数に 罪悪感を抱き、関数の名前と引数をそのまま文章形式でコメントに書き直すように なってしまう。  /与えられたsubtreeに含まれるnameとdepthに合致したNodeを見つける。 Node* FindNodeInSubtree(Node* subtree, string name, int depth);  これは「価値のないコメント」だ関数宣言とほぼ同じだ)。このコメントは削除  するか改善すべきだろう。  コメントをつけたければ、もっと大切なことを説明したほうがいい。  /与えられた\'name\'に合致したNodeかNULLを返す。 /もしdepth <= ならば、\'subtree\'だけを調べる。 /もしdepth == Nならば、\'subtree\'とその下のＮ階層まで調べる。 Node* FindNodeInSubtree(Node* subtree, string name, int depth);  ひどい名前はコメントをつけずに名前を変える  コメントはひどい名前の埋め合わせに使うものではない。例えば､CleanReplyQ  という関数につけたコメントがある。  // Replyに対してRequestで記述した制限を課す。 /例えば、返ってくる項目数や合計バイト数など。 void CleanReply(Request request, Reply reply);  このコメントは「クリーン(clean)」の意味をわかりやすく説明しているだけだ。  ｢制限を課す(enforce limit)」という言葉を関数名に入れたほうがいい。  //  \'reply\'を\'request\'にある項目数やバイト数の制限に合わせる。 void EnforceLimitsFromRequest(Request request, Reply reply);  この関数名は「自己文書化」されている。関数名はいろんなところで使用されるの  だから、優れたコメントよりも名前のほうが大切だ。  ひどい名前の関数にコメントをつけた例をもうつ挙げよう。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(77,1,76,'60       5章コメントすべきことを知る\n\n/／レジストリキーの八ンドルを解放する。実際のレジストリは変更しない。\nvoid DeleteRegistry(RegistryKey* key);\n\nDeleteRegistryQは危険な関数のように見える（レジストリを削除する！？)。で\nも、コメントにある「実際のレジストリは変更しない」は、危険な関数ではないと\n言っている。\n\n以下のような自己文書化した名前をつけたほうがいいだろう。\n\nvoid ReleaseRegistryHandle(RegistryKey* key);\n\n通常は「補助的なコメント」（コードの読みにくさを補うコメント）が必要になる\nことはない。プログラマはこのことを「優れたコード〉ひどいコード＋優れたコメ\nント」と言っている。\n\n5.2自分の考えを記録する\n何をコメントすべきでないかはわかった。それじゃあ、何をコメントすべきかを考\n\nえていこう（みんな考えてないことが多いよね)。\n\n優れたコメントというのは「考えを記録する」ためのものである。コードを書いて\n\nいるときに持っている「大切な考え」のことだ。\n\n『 監 督 の コ メ ン タ リ ー 」 を 入 れ る\n\n映画のDVDにはよく「監督のコメンタリー」がついてくる。映画の製作者が自分\nの考えや物語について語ってくれるので、作品がどのように作られたのかを理解する\nのに役立つ。これと同じように、コメントにはコードに対する大切な考えを記録しな\nければいけない。\n\n例えば、こんな感じだ。\n\n/／このデータだとハシシュテーブルよりもバイナリツリーのほうが40%速かった。\n/／左右の比較よりも八ツシュの計算コストのほうが高いようだ。\n\nコメントから情報を得ることができるので、下手に最適化しようとして無駄に時間\n\nを使う必要がなくなる。\n\n例は他にもある。\n\n','       章コメントすべきことを知る  /レジストリキーの八ンドルを解放する。実際のレジストリは変更しない。 void DeleteRegistry(RegistryKey* key);  DeleteRegistryQは危険な関数のように見えるレジストリを削除する)。で も、コメントにある「実際のレジストリは変更しない」は、危険な関数ではないと 言っている。  以下のような自己文書化した名前をつけたほうがいいだろう。  void ReleaseRegistryHandle(RegistryKey* key);  通常は「補助的なコメント」コードの読みにくさを補うコメントが必要になる ことはない。プログラマはこのことを「優れたコード〉ひどいコード優れたコメ ント」と言っている。  .自分の考えを記録する 何をコメントすべきでないかはわかった。それじゃあ、何をコメントすべきかを考  えていこうみんな考えてないことが多いよね)。  優れたコメントというのは「考えを記録する」ためのものである。コードを書いて  いるときに持っている「大切な考え」のことだ。  『 監 督 の コ メ ン タ リ ー 」 を 入 れ る  映画のDVDにはよく「監督のコメンタリー」がついてくる。映画の製作者が自分 の考えや物語について語ってくれるので、作品がどのように作られたのかを理解する のに役立つ。これと同じように、コメントにはコードに対する大切な考えを記録しな ければいけない。  例えば、こんな感じだ。  /このデータだとハシシュテーブルよりもバイナリツリーのほうが%速かった。 /左右の比較よりも八ツシュの計算コストのほうが高いようだ。  コメントから情報を得ることができるので、下手に最適化しようとして無駄に時間  を使う必要がなくなる。  例は他にもある。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(78,1,77,'５２自分の考えを記録する61\n\n/／ヒューリスティックだと単語が漏れることがあるが仕方ない。100％は難しい：\n\nこのコメントがなければ、失敗するテストケースに無駄な時間をかけることになる\n\nかもしれない。あるいは、バグだと思って修llとしたくなるだろう。\n\nコードが汚いI\'ll  IIIをコメンl､にI  l\"いてもいい。\n\n/／このクラスは汚くなってきている。\n/／サブクラス\'ResourceNode\'を作って整理したほうがいいかもしれない。\n\nこのコメントはコードが汚いことを認めている。そして、誰かに修正を促している\n(簡単な仕様書もついているoコメントがなければ、コードが汚くて誰も近づかな\nかっただろう。\n\nコードの欠陥にコメントをつける\nコードは絶えず進化しているので、その過程で欠陥を生む迎命にある。その欠陥を\n文書化することを恥ずかしがってはいけない。例えば、改善が必要なときは以ドのよ\nうに書いておこう。\n\n// TODO:もっと高速なアルゴリズムを使う\n\nコードが未完成のときは、以下のように書いておこう。\n\n// TODOfダスティン): MC以外のフォーマットに対応する\n\nプログラマがよく使う記法がいくつかある簿\n\nれらの記法をいつどのように使うかについては、チームの規約があるかもしれ\n  (小文字）や\n\nない。例えば、TODO:は大きな問題に使って、小さな|川題にはtodo: \n\n \n\n典型的な意味〃:(cid:106)…-塗,_…ふ--…ー\nあとで手をつける\n既知の不典合があるコード\nあまりキレイじゃない解決策\n危|晩！大きな問(cid:7735)がある\n\n記法\nT\nO\nD\nO\n：\nXNE：\nF\nI\nＨ\nＡ\n〔\nK\n：\nＸ\nＸ\nＸ\n\n： こ\n\n','自分の考えを記録する  /ヒューリスティックだと単語が漏れることがあるが仕方ない。は難しい  このコメントがなければ、失敗するテストケースに無駄な時間をかけることになる  かもしれない。あるいは、バグだと思って修llとしたくなるだろう。  コードが汚いI\'ll  IIIをコメンl､にI  l\"いてもいい。  /このクラスは汚くなってきている。 /サブクラス\'ResourceNode\'を作って整理したほうがいいかもしれない。  このコメントはコードが汚いことを認めている。そして、誰かに修正を促している (簡単な仕様書もついているoコメントがなければ、コードが汚くて誰も近づかな かっただろう。  コードの欠陥にコメントをつける コードは絶えず進化しているので、その過程で欠陥を生む迎命にある。その欠陥を 文書化することを恥ずかしがってはいけない。例えば、改善が必要なときは以ドのよ うに書いておこう。  // TODO:もっと高速なアルゴリズムを使う  コードが未完成のときは、以下のように書いておこう。  // TODOfダスティン): MC以外のフォーマットに対応する  プログラマがよく使う記法がいくつかある簿  れらの記法をいつどのように使うかについては、チームの規約があるかもしれ   (小文字や  ない。例えば、TODO:は大きな問題に使って、小さな|川題にはtodo:      典型的な意味〃:(cid:)…-塗,_…ふ--…ー あとで手をつける 既知の不典合があるコード あまりキレイじゃない解決策 危|晩大きな問(cid:)がある  記法 T O D O  XNE F I Ｈ Ａ 〔 K  Ｘ Ｘ Ｘ   こ  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(79,1,78,'６２１５章コメントすべきことを知る\n\nmaybe-later: (あとで直す）を使うなどだ。\n\n大切なのは、これからコードをどうしたいのかを自由にコメントに書くことだ。そ\nういうコメントを書くことで、コードの品質や状態を知らせたり、さらには改善の方\n向を示したりできるのだ。\n\n定数にコメントをつける\n定数を定義するときには、その定数が何をするのか、なぜその値を持っているのか\nという「背景」が存在する場合が多い。例えば、コードのなかで以下のような定数を\n見かけることがあるだろう。\n\nNUM THREADS = 8\n\n■■■■\n\nこのコードにはコメントは必要なさそうだ。でも、これを書いたプログラマには何\n\nか考えがあるかもしれない。\n\nNUM THREADS = 8   #値は「>= 2 * num processors」で十分。\n\nこれなら値の決め方がわかる（１だと小さすぎて、５０だと大きすぎる)。\n値は厳密じゃなくてもいい場合もある。この場合もコメントが役に立つ。\n\n/／合理的な限界値。人間はこんなに読めない。\nconst int MAX RSS SUBSCRIPTIONS = IOOO;\n\n値がいい感じに設定されているので、それ以上調整する必要がないこともある。\n\nimage quality = 0.72;   // 0.72ならユーザはファイルサイズと品質の面で妥協できる。\n\nこんなコメントはつけないと思っているかもしれないけど、すごく役に立ってい\n\nる\n。\n\nなかには名前が明確なのでコメントが必要ない定数もあるSECONDS  PER  DAYな\nど)。だけど、ぼくたちの経験からすると、コメントをつけて改善できる定数は多い。\n定数の値を決めたときに頭のなかで考えていたことを記録することが大切なのだ。\n\n','章コメントすべきことを知る  maybe-later: (あとで直すを使うなどだ。  大切なのは、これからコードをどうしたいのかを自由にコメントに書くことだ。そ ういうコメントを書くことで、コードの品質や状態を知らせたり、さらには改善の方 向を示したりできるのだ。  定数にコメントをつける 定数を定義するときには、その定数が何をするのか、なぜその値を持っているのか という「背景」が存在する場合が多い。例えば、コードのなかで以下のような定数を 見かけることがあるだろう。  NUM THREADS =   ■■■■  このコードにはコメントは必要なさそうだ。でも、これを書いたプログラマには何  か考えがあるかもしれない。  NUM THREADS =    #値は「>=  * num processors」で十分。  これなら値の決め方がわかるだと小さすぎて、だと大きすぎる)。 値は厳密じゃなくてもいい場合もある。この場合もコメントが役に立つ。  /合理的な限界値。人間はこんなに読めない。 const int MAX RSS SUBSCRIPTIONS = IOOO;  値がいい感じに設定されているので、それ以上調整する必要がないこともある。  image quality = .;   // .ならユーザはファイルサイズと品質の面で妥協できる。  こんなコメントはつけないと思っているかもしれないけど、すごく役に立ってい  る 。  なかには名前が明確なのでコメントが必要ない定数もあるSECONDS  PER  DAYな ど)。だけど、ぼくたちの経験からすると、コメントをつけて改善できる定数は多い。 定数の値を決めたときに頭のなかで考えていたことを記録することが大切なのだ。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(80,1,79,'５３読み手の立場になって考えるʼ６３\n\n5.3読み手の立場になって考える\n本書で使っている技法は、他の人にコードがどのように見えるかを想像するもの\nだ。「他の人」というのは、プロジェクトのことを君のように熟知していない人のこ\nとである。どこにコメントをつければいいかを判断するのにこの技法が役に立つ。\n\n質問されそうなことを想像する\n\n僻\n\nか質問はありますか？\nあの看板のこと以外で\n\n蝋 何\n\nアメリカ遥鵜局一\n\n郷\n\nＷ\n\nＩＮ\n\nﾍｸﾌ\n\n他人のコードを読むと「えっ？これって何なの？」と疑問に思うところがあるIま\n\nずだ。こういうところにコメントをつければいい。\n\n例えば、ClearQの定義を見てみよう。\n\nstruct Recorder {\n\nvector<ﬂoat> data;\n\n','読み手の立場になって考えるʼ  .読み手の立場になって考える 本書で使っている技法は、他の人にコードがどのように見えるかを想像するもの だ。「他の人」というのは、プロジェクトのことを君のように熟知していない人のこ とである。どこにコメントをつければいいかを判断するのにこの技法が役に立つ。  質問されそうなことを想像する  僻  か質問はありますか あの看板のこと以外で  蝋 何  アメリカ遥鵜局一  郷  Ｗ  ＩＮ  ﾍｸﾌ  他人のコードを読むと「えっこれって何なの」と疑問に思うところがあるIま  ずだ。こういうところにコメントをつければいい。  例えば、ClearQの定義を見てみよう。  struct Recorder {  vector<ﬂoat> data;  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(81,1,80,'６４１５章コメントすべきことを知る\n\nvoid ClearQ {\n\n｝\n\nvector<float>().swap(data);   //えっ？どうしてdata.clear(）じゃないの？\n\nこのコードを見たC++プログラマは、「どうして単純にdata.clearQせずに空の\nベクタをスワップするんだ？」と疑問に思うだろう。このようにしているのは、ベク\nタのメモリを解放してメモリアロケータに戻す方法がこれしかないからだ。これはあ\nまり知られていないことである。つまり、ここにコメントをつけるべきなのだ員\n\n/／ベクタのメモリを解放する(FSTL swap技法」で検索してみよう(cid:106)\nvector<ﬂoat>().swap(data);\nハマリそうな震を告知する\n\n_ムー 』\n\n','章コメントすべきことを知る  void ClearQ {  ｝  vector<float>().swap(data);   //えっどうしてdata.clear(じゃないの  このコードを見たC++プログラマは、「どうして単純にdata.clearQせずに空の ベクタをスワップするんだ」と疑問に思うだろう。このようにしているのは、ベク タのメモリを解放してメモリアロケータに戻す方法がこれしかないからだ。これはあ まり知られていないことである。つまり、ここにコメントをつけるべきなのだ員  /ベクタのメモリを解放する(FSTL swap技法」で検索してみよう(cid:) vector<ﬂoat>().swap(data); ハマリそうな震を告知する  _ムー 』  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(82,1,81,'５３読み手の立場になって考えるʼ６５\n\n関数やクラスを文書化するときには、「このコードを見てビックリすることは何だ\nろう？どんなふうに間違えて使う可能性があるだろう？」と自分に問いかけるとい\nい。基本的にはコードを使うときに直面する問題を「前もって」予測したい。\n\n例えば、ユーザにメールを送信するコードを書いたとしよう。\n\nvoid SendEmail(string to, string subject, string body);\n\nこの関数の実装では、外部のメールサービスに接続している。その接続には１秒\n以上かかる。このことを知らないウェブアプリケーション開発者が、HTTPリクエ\nストの処理中に誤ってこの関数を呼び出してしまうかもしれない（メールサービスが\nダウンしていると、ウェブアプリケーションが「ハング」してしまう)o\n\nこのような不幸を防ぐには、「実装の詳細」についてコメントを書くべきだ。\n\n/／メールを送信する外部サービスを呼び出している（1分でタイムアウト）\nvoid SendEmail(string to, string subject, string body);\n\n以下はまた別の例だ。FixBrokenHtmlという関数があるとする。これは閉じタグ\n\nのない壊れたHTMLを修復するためのものだ。\n\ndef FixBrokenHtml(html): ...\n\nこの関数は間違いなく動く。ただし、対応の取れていないタグのネストが深いと処\n\n理に時間がかかってしまう。HTMLによっては何分もかかることもある。\n\nユーザが使った「あと」で気づくよりも、使う「前」に告知するほうがいい。\n\n//実行時間は0(タグの数＊タグの深さの平均)なので、ネストの深さに気を付ける。\ndef FixBrokenHtml(html): ...\n\n','読み手の立場になって考えるʼ  関数やクラスを文書化するときには、「このコードを見てビックリすることは何だ ろうどんなふうに間違えて使う可能性があるだろう」と自分に問いかけるとい い。基本的にはコードを使うときに直面する問題を「前もって」予測したい。  例えば、ユーザにメールを送信するコードを書いたとしよう。  void SendEmail(string to, string subject, string body);  この関数の実装では、外部のメールサービスに接続している。その接続には秒 以上かかる。このことを知らないウェブアプリケーション開発者が、HTTPリクエ ストの処理中に誤ってこの関数を呼び出してしまうかもしれないメールサービスが ダウンしていると、ウェブアプリケーションが「ハング」してしまう)o  このような不幸を防ぐには、「実装の詳細」についてコメントを書くべきだ。  /メールを送信する外部サービスを呼び出している分でタイムアウト void SendEmail(string to, string subject, string body);  以下はまた別の例だ。FixBrokenHtmlという関数があるとする。これは閉じタグ  のない壊れたHTMLを修復するためのものだ。  def FixBrokenHtml(html): ...  この関数は間違いなく動く。ただし、対応の取れていないタグのネストが深いと処  理に時間がかかってしまう。HTMLによっては何分もかかることもある。  ユーザが使った「あと」で気づくよりも、使う「前」に告知するほうがいい。  //実行時間は(タグの数タグの深さの平均)なので、ネストの深さに気を付ける。 def FixBrokenHtml(html): ...  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(83,1,82,'６６１５章コメントすべきことを知る\n\n｢全体像」のコメント\n\n新しいチームメンバにとって、最も難しいのは「全体像」の理解である。クラスは\nどのように連携しているのか。データはどのようにシステムを流れているのか。エン\nトリーポイントはどこにあるのか。システムを設計した人は、こうしたことについて\nコメントを書かないことが多い。あまりにも密接にシステムに関わりすぎているから\nだ\n。\n\nこんな思考実験をしてみよう。新しくチームに参加した人がいるとする。彼女は君\n\nの隣に座っている。彼女にはコードに慣れてもらわなければいけない。\n\n君は彼女にコードのことを教える。ファイルやクラスを指して、こんなことを言う\n\nだろう。\n\n●「これはビジネスロジックとデータベースをつなぐグルーコードです。アプ\n\nリケーションから直接使ってはいけません」\n\n●「このクラスは複雑に見えますけと母、単なるキャッシュです。システムのこ\n\nとは関知していません」\n\n','章コメントすべきことを知る  ｢全体像」のコメント  新しいチームメンバにとって、最も難しいのは「全体像」の理解である。クラスは どのように連携しているのか。データはどのようにシステムを流れているのか。エン トリーポイントはどこにあるのか。システムを設計した人は、こうしたことについて コメントを書かないことが多い。あまりにも密接にシステムに関わりすぎているから だ 。  こんな思考実験をしてみよう。新しくチームに参加した人がいるとする。彼女は君  の隣に座っている。彼女にはコードに慣れてもらわなければいけない。  君は彼女にコードのことを教える。ファイルやクラスを指して、こんなことを言う  だろう。  ●「これはビジネスロジックとデータベースをつなぐグルーコードです。アプ  リケーションから直接使ってはいけません」  ●「このクラスは複雑に見えますけと母、単なるキャッシュです。システムのこ  とは関知していません」  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(84,1,83,'5.3読み手の立場になって考えるʼ６７\n\n簡単な会話だけど、ソースコードを読んだだけでは得られない情報が手に入った。\nこれは高レベルのコメントに書くべき情報だ。\n以下は、ファイルにつけたコメントの例だ。\n\n/／このファイルには、ファイルシステムに関する便利なインタフェースを提供\n/／するヘルパー関数が含まれています。ファイルのパーミッションなどを扱います。\n\nなにも大量の正式文書を書けと言ってるわけではないので、ビビらないで欲しい。\n\n短い適切な文章で構わない。何もないよりはマシだ。\n\n要 約 コ メ ン ト\n\n関数の内部でも「全体像」についてコメントするのはいい考えだ。低レベルのコー\nドをうまく要約したコメントを紹介しよう。\n\n＃顧客が自分で購入した商品を検索する\nfor customer id in all customers:\n\nfor sale in all sales[customer id].sales:\n\nif sale･recipient == customer_id:\n\nコメントがないとコードを読んでいる途中で意味がわからなくなるfall\n\ncustomersをイテレートするのはわかるけど……何のために？」)。\n\nこのような要約コメントは、関数の内部にある大きな「塊」につけてもいい。\n\ndef GenerateUserReportQ:\n\n＃このユーザのロックを獲得する\n\n● ● ●\n\n＃ユーザのI情報をDBから読み込む\n\n＃情報をファイルに書き出す\n\n＃このユーザのロックを解放する\n\n関 数 の 処 理 を 箇 条 書 き で ま と め た も の な の で 、 詳 細 を 調 べ な く て も 関 数 の 概 要 が 把\n\n','.読み手の立場になって考えるʼ  簡単な会話だけど、ソースコードを読んだだけでは得られない情報が手に入った。 これは高レベルのコメントに書くべき情報だ。 以下は、ファイルにつけたコメントの例だ。  /このファイルには、ファイルシステムに関する便利なインタフェースを提供 /するヘルパー関数が含まれています。ファイルのパーミッションなどを扱います。  なにも大量の正式文書を書けと言ってるわけではないので、ビビらないで欲しい。  短い適切な文章で構わない。何もないよりはマシだ。  要 約 コ メ ン ト  関数の内部でも「全体像」についてコメントするのはいい考えだ。低レベルのコー ドをうまく要約したコメントを紹介しよう。  顧客が自分で購入した商品を検索する for customer id in all customers:  for sale in all sales[customer id].sales:  if sale･recipient == customer_id:  コメントがないとコードを読んでいる途中で意味がわからなくなるfall  customersをイテレートするのはわかるけど……何のために」)。  このような要約コメントは、関数の内部にある大きな「塊」につけてもいい。  def GenerateUserReportQ:  このユーザのロックを獲得する  ● ● ●  ユーザのI情報をDBから読み込む  情報をファイルに書き出す  このユーザのロックを解放する  関 数 の 処 理 を 箇 条 書 き で ま と め た も の な の で 、 詳 細 を 調 べ な く て も 関 数 の 概 要 が 把  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(85,1,84,'６８１５章コメントすべきことを知る\n\n握できるようになっている（塊を関数に分割できるならそうしよう。前にも言ったけ\nど、ひどいコードに優れたコメントをつけるよりも、優れたコードのほうがいい)。\n\nWHAT・WHY・HOWをコメントに書くべきか１\n\n「コメントにはWHATではなく（あるいはHOWではなく)  WHYを書こう」というア\nドバイスを耳にしたことがあるかもしれない。確かにキャッチーな言葉だけど、少し単純\n化しすぎていて、人によって受け取り方が違うかもしれない。\n\nぼくたちからのアドバイスはこうだ。「コードを理解するのに役立つものなら何でもいい\nから書こう」これなら、WHATでもHOWでもWHYでも（あるいは３つ全部でも）害\nける。\n\n5.4ライターズブロックを乗り越える\nプログラマの多くはコメントを書きたがらない。コメントをうまく書くのは大変だ\nと思っているからだ。こうした「ライターズブロック↑」を乗り越えるには、とにか\nく書き始めるしかない。自分の考えていることをとりあえず書き出してみよう。生煮\nえであっても構わない。\n\n例えば、ある関数を作っていて、「ヤバい。これはリストに重複があったら面倒な\n\nことになる」と思ったとする。それをそのまま書き出せばいい。\n\n/／ヤバい。これはリストに重複があったら面倒なことになる\n\nね、簡単でしょう？変なコメントでもないよね（何もないよりはマシだ)。ただ、\nちょっとあいまいな表現かもしれない。言い回しをもっと詳細な言葉に置き換えると\nいいだろう。\n\n●「ヤバい」は「注意：これには気を付けて」という意味だ。\n\n●「これ」は「入力を処理するコード」という意味だ。\n\n●「面倒なことになる」は「実装が難しくなる」という意味だく\n\n↑●訳注行き詰まってしまって、文章が書けないこと。\n\n','章コメントすべきことを知る  握できるようになっている塊を関数に分割できるならそうしよう。前にも言ったけ ど、ひどいコードに優れたコメントをつけるよりも、優れたコードのほうがいい)。  WHAT・WHY・HOWをコメントに書くべきか  「コメントにはWHATではなくあるいはHOWではなく)  WHYを書こう」というア ドバイスを耳にしたことがあるかもしれない。確かにキャッチーな言葉だけど、少し単純 化しすぎていて、人によって受け取り方が違うかもしれない。  ぼくたちからのアドバイスはこうだ。「コードを理解するのに役立つものなら何でもいい から書こう」これなら、WHATでもHOWでもWHYでもあるいはつ全部でも害 ける。  .ライターズブロックを乗り越える プログラマの多くはコメントを書きたがらない。コメントをうまく書くのは大変だ と思っているからだ。こうした「ライターズブロック↑」を乗り越えるには、とにか く書き始めるしかない。自分の考えていることをとりあえず書き出してみよう。生煮 えであっても構わない。  例えば、ある関数を作っていて、「ヤバい。これはリストに重複があったら面倒な  ことになる」と思ったとする。それをそのまま書き出せばいい。  /ヤバい。これはリストに重複があったら面倒なことになる  ね、簡単でしょう変なコメントでもないよね何もないよりはマシだ)。ただ、 ちょっとあいまいな表現かもしれない。言い回しをもっと詳細な言葉に置き換えると いいだろう。  ●「ヤバい」は「注意これには気を付けて」という意味だ。  ●「これ」は「入力を処理するコード」という意味だ。  ●「面倒なことになる」は「実装が難しくなる」という意味だく  ↑●訳注行き詰まってしまって、文章が書けないこと。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(86,1,85,'5 . 5 ま と め ʼ ６ ９\n\n書き換えたコメントは以下のようになる。\n\n/／注意：このコードはリストの重複を処理できません（実装が難しいので)。\n\nコメントを書く作業は、３つの簡単な手順に分解できる。\n\n●頭のなかにあるコメントをとにかく書き出す。\n\n●コメントを読んで（どちらかと言えば）改善が必要なものを見つける。\n\n●改善する。\n\nコメントを書くようになれば、手順１の品質が次第によくなっていく。最終的に\nは、修正の必要がなくなるだろう。それに、早めにしょっちゅうコメントを書いてい\nけば、最後にまとめて大量のコメントを書くような事態に陥ることはない。\n\n5 . 5 ま と め\nコメントの目的とは、コードの意図を読み手に理解してもらうことである。本章で\nは、コードについてぼんやりと考えていたことをハッキリと理解して、実際に書き出\nすことをやってみた。\n\nコメントすべきでは「ない」こと：\n\n●コードからすぐに抽出できること。\n\n●ひどいコード（例えば、ひどい名前の関数）を補う「補助的なコメント｣。\n\nコメントを書くのではなくコードを修正する。\n\n記録すべき自分の考え：\n\n●なぜコードが他のやり方ではなくこうなっているのか（｢監督コメンタ\n\nリー｣)。\n\n●コードの欠陥をTODO:  *  XXX:などの記法を使って示す。\n\n●定数の値にまつわる「背景｣。\n\n',' .  ま と め ʼ    書き換えたコメントは以下のようになる。  /注意このコードはリストの重複を処理できません実装が難しいので)。  コメントを書く作業は、つの簡単な手順に分解できる。  ●頭のなかにあるコメントをとにかく書き出す。  ●コメントを読んでどちらかと言えば改善が必要なものを見つける。  ●改善する。  コメントを書くようになれば、手順の品質が次第によくなっていく。最終的に は、修正の必要がなくなるだろう。それに、早めにしょっちゅうコメントを書いてい けば、最後にまとめて大量のコメントを書くような事態に陥ることはない。   .  ま と め コメントの目的とは、コードの意図を読み手に理解してもらうことである。本章で は、コードについてぼんやりと考えていたことをハッキリと理解して、実際に書き出 すことをやってみた。  コメントすべきでは「ない」こと  ●コードからすぐに抽出できること。  ●ひどいコード例えば、ひどい名前の関数を補う「補助的なコメント｣。  コメントを書くのではなくコードを修正する。  記録すべき自分の考え  ●なぜコードが他のやり方ではなくこうなっているのか｢監督コメンタ  リー｣)。  ●コードの欠陥をTODO:  *  XXX:などの記法を使って示す。  ●定数の値にまつわる「背景｣。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(87,1,86,'7０       ５章コメントすべきことを知老\n\n読み手の立場になって考える：\n\n●コードを読んだ人が「えっ？」と思うところを予想してコメントをつける。\n\n●平均的な読み手が驚くような動作は文書化しておく。\n\n●ファイルやクラスには「全体像」のコメントを書く。\n\n●読み手が細部に捕らわれないように、コードブロックにコメントをつけて概\n\n要をまとめる。\n\n','       章コメントすべきことを知老  読み手の立場になって考える  ●コードを読んだ人が「えっ」と思うところを予想してコメントをつける。  ●平均的な読み手が驚くような動作は文書化しておく。  ●ファイルやクラスには「全体像」のコメントを書く。  ●読み手が細部に捕らわれないように、コードブロックにコメントをつけて概  要をまとめる。  ','2017-11-20 15:02:16','2017-11-20 15:02:16'),(88,1,87,'ʼ\n７？\n\n６章\nコメントは正確で簡潔に\n\n','ʼ   章 コメントは正確で簡潔に  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(89,1,88,'７２１６章コメントは正確で簡潔に\n\n前章では、何をコメントに書くべきかを説明した。本章では、どうすればコメント\n\nを正確で簡潔に書けるかを説明する。\n\nコメントを書くのであれば、正確に書くべきだ（できるだけ明確で詳細に)。また、\nコメントには画面の領域を取られるし、読むのにも時間がかかるので、簡潔なもので\nなければいけない。\n\n(cid:20276)となる考え\nコメントは領域に対する情報の比率が高くなければいけない。\n\nこれからそのやり方を見ていこう。\n6.1コメントを簡潔にしておく\n以下は、C++の型定義につけたコメントの例だ。\n\n// intはCategoryTypeo\n//  pairの最初のfloatは\'score\'o\n/／２つめは\'weight\'o\ntypedef hashjiapdnt, pair<ﬂoat, ﬂoat> > ScoreMap;\n\nどうして３行も使って説明しているのだろう？これなら１行で説明できないだ\n\nろうか？\n\n// CategoryType -> (score, weight)\ntypedef hashjiapdnt, pair<ﬂoat, ﬂoat> > ScoreMap;\n\n3行分の領域が必要なこともあるだろう。でも、ここには必要ない。\n6.2あいまいな代名詞を避ける\n古典漫才の「Who\'s  on  First?↑」からもわかるように、代名詞は物事を複雑にし\n\nてしまう。\n\n読み手は代名詞を「還元」しなければいけない。場合によっては、「それ」や「こ\n\nれ」が何を指しているのかよくわからないこともある。以下に例を挙げよう。\n\n訳注アボット＆コステロの「一塁手は誰？」という漫才。一塁手の名前が「Who  (誰・ダレ)」なので、\n｢一塁手は誰なの？」「一塁手はダレだよ」「こっちが誰かと聞いてるんだよ」「だからダレだよ」……とい\nう会話が延々と繰り返される。\n\n','章コメントは正確で簡潔に  前章では、何をコメントに書くべきかを説明した。本章では、どうすればコメント  を正確で簡潔に書けるかを説明する。  コメントを書くのであれば、正確に書くべきだできるだけ明確で詳細に)。また、 コメントには画面の領域を取られるし、読むのにも時間がかかるので、簡潔なもので なければいけない。  (cid:)となる考え コメントは領域に対する情報の比率が高くなければいけない。  これからそのやり方を見ていこう。 .コメントを簡潔にしておく 以下は、C++の型定義につけたコメントの例だ。  // intはCategoryTypeo //  pairの最初のfloatは\'score\'o /つめは\'weight\'o typedef hashjiapdnt, pair<ﬂoat, ﬂoat> > ScoreMap;  どうして行も使って説明しているのだろうこれなら行で説明できないだ  ろうか  // CategoryType -> (score, weight) typedef hashjiapdnt, pair<ﬂoat, ﬂoat> > ScoreMap;  行分の領域が必要なこともあるだろう。でも、ここには必要ない。 .あいまいな代名詞を避ける 古典漫才の「Who\'s  on  First?↑」からもわかるように、代名詞は物事を複雑にし  てしまう。  読み手は代名詞を「還元」しなければいけない。場合によっては、「それ」や「こ  れ」が何を指しているのかよくわからないこともある。以下に例を挙げよう。  訳注アボットコステロの「一塁手は誰」という漫才。一塁手の名前が「Who  (誰・ダレ)」なので、 ｢一塁手は誰なの」「一塁手はダレだよ」「こっちが誰かと聞いてるんだよ」「だからダレだよ」……とい う会話が延々と繰り返される。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(90,1,89,'６４関数の動作を正確に記述するʼ７３\n\n/／データをキャッシュに入れる。ただし、先にそのサイズをチェックする。\n\n「その」が指しているのは、「データ」かもしれないし「キャッシュ」かもしれな\nい。コードを読み進めていけば、どちらを指しているのかはわかるだろう。でも、そ\nうしないとわからないのであれば、何のためにコメントを書いているのだろう？\n\nまぎらわしいようであれば、名詞を代名詞に「代入」してみるといい。先ほどの例\n\nであれば、「それ」を「データ」に変えてみるのだ。\n\n/／データをキャッシュに入れる。ただし、先にデータのサイズをチェックする。\n\nこれが最も簡単な改善だ。あるいは、文章全体を書き換えて「それ」を明確にする\n\nこともできる。\n\n/／データが十分に小さければ、それをキャッシュに入れる。\n6.3歯切れの悪い文章を磨く\nコメントを正確にすることと簡潔にすることは両立することが多い。\n以下は、ウェブクローラの例だ。\n\n＃これまでにクロールしたURLかどうかによって優先度を変える。\n\nこの文章は問題なさそうに見える。でも、以下と比較してみるとどうだろうか。\n\n＃これまでにクロールしていないURLの優先度を高くする。\n\nこちらのほうが単純だし短いし直接的だ。さらには、クロールしていないURLの\n\n優先度が高いという、先のコメントでは言及されていない情報も含まれている。\n6.4関数の動作を正確に記述する\nファイルの行数を数える関数を書いているとしよう。\n\n/／このファイルに含まれる行数を返す。\nint CountLines(string filename) {…｝\n\nあまり正確なコメントではない。「行」にはさまざまな意味があるからだ。コー\n\n','関数の動作を正確に記述するʼ  /データをキャッシュに入れる。ただし、先にそのサイズをチェックする。  「その」が指しているのは、「データ」かもしれないし「キャッシュ」かもしれな い。コードを読み進めていけば、どちらを指しているのかはわかるだろう。でも、そ うしないとわからないのであれば、何のためにコメントを書いているのだろう  まぎらわしいようであれば、名詞を代名詞に「代入」してみるといい。先ほどの例  であれば、「それ」を「データ」に変えてみるのだ。  /データをキャッシュに入れる。ただし、先にデータのサイズをチェックする。  これが最も簡単な改善だ。あるいは、文章全体を書き換えて「それ」を明確にする  こともできる。  /データが十分に小さければ、それをキャッシュに入れる。 .歯切れの悪い文章を磨く コメントを正確にすることと簡潔にすることは両立することが多い。 以下は、ウェブクローラの例だ。  これまでにクロールしたURLかどうかによって優先度を変える。  この文章は問題なさそうに見える。でも、以下と比較してみるとどうだろうか。  これまでにクロールしていないURLの優先度を高くする。  こちらのほうが単純だし短いし直接的だ。さらには、クロールしていないURLの  優先度が高いという、先のコメントでは言及されていない情報も含まれている。 .関数の動作を正確に記述する ファイルの行数を数える関数を書いているとしよう。  /このファイルに含まれる行数を返す。 int CountLines(string filename) {…｝  あまり正確なコメントではない。「行」にはさまざまな意味があるからだ。コー  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(91,1,90,'74       6章コメントは正確で簡潔に\n\nナーケースを考えてみよう。\n\n●Ⅲ!ʼ（空のファイル）は、０行なのか１行なのか。\n\n●\"hello\"は、０行なのか１行なのか。\n\n●\"hello¥n\"は、１行なのか２行なのか。\n\n●\"hello¥n  world\"は、１行なのか２行なのか。\n\n●Ⅲhello¥n¥r cruel¥n worl小r\"は、２行なのか３行なのか４行なのか。\n\n最も単純な実装は、改行文字(¥nを数えるものだUnixのwcコマンドと同じ方\n\n法だ)。この実装に適したコメントがこれだ。\n\n/／このファイルに含まれる改行文字(\'¥n\')を数える《\ni\nnt CountLines(string filename) {…｝\n\n最初のコメントと比較すると、それほど長くはなっていないのに、伝わる情報は格\n段に増えている。改行文字がない場合は、Ｏを返すことがわかる。また、キャリッジ\nリターン(¥r)が無視されることもわかる。\n6.5入出力のコーナーケースに実例を使う\nʻ慎重に選んだ入出力の実例をコメントに書いておけば、それは千の言葉に等しいと\n\n言える。\n\n例えば、文字列の一部を除去する関数があるとする。\n\n//  \'src\'の先頭や末尾にある,char5ʼを除去する。\nString Strip(String src, String chars) {…】\n\nこのコメントはあまり正確ではない。以下のような質問に答えることができない力\n\nらだ。\n\n●charsは、除去する文字列なのか、順序のない文字集合なのか!\n\n●srcの末尾に複数のcharsがあったらどうなるのか？\n\n','       章コメントは正確で簡潔に  ナーケースを考えてみよう。  ●Ⅲ!ʼ空のファイルは、行なのか行なのか。  ●\"hello\"は、行なのか行なのか。  ●\"hello¥n\"は、行なのか行なのか。  ●\"hello¥n  world\"は、行なのか行なのか。  ●Ⅲhello¥n¥r cruel¥n worl小r\"は、行なのか行なのか行なのか。  最も単純な実装は、改行文字(¥nを数えるものだUnixのwcコマンドと同じ方  法だ)。この実装に適したコメントがこれだ。  /このファイルに含まれる改行文字(\'¥n\')を数える《 i nt CountLines(string filename) {…｝  最初のコメントと比較すると、それほど長くはなっていないのに、伝わる情報は格 段に増えている。改行文字がない場合は、Ｏを返すことがわかる。また、キャリッジ リターン(¥r)が無視されることもわかる。 .入出力のコーナーケースに実例を使う ʻ慎重に選んだ入出力の実例をコメントに書いておけば、それは千の言葉に等しいと  言える。  例えば、文字列の一部を除去する関数があるとする。  //  \'src\'の先頭や末尾にある,charʼを除去する。 String Strip(String src, String chars) {…】  このコメントはあまり正確ではない。以下のような質問に答えることができない力  らだ。  ●charsは、除去する文字列なのか、順序のない文字集合なのか!  ●srcの末尾に複数のcharsがあったらどうなるのか  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(92,1,91,'６５入出力のコーナーケースに実例を使うʼ７』\n\n以上の質問に答えられる適切な実例はこうだく\n\n/\n／、．．\n/／実例: Strip(\"abba/a/ba\", \"ab\")は\"/a/\"を返す\nString Strip(String src, String chars) {…｝\nこの実例は、StripQのすべての機能を「見せて」いる。上記の質問に答えられを\n\nいような簡単な実例では役に立たないので注意しよう。\n\n/／実例：Strip(ʻiabi\'，!\'a側)は\"b\"を返す\n\n実例を使った関数をもう１つ紹介しよう\n\n// Vの「要素< pivot」が「要素>= pivot」の前に来るように配置し直す。\n/／それから、「v[i] < pivot」になる最大のTを返す（なければ-1を返す)c\nint Partition(vector<int>* v, int pivot);\n\nこのコメントは実に正確だ。でも、視覚化が少し難しい。実例を使ってより詳しく\n\n説明してみよう。\n\n．\n，\n/\n／\n．\n//実例: Partition([8 5 9 8 2], 8)の結果は[521898となり、１を返す。\nint Partition(vector<int>* v, int pivot);\n\nぼくたちが選んだ実例には、大切な点がいくつかある。\n\n●pivotをベクタの要素と同じにして、エッジケースを示している〔\n\n●ベクタに重複要素（８）を入れることで、これが入力値として受け入れられ\n\nることを示している。\n\n●結果のベクタはソートしていない。ここでソートしていたら、ソートされて\n\nいるはずと読み手が誤解する可能性がある。\n\n●戻り値が１になるので、ベクタの要素に１を入れていないく\n\n','入出力のコーナーケースに実例を使うʼ』  以上の質問に答えられる適切な実例はこうだく  / 、 /実例: Strip(\"abba/a/ba\", \"ab\")は\"/a/\"を返す String Strip(String src, String chars) {…｝ この実例は、StripQのすべての機能を「見せて」いる。上記の質問に答えられを  いような簡単な実例では役に立たないので注意しよう。  /実例Strip(ʻiabi\'!\'a側)は\"b\"を返す  実例を使った関数をもうつ紹介しよう  // Vの「要素< pivot」が「要素>= pivot」の前に来るように配置し直す。 /それから、「v[i] < pivot」になる最大のTを返すなければ-を返す)c int Partition(vector<int>* v, int pivot);  このコメントは実に正確だ。でも、視覚化が少し難しい。実例を使ってより詳しく  説明してみよう。    /   //実例: Partition([    ], )の結果は[となり、を返す。 int Partition(vector<int>* v, int pivot);  ぼくたちが選んだ実例には、大切な点がいくつかある。  ●pivotをベクタの要素と同じにして、エッジケースを示している〔  ●ベクタに重複要素を入れることで、これが入力値として受け入れられ  ることを示している。  ●結果のベクタはソートしていない。ここでソートしていたら、ソートされて  いるはずと読み手が誤解する可能性がある。  ●戻り値がになるので、ベクタの要素にを入れていないく  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(93,1,92,'７６１６章コメントは正確で簡潔に\n\n6.6コードの意図を書く\n前章でも言ったけど、コメントというのはコードを書いているときに考えていたこ\nとを読み手に伝えるためのものだ。でも、コードの動作をそのまま書いているだけ\nで、何も情報を追加していないコメントが多い。\n\nそんなコメントを見てみよう。\n\nvoid DisplayProducts(list<Product> products) {\n\nproducts.sort(CompareProductByPrice);\n\n//  listを逆順にイテレートする\nfor (list<Product>::reverse_iterator it = products.rbeginQ; it != products.rendO:\n\n++it)\nDisplayPrice(it->price);\n\nのコメントは直下のコードをそのまま説明しているだけだ。もっといいコメント\n\nʻ． こ\n\nｅ ● （\n\nを考えてみよう。\n\n/／値段の高い順に表示する\nfor (list<Product>::reverse_iterator it = products.rbeginQ;…）\n\nこのコメントは、プログラムの動作を高レベルから説明している。プログラマか\n\nコードを書いたときに考えていたことに近い。\n\nところで、このプログラムにはバグがある! CompareProductByPrice関数（ここ\nには書いていない）が、すでに値段の高い順にソートしているのだ。したがって、こ\nのコードは作者の意図に反したものになっている。\n\nこのことはつまり、２番めのコメントのほうが優れているということだ。最初のコ\nメントは、バグのことはさておき、技術的には正しい（逆順にイテレートする)。で\nも、作者の意図（値段の高い順に表示する）が、実際のコードと矛盾していることに\n気づきやすいのは、２番めのコメントのほうである。ここではコメントが冗長検査の\n役割を果たしているわけだ。\n\n究極的には、ユニットテストが最高の冗長検査になるだろう（｢１４章テストと読\nみやすさ」参照)。だからといって、プログラムの意図を説明するコメントをつける\n\n','章コメントは正確で簡潔に  .コードの意図を書く 前章でも言ったけど、コメントというのはコードを書いているときに考えていたこ とを読み手に伝えるためのものだ。でも、コードの動作をそのまま書いているだけ で、何も情報を追加していないコメントが多い。  そんなコメントを見てみよう。  void DisplayProducts(list<Product> products) {  products.sort(CompareProductByPrice);  //  listを逆順にイテレートする for (list<Product>::reverse_iterator it = products.rbeginQ; it != products.rendO:  ++it) DisplayPrice(it->price);  のコメントは直下のコードをそのまま説明しているだけだ。もっといいコメント  ʻ こ  ｅ ●   を考えてみよう。  /値段の高い順に表示する for (list<Product>::reverse_iterator it = products.rbeginQ;…  このコメントは、プログラムの動作を高レベルから説明している。プログラマか  コードを書いたときに考えていたことに近い。  ところで、このプログラムにはバグがある! CompareProductByPrice関数ここ には書いていないが、すでに値段の高い順にソートしているのだ。したがって、こ のコードは作者の意図に反したものになっている。  このことはつまり、番めのコメントのほうが優れているということだ。最初のコ メントは、バグのことはさておき、技術的には正しい逆順にイテレートする)。で も、作者の意図値段の高い順に表示するが、実際のコードと矛盾していることに 気づきやすいのは、番めのコメントのほうである。ここではコメントが冗長検査の 役割を果たしているわけだ。  究極的には、ユニットテストが最高の冗長検査になるだろう｢章テストと読 みやすさ」参照)。だからといって、プログラムの意図を説明するコメントをつける  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(94,1,93,'６７「名前付き引数」コメントʼ７７\n\nのが無駄になるわけではない。\n\n6.7『名前付き引数」コメント\n以下のような関数呼び出しを目にしたとしよう。\n\nConnect(10, false);\n\n数値とブール値が渡されているけど、何のことだかよくわからない。\nPythonのような言語であれば、引数を名前付きで渡せる。\n\ndef Connect(timeout, use encryption): ...\n\n＃名前付き引数で関数を呼び出す\nConnect(timeout = 10, use encryption = False)\n\nこれはC++  ^  Javaのような言語ではできない。でも、インラインコメントを使え\n\nば同じような効果が得られる。\n\nvoid Connect(int timeout, bool use encryption) {…｝\n\n/／引数にコメントをつけて関数を呼び出す\nConnect(/* timeout ms = */ 10, /* use encryption = */ false);\n\n最初の「名前」がtimeoutではなく、timeout  msになっていることに注意して欲\nしい。本来であれば、仮引数の名前をtimeout  msにすべきだけど、何らかの理由で\n変更できないのであれば、このようにして手っ取り早く名前を「改善」できる。\n\n特にブール型の引数では、値の前に/*  name  =  */を置くのが大切だ。値の後ろに\n\nあるとまぎらわしい。\n\n/／これはやってはいけない！\nConnect(…, false /* use encryption */);\n\n/／これもやってはいけない！\nConnect(…, false /* = use encryption */);\n\nこれでは、falseが「暗号化する」のか「暗号化しない」のかよくわからない。\nこのようなコメントは必要ないことが多い。でも、よくわからない引数を説明する\n\n','「名前付き引数」コメントʼ  のが無駄になるわけではない。  .『名前付き引数」コメント 以下のような関数呼び出しを目にしたとしよう。  Connect(, false);  数値とブール値が渡されているけど、何のことだかよくわからない。 Pythonのような言語であれば、引数を名前付きで渡せる。  def Connect(timeout, use encryption): ...  名前付き引数で関数を呼び出す Connect(timeout = , use encryption = False)  これはC++  ^  Javaのような言語ではできない。でも、インラインコメントを使え  ば同じような効果が得られる。  void Connect(int timeout, bool use encryption) {…｝  /引数にコメントをつけて関数を呼び出す Connect(/* timeout ms = */ , /* use encryption = */ false);  最初の「名前」がtimeoutではなく、timeout  msになっていることに注意して欲 しい。本来であれば、仮引数の名前をtimeout  msにすべきだけど、何らかの理由で 変更できないのであれば、このようにして手っ取り早く名前を「改善」できる。  特にブール型の引数では、値の前に/*  name  =  */を置くのが大切だ。値の後ろに  あるとまぎらわしい。  /これはやってはいけない Connect(…, false /* use encryption */);  /これもやってはいけない Connect(…, false /* = use encryption */);  これでは、falseが「暗号化する」のか「暗号化しない」のかよくわからない。 このようなコメントは必要ないことが多い。でも、よくわからない引数を説明する  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(95,1,94,'７８１６章コメントは正確で簡潔に\n\nときには、こうするのが手っ取り早い（し簡潔である)〈\n\n6.8情報密度の高い言葉を使う\nプログラミングの経験が何年かあれば、同じ問題や解決策が何度も繰り返し登場す\nることに気づいていると思う。こうしたパターンやイディオムを説明するための言葉\nや表現がある。このような言葉を使えば、コメントをもっと簡潔にできる。\n\n例えば、以下のようなコメントがあったとしよう。\n\nこのクラスには大量のメンバがある。同じ\'情報はデータベースにも保管されている。ただし、\n速度の面からここにも保管しておく。このクラスを読み込むときには、メンバが存在してい\nるかどうかを先に確認する。もし存在していれば､そのまま返す。存在しなければ､データベー\nスから読み込んで、次回のためにデータをフィールドに保管する。\n\nうではなく、以下のように書けばいい。\n\nノ/ノ /ノ/ノ こ\n\n/\n\n/／このクラスの役割は、データベースのキャッシュ層である。\n\n他にも以下のようなコメントは\n\n/／所在地から余分な空白を除去する。それから「Avenue」を「Ave.」にするなどの整形を施す\n/／こうすれば、表記がわずかに違う所在地でも同じものであると判別できる。\n\n以下のようにできる\n\n/／所在地を正規化する（例: \"Avenue\" -> \"Ave.\"\n\nこのように多くの意味を含んだ言葉や表現が数多く存在する。例えば、「ヒュー\'ノ\nステイック」・「ブルートフオース」・「ナイーブソリューション」などがそうだ。コン\nントが長くてくどいと感じたら、こうした表現を使えないか確かめよう。\n\n6 . 9 ま と め\n本章では、小さな領域にできるだけ多くの情報を詰め込んだコメントを書くことに\n\nついて説明した。具体的なヒントを以下に挙げる。\n\n●複数のものを指す可能性がある「それ」や「これ」などの代名詞を避ける。\n\n','章コメントは正確で簡潔に  ときには、こうするのが手っ取り早いし簡潔である)〈  .情報密度の高い言葉を使う プログラミングの経験が何年かあれば、同じ問題や解決策が何度も繰り返し登場す ることに気づいていると思う。こうしたパターンやイディオムを説明するための言葉 や表現がある。このような言葉を使えば、コメントをもっと簡潔にできる。  例えば、以下のようなコメントがあったとしよう。  このクラスには大量のメンバがある。同じ\'情報はデータベースにも保管されている。ただし、 速度の面からここにも保管しておく。このクラスを読み込むときには、メンバが存在してい るかどうかを先に確認する。もし存在していれば､そのまま返す。存在しなければ､データベー スから読み込んで、次回のためにデータをフィールドに保管する。  うではなく、以下のように書けばいい。  ノ/ノ /ノ/ノ こ  /  /このクラスの役割は、データベースのキャッシュ層である。  他にも以下のようなコメントは  /所在地から余分な空白を除去する。それから「Avenue」を「Ave.」にするなどの整形を施す /こうすれば、表記がわずかに違う所在地でも同じものであると判別できる。  以下のようにできる  /所在地を正規化する例: \"Avenue\" -> \"Ave.\"  このように多くの意味を含んだ言葉や表現が数多く存在する。例えば、「ヒュー\'ノ ステイック」・「ブルートフオース」・「ナイーブソリューション」などがそうだ。コン ントが長くてくどいと感じたら、こうした表現を使えないか確かめよう。   .  ま と め 本章では、小さな領域にできるだけ多くの情報を詰め込んだコメントを書くことに  ついて説明した。具体的なヒントを以下に挙げる。  ●複数のものを指す可能性がある「それ」や「これ」などの代名詞を避ける。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(96,1,95,'6 . 9 ま と め ʼ ７ ９\n\n●関数の動作はできるだけ正確に説明する。\n\n●コメントに含める入出力の実例を慎重に選ぶ。\n\n●コードの意図は、詳細レベルではなく、高レベルで記述する。\n●よくわからない引数にはインラインコメントを使う（例: Function(/* ari\n\n＝＊／…）)。\n\n●多くの意味が詰め込まれた言葉や表現を使って、コメントを簡潔に保つ〈\n\n',' .  ま と め ʼ    ●関数の動作はできるだけ正確に説明する。  ●コメントに含める入出力の実例を慎重に選ぶ。  ●コードの意図は、詳細レベルではなく、高レベルで記述する。 ●よくわからない引数にはインラインコメントを使う例: Function(/* ari  …)。  ●多くの意味が詰め込まれた言葉や表現を使って、コメントを簡潔に保つ〈  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(97,1,96,'蕊寵(cid:7767)\nループとロジックの単純化\n\n第１部では、表面上の改善について説明した。これはコードの読みやすさを１行\nずつ改善する単純な方法であり、大きなリスクや労力をかけずに適用できるものであ\n。\nる\n第Ⅱ部では、もっと深いところに進んで、プログラムの「ループとロジック」のこ\nとを説明したいと思う。これはコードを動かすための制御フロー・論理式・変数など\nのことだ。これまで同様、ぼくたちの目標は、君のコードを理解しやすくすることで\nある。\n\nそのために君のコードの「精神的な荷物」を減らしたいと思っている。複雑なルー\nプ・巨大な式・膨大な変数を見ると、真剣に考えて記憶しなければいけないので、頭\nのなかに「精神的な荷物」が増えてしまう。これは「理解しやすい」と正反対のこと\nだ。コードに「精神的な荷物」がたくさんあると、バグは見つからなくなるし、コー\nドは変更しにくくなるし、何よりコードに触れるのが楽しくなくなる。\n\n','蕊寵(cid:) ループとロジックの単純化  第部では、表面上の改善について説明した。これはコードの読みやすさを行 ずつ改善する単純な方法であり、大きなリスクや労力をかけずに適用できるものであ 。 る 第Ⅱ部では、もっと深いところに進んで、プログラムの「ループとロジック」のこ とを説明したいと思う。これはコードを動かすための制御フロー・論理式・変数など のことだ。これまで同様、ぼくたちの目標は、君のコードを理解しやすくすることで ある。  そのために君のコードの「精神的な荷物」を減らしたいと思っている。複雑なルー プ・巨大な式・膨大な変数を見ると、真剣に考えて記憶しなければいけないので、頭 のなかに「精神的な荷物」が増えてしまう。これは「理解しやすい」と正反対のこと だ。コードに「精神的な荷物」がたくさんあると、バグは見つからなくなるし、コー ドは変更しにくくなるし、何よりコードに触れるのが楽しくなくなる。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(98,1,97,'ʼ８３\n\nア章\n制御フローを読みやすくする\n\nおい１\n\nエサが見つかったぞ！\n\nオレもだ！\n\nゆ ●\n\n寿愉\n・(cid:7761)\n\n０\n\nＰ\n\n','ʼ  ア章 制御フローを読みやすくする  おい  エサが見つかったぞ  オレもだ  ゆ ●  寿愉 ・(cid:)    Ｐ  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(99,1,98,'８４１７章制御フローを読みやすくする\n\n条件やループなどの制御フローがないコードは読みやすい。他の場所に飛んだり枝\n分かれしたりするのは複雑なので、コードがすぐにわかりにくくなってしまう。本章\nでは、コードの制御フローを読みやすくすることについて説lﾘＩする。\n\n(cid:20276) と な る 考 え\n条件やループなどの制御フローはできるだけ「自然」にする。コードの読み手が立ち止まっ\nたり読み返したりしないように書く。\n\n7.1条件式の引数の並び順\n以下の２つのコードはどちらが読みやすいだろうかｃ\n\ni\nf (length >= 10)\n\nま た は\n\ni\nf (10 <= length)\n\nほとんどのプログラマは妓初のほうが読みやすいと言うだろう。それでは、以下の\n\n2つならどうだろうか。\n\nwhile (bytes received < bytes expected)\n\nま た は\n\nwhile fbvtes exoected > bvtes received)\n\n､\n\nノ\n\nー\n\nｌ\n\nＪ\n\n一\n\nʼ\n\nこれも雌初のほうが読みやすい。それはなぜだろう？どんな原則があるのだろ\nう？ａ〈ｂとb  >  aのどちらが読みやすいかなんて、どうやって決めるのだろう？\n\nぼくたちが便利に使っている指針を教えよう。\n\n(cid:20273)(cid:7637)釧\n\n右側\n\n｢洲盗対象」の式。変化する。｜「比(cid:20280)対象」の式。あまり変化しない。\n\n窯慰i:;\n\nこの指針は英語の用法と合っている。英語で「もし君が１年間で10万ドル以上稼\n\n','章制御フローを読みやすくする  条件やループなどの制御フローがないコードは読みやすい。他の場所に飛んだり枝 分かれしたりするのは複雑なので、コードがすぐにわかりにくくなってしまう。本章 では、コードの制御フローを読みやすくすることについて説lﾘＩする。  (cid:) と な る 考 え 条件やループなどの制御フローはできるだけ「自然」にする。コードの読み手が立ち止まっ たり読み返したりしないように書く。  .条件式の引数の並び順 以下のつのコードはどちらが読みやすいだろうかｃ  i f (length >= )  ま た は  i f ( <= length)  ほとんどのプログラマは妓初のほうが読みやすいと言うだろう。それでは、以下の  つならどうだろうか。  while (bytes received < bytes expected)  ま た は  while fbvtes exoected > bvtes received)  ､  ノ  ー  ｌ  Ｊ  一  ʼ  これも雌初のほうが読みやすい。それはなぜだろうどんな原則があるのだろ うａ〈ｂとb  >  aのどちらが読みやすいかなんて、どうやって決めるのだろう  ぼくたちが便利に使っている指針を教えよう。  (cid:)(cid:)釧  右側  ｢洲盗対象」の式。変化する。｜「比(cid:)対象」の式。あまり変化しない。  窯慰i:;  この指針は英語の用法と合っている。英語で「もし君が年間で万ドル以上稼  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(100,1,99,'7.1条件式の引数の並び順ʼ８５\n\nげるならば」や「もし君が１８歳以_上ならば」と言うのは自然だ。でも、「もし１８年\nが君の年齢以下ならば」と言うのは不自然だ。\n\nwhile (bytes_received < bytes_expected)が自然なのもこのためだ。bytes\nreceivedは調査対象の値なので、ループを実行するたびに増えていく。bytes\nexpectedは比較対象の値なので、より「安定」したものである。\n\n今も「ヨーダ記法」は便利なの？\n\nプログラミング言語のなかには、ifの条件部分で代入できるものがある（例えば、Ｃや\n\nC++などがそうだ。Javaではできない)。\n\nif (obj = NULL) ...\n\nこれは以下のことを意図したバグであることが多い。\n\nif (obj == NULL) ...\n\nこのようなバグを防ぐために、引数の並び順を変えるプログラマもいる。\n\nif (NULL == obj) ...\n\nこうすれば、＝=を間違えて＝と書いたとしても、if (NULL = obj)がコンパイルできな\n\nいので安全だ。\n\nただし、順序を逆にするとコードが不自然で読みにくくなる（ヨーダが「Not if\nanything to say about it I have↑」と言うのと同じだ)。現代のコンパイラはif (obj\n= NULL)と書くと警告を出してくれる。したがって、「ヨーダ記法」は過去のものになりつ\nつあると言えるだろう。\n\n.↑訳注パルパティーンとの会話に登場するセリフ。「今日でジェダイは死に絶える」「さてどうかのう。そ\n\nう決めつけるのはまだ･･…．早い」\n\n','.条件式の引数の並び順ʼ  げるならば」や「もし君が歳以_上ならば」と言うのは自然だ。でも、「もし年 が君の年齢以下ならば」と言うのは不自然だ。  while (bytes_received < bytes_expected)が自然なのもこのためだ。bytes receivedは調査対象の値なので、ループを実行するたびに増えていく。bytes expectedは比較対象の値なので、より「安定」したものである。  今も「ヨーダ記法」は便利なの  プログラミング言語のなかには、ifの条件部分で代入できるものがある例えば、Ｃや  C++などがそうだ。Javaではできない)。  if (obj = NULL) ...  これは以下のことを意図したバグであることが多い。  if (obj == NULL) ...  このようなバグを防ぐために、引数の並び順を変えるプログラマもいる。  if (NULL == obj) ...  こうすれば、=を間違えてと書いたとしても、if (NULL = obj)がコンパイルできな  いので安全だ。  ただし、順序を逆にするとコードが不自然で読みにくくなるヨーダが「Not if anything to say about it I have↑」と言うのと同じだ)。現代のコンパイラはif (obj = NULL)と書くと警告を出してくれる。したがって、「ヨーダ記法」は過去のものになりつ つあると言えるだろう。  .↑訳注パルパティーンとの会話に登場するセリフ。「今日でジェダイは死に絶える」「さてどうかのう。そ  う決めつけるのはまだ･･…早い」  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(101,1,100,'８６１７章制御フローを読みやすくする\n\n7.2   if/elseブロックの並び順\nﾖL園圃、\n\n三分のヘツ卜紹ノ\n\n〃 印\n\nif/else文のブロックは、並び順を自由に変えることができる。例えば、以下のよ\nうに書くのと、\n\nif (a == b) {\n\n／／第１のケース\n\n} else {\n\n／／第２のケース\n\nif (a != b) {\n\n／／第２のケース\n\n} else {\n\n／／第１のケース\n\nれまであまり深く考えなかったかもしれないけど、この並び順には優劣があるく\n\n下のように書くのは同じことだ。\n\n｝ 以\n\n｝ こ\n\n','章制御フローを読みやすくする  .   if/elseブロックの並び順 ﾖL園圃、  三分のヘツ卜紹ノ  〃 印  if/else文のブロックは、並び順を自由に変えることができる。例えば、以下のよ うに書くのと、  if (a == b) {  第のケース  } else {  第のケース  if (a != b) {  第のケース  } else {  第のケース  れまであまり深く考えなかったかもしれないけど、この並び順には優劣があるく  下のように書くのは同じことだ。  ｝ 以  ｝ こ  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(102,1,101,'7.2     if/elseブロックの並び順87\n\n●条件は否定形よりも肯定形を使う。例えば､if  (!debug)ではなく、if\n\n(debug)を使う。\n\n●単純な条件を先に書く。ifとelseが同じ画面に表示されるので見やすい。\n●関心を引く条件や目立つ条件を先に書く。\n\nこの優劣は衝突することもあるので、そのときは自分で判断しなければいけない。\n\nでも、優先度は明確に決まることが多い。\n\n例えば､URLにクエリパラメータexpand  allが含まれているかどうかを判断して、\n\nreponseを構築するウェブサーバがあるとしよう。\n\ni\nf (!url・HasQueryParameter(\"expandjll\")) {\n\nresponse.Render(items);\n\n} else\n\n｝\n\nfor (int i = 0; i < items.sizeQ; i++) {\n\ni\ntems[i].Expand();\n\n初の行を見ると、expand_allのことが頭に浮かんでしまう。「ピンクの象のこ\nとを考えないように」と言われても、ピンクの象のことを考えてしまうのと同じだ。\n｢ピンクの象」という独特な言葉が「考えないように」を吹き飛ばしてしまうのだ。\n\n｝ 最\n\nここではexpand_allがピンクの象だ。関心を引く条件なので（それに肯定形なの\n\nで)、これを先に処理しよう。\n\ni\nf (url.HasOueryParameter(\"expand_air\')) {\nfor (int i = 0; i < items.sizeQ; i++) {\n\nitems[i].Expand();\n\nresponse.Render(items);\n\n｝ ●\n\n● ●\n\n} else {\n\n● ● ●\n\n｝\n\n','.     if/elseブロックの並び順  ●条件は否定形よりも肯定形を使う。例えば､if  (!debug)ではなく、if  (debug)を使う。  ●単純な条件を先に書く。ifとelseが同じ画面に表示されるので見やすい。 ●関心を引く条件や目立つ条件を先に書く。  この優劣は衝突することもあるので、そのときは自分で判断しなければいけない。  でも、優先度は明確に決まることが多い。  例えば､URLにクエリパラメータexpand  allが含まれているかどうかを判断して、  reponseを構築するウェブサーバがあるとしよう。  i f (!url・HasQueryParameter(\"expandjll\")) {  response.Render(items);  } else  ｝  for (int i = ; i < items.sizeQ; i++) {  i tems[i].Expand();  初の行を見ると、expand_allのことが頭に浮かんでしまう。「ピンクの象のこ とを考えないように」と言われても、ピンクの象のことを考えてしまうのと同じだ。 ｢ピンクの象」という独特な言葉が「考えないように」を吹き飛ばしてしまうのだ。  ｝ 最  ここではexpand_allがピンクの象だ。関心を引く条件なのでそれに肯定形なの  で)、これを先に処理しよう。  i f (url.HasOueryParameter(\"expand_air\')) { for (int i = ; i < items.sizeQ; i++) {  items[i].Expand();  response.Render(items);  ｝ ●  ● ●  } else {  ● ● ●  ｝  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(103,1,102,'８８１７章制御フローを読みやすくする\n\n否定形の条件であっても、単純で関心や注意を引く場合もある。そういうときは、\n\nそれを先に処理しよう。\n\n＃エラーをログに記録する\n\nif  not  ﬁle:\n\nelse:\n．\n＃\n．\n．\n\n状況によって判断基準は変わってくるのだ。\nまとめると、ここで挙げたようなことに注意して欲しい。if/elseがおかしな順番\n\nにならないように気を付けよう。\n\n７ ． ３ 三 項 演 算 子\nＣ言語などでは、条件？ａ：ｂという条件式が書ける。これは、if (条件{a\n} else { b }を簡潔に書いたものだ。\n読みやすさの点から言うと、これには議論の余地がある。支持者は、複数行が１\n行にまとまるのでいいと言う。反対者は、読みにくいしデバッガでステップ実行する\nのが難しいと言う。\n三項演算子が読みやすくて簡潔な例を挙げよう。\n\nt\ni\nmestr+＝（hour>＝１２）？〃pmi\'：\'\'a､\'!；\n\n■■■■\n\n三項演算子を使わないと以下のようになる。\n\nくて冗長な感じがする。この場合は、三項演算子のほうが読みやすいだろう。\n\nでも、以下の式だと読みにくい。\n\nreturnexponent＞＝０？mantissa＊（１<〈exponent）：mantissa／（１〈〈-exponent)；\n\nこれは、単純な２つの値から１つを選ぶようなものではない。それなのにこんな\n\n｝ 長\n\nif (hour >= 12) {\n\nt\ni\nme_str += \"pm\";\n\n} else {\n\nt\ni\nme str += \"am\":\n\n','章制御フローを読みやすくする  否定形の条件であっても、単純で関心や注意を引く場合もある。そういうときは、  それを先に処理しよう。  エラーをログに記録する  if  not  ﬁle:  else:      状況によって判断基準は変わってくるのだ。 まとめると、ここで挙げたようなことに注意して欲しい。if/elseがおかしな順番  にならないように気を付けよう。     三 項 演 算 子 Ｃ言語などでは、条件ａｂという条件式が書ける。これは、if (条件{a } else { b }を簡潔に書いたものだ。 読みやすさの点から言うと、これには議論の余地がある。支持者は、複数行が 行にまとまるのでいいと言う。反対者は、読みにくいしデバッガでステップ実行する のが難しいと言う。 三項演算子が読みやすくて簡潔な例を挙げよう。  t i mestr+hour>〃pmi\'\'\'a､\'!  ■■■■  三項演算子を使わないと以下のようになる。  くて冗長な感じがする。この場合は、三項演算子のほうが読みやすいだろう。  でも、以下の式だと読みにくい。  returnexponentmantissa<〈exponentmantissa〈〈-exponent)  これは、単純なつの値からつを選ぶようなものではない。それなのにこんな  ｝ 長  if (hour >= ) {  t i me_str += \"pm\";  } else {  t i me str += \"am\":  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(104,1,103,'7.4   do/whileループを避ける8９\n\nコードを書くというのは、「何でも１行に収めたい」と思っているからだ。\n\n(cid:20276)となる考え\n行数を短くするよりも、他の人が理解するのにかかる時間を短くするく\n\n下手に省略せずにきちんとif/else文を使えば、コードがより自然になる。\n\ni\nf (exponent >= 0) {\n\nreturn mantissa * (l  exponent);\nreturn mantissa / (l  -exponent);\n\n} else {\n｝\n\nア ド バ イ ス\n基本的にはif/elseを使おう。三項演算子はそれによって簡潔になるときにだけ使おう。\n\n７．4  do/whileループを避ける\n\nPerlなどの評判のいいプログラミング言語には、do {式} while (条件）ループ\n\nがある。式の部分は最低１回は実行される。以下に例を挙げよう。\n\n','.   do/whileループを避ける  コードを書くというのは、「何でも行に収めたい」と思っているからだ。  (cid:)となる考え 行数を短くするよりも、他の人が理解するのにかかる時間を短くするく  下手に省略せずにきちんとif/else文を使えば、コードがより自然になる。  i f (exponent >= ) {  return mantissa * (l  exponent); return mantissa / (l  -exponent);  } else { ｝  ア ド バ イ ス 基本的にはif/elseを使おう。三項演算子はそれによって簡潔になるときにだけ使おう。    do/whileループを避ける  Perlなどの評判のいいプログラミング言語には、do {式} while (条件ループ  がある。式の部分は最低回は実行される。以下に例を挙げよう。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(105,1,104,'９０１７章制御フローを読みやすくする\n\n//   name\'に合致するものを\'node\'のリストから探索する。\n// \'max length\'を超えたノードは考えない。\npublic boolean ListHasNode(Node node, String name, int max_length) ¥\n\ndo {\n\ni\nf (node・name().equals(name))\n\nreturn true;\n\nnode = node.next();\n\n} while (node != null && -max_length > 0);\n\nreturn false;\n\ndo/whileループが変わっているのは、コードブロックを再実行する条件が下にあ\nることだ。if文・while文・for文などの条件は、コードブロックの上にある。コー\nドは上から下に読んでいくので、do/whileは少し不自然だ。コードを２回読むこと\nになってしまう。\n\nwhileループにすれば、コードブロックを読む前に繰り返しの条件がわかるので、\n読みやすくなる。でも、コードを重複させてまでdo/whileを削除するのはバカらし\nい。\n\n/／擬似do/while  (やってはダメ!)\n本体\n\nwhile (condition) -\n\n本体（2度め）\n\no/whileループは、whileループで書き直せることが多いく\n\npublic boolean ListHasNode(Node node, String name, int max_length)\n\nwhile (node != null && max length- > o) {\n\ni\nf (node.name().equals(name)) return true;\nnode = node.nextQ;\n\neturn false;\n\n｝r\n\n｝ d\n\n｝\n\n','章制御フローを読みやすくする  //   name\'に合致するものを\'node\'のリストから探索する。 // \'max length\'を超えたノードは考えない。 public boolean ListHasNode(Node node, String name, int max_length) ¥  do {  i f (node・name().equals(name))  return true;  node = node.next();  } while (node != null && -max_length > );  return false;  do/whileループが変わっているのは、コードブロックを再実行する条件が下にあ ることだ。if文・while文・for文などの条件は、コードブロックの上にある。コー ドは上から下に読んでいくので、do/whileは少し不自然だ。コードを回読むこと になってしまう。  whileループにすれば、コードブロックを読む前に繰り返しの条件がわかるので、 読みやすくなる。でも、コードを重複させてまでdo/whileを削除するのはバカらし い。  /擬似do/while  (やってはダメ!) 本体  while (condition) -  本体度め  o/whileループは、whileループで書き直せることが多いく  public boolean ListHasNode(Node node, String name, int max_length)  while (node != null && max length- > o) {  i f (node.name().equals(name)) return true; node = node.nextQ;  eturn false;  ｝r  ｝ d  ｝  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(106,1,105,'７５関数から早く返すʼ９１\n\nこうすれば、max lengthが０でも、nodeがnullでも動くようになる。\ndo/whileを避ける理由は他にもある。それは、内部にあるcontinue文がまぎらわ\n\nしいからだ。例えば、以下のコードは何をしているのだろう？\n\nループは永久に続くのだろうか？それとも１回だけなのだろうか？多くのプ\n\nログラマは、立ち止まって考えることになる（答えは、ループは１回だけになる)。\n\nビャーネ・ストロヴストルップ(C++の作者）は、著書『C++  Programming\n\nLanguage ^Jでこう言っている。\n\n私の経験では、do-statementは、エラーや混乱の原因になることが多い。（中\n略）私は条件が「前もって」書かれている方が好きだ。そのため、私はdo-\nstatementを避けることが多い。\n\n了.５関数から早く返す\n関数で複数のreturn文を使ってはいけないと思っている人がいる。アホくさ。関\n\n数から早く返すのはいいことだ。むしろ望ましいときもある。例えば、\n\npublic\ni f\ni f\n\nboolean Contains(String str, String substr) {\n(str == null || substr == null) return false;\n(substr.equals(\"\")) return true;\n\n関数の出口を１つにしたいというのは、何らかのクリーンアップコードを確実に\n実行したいからだろう。現代の言語では、こうした仕組みがより洗練された形で提供\nされている。\n\nのような「ガード節」を使わずに実装するとすごく不自然な実装になる。\n\n｝ こ\n\n↑訳注『プログラミング言語Ｃ+＋第３版』(Biarne  Stroustrup著、長尾向弘訳、アジソンウエスレイパブ\n\nリッシヤーズジヤパン)、p.178\n\ndo {\n\ncontinue;\n\n} while (false);\n\n','関数から早く返すʼ  こうすれば、max lengthがでも、nodeがnullでも動くようになる。 do/whileを避ける理由は他にもある。それは、内部にあるcontinue文がまぎらわ  しいからだ。例えば、以下のコードは何をしているのだろう  ループは永久に続くのだろうかそれとも回だけなのだろうか多くのプ  ログラマは、立ち止まって考えることになる答えは、ループは回だけになる)。  ビャーネ・ストロヴストルップ(C++の作者は、著書『C++  Programming  Language ^Jでこう言っている。  私の経験では、do-statementは、エラーや混乱の原因になることが多い。中 略私は条件が「前もって」書かれている方が好きだ。そのため、私はdo- statementを避けることが多い。  了.関数から早く返す 関数で複数のreturn文を使ってはいけないと思っている人がいる。アホくさ。関  数から早く返すのはいいことだ。むしろ望ましいときもある。例えば、  public i f i f  boolean Contains(String str, String substr) { (str == null || substr == null) return false; (substr.equals(\"\")) return true;  関数の出口をつにしたいというのは、何らかのクリーンアップコードを確実に 実行したいからだろう。現代の言語では、こうした仕組みがより洗練された形で提供 されている。  のような「ガード節」を使わずに実装するとすごく不自然な実装になる。  ｝ こ  ↑訳注『プログラミング言語Ｃ+第版』(Biarne  Stroustrup著、長尾向弘訳、アジソンウエスレイパブ  リッシヤーズジヤパン)、p.  do {  continue;  } while (false);  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(107,1,106,'９２１７章制御フローを読みやすくする\n\n|言語汁:“\nＣ\n+\n＋\nＪａｖａ・Python\nPython\nC\n＃\n\nクリーンアップコードのイディオム\nデス|､ラクダ\nt r y … f i n a l l y\nwith\nusing\n\n純粋なＣ言語には、Ｉ孔l数の終了時に特定のコードを呼び出すI､リガー機能は存在\nしない。したがって、クリーンアップコードが大量に存在する大きな関数では、早め\nに返すのをうまくやるのは雌しいかもしれない。ただし、関数をリファクタリングし\nたり、gotoクリーンアップを仙重に使ったりするなどの方法がないわけでもない。\n\n7.6悪名高きgoto\nＣ言語以外では、gotoはほとんど必要ない。Hじことをする方法が他にあるから\nだ。gotoを使うとすぐに手に負えなくなったり、コードについていくのが難しくなっ\nたりするので、すごく評判が悪い。\n\nでも、今でもＣ言語のさまざまなプロジェクトでgotoは使われている。例えば、\nLinuxカーネルがそうだ。神への冒とくだとgotoをはねつけるよりも、gotoを使う\nべき理由を分析するほうがいいだろう。\n\n最も単純で害のないgotoというのは、関数の蝦下部に置いたexitと一緒に使うも\n\nのだ。\n\ni\nf (p == NULL) goto exit;\n\nexit3\n\nfclose(ﬁlel);\nfclose(ﬁle2):\n\nreturn\n\ngotoが唯一許されるのがこれだ。これならgotoは大した問題にならない。\nでも、gotoの飛び先が複数になると問題だ。経路が交差していたらなおさらであ\nる。特に、gotoから上に飛ぶのは本物のスパゲティコードになる。これは普通のルー\n\n','章制御フローを読みやすくする  |言語汁:“ Ｃ +  Ｊａｖａ・Python Python C   クリーンアップコードのイディオム デス|､ラクダ t r y … f i n a l l y with using  純粋なＣ言語には、Ｉ孔l数の終了時に特定のコードを呼び出すI､リガー機能は存在 しない。したがって、クリーンアップコードが大量に存在する大きな関数では、早め に返すのをうまくやるのは雌しいかもしれない。ただし、関数をリファクタリングし たり、gotoクリーンアップを仙重に使ったりするなどの方法がないわけでもない。  .悪名高きgoto Ｃ言語以外では、gotoはほとんど必要ない。Hじことをする方法が他にあるから だ。gotoを使うとすぐに手に負えなくなったり、コードについていくのが難しくなっ たりするので、すごく評判が悪い。  でも、今でもＣ言語のさまざまなプロジェクトでgotoは使われている。例えば、 Linuxカーネルがそうだ。神への冒とくだとgotoをはねつけるよりも、gotoを使う べき理由を分析するほうがいいだろう。  最も単純で害のないgotoというのは、関数の蝦下部に置いたexitと一緒に使うも  のだ。  i f (p == NULL) goto exit;  exit  fclose(ﬁlel); fclose(ﬁle):  return  gotoが唯一許されるのがこれだ。これならgotoは大した問題にならない。 でも、gotoの飛び先が複数になると問題だ。経路が交差していたらなおさらであ る。特に、gotoから上に飛ぶのは本物のスパゲティコードになる。これは普通のルー  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(108,1,107,'7.7ネストを浅くするʼ９３\n\nプに置き換え可能だ。基本的にはgotoは使わないほうがいいだろう｡\n\n７．アネストを浅くする\nネストの深いコードは理解しにくい。ネストが深くなると、読み手は「精神的ス\nタック」に条件をプッシュしなければいけない。閉じ括弧（}）を見てスタックから\nポップしようと思っても、その条件が何だったのかうまく思い出せない。\n\n以下は、比較的単純な例だ。自分がどの条件ブロックにいるのかを常に確認してい\n\nるのがわかるだろうか。\n\n最初の閉じ括弧を見つけると、「permissionjresult   != SUCCESSが終わるんだ\nな。次は、permissionjresult == SUCCESSか。でも、これはまだuser result ==\nSUCCESSの内部だな」と考える。\n\nつまり、user  resultとpermission  resultの値を常に覚えておかなければいけな\nいということだ。それに、if  {}ブロックが終了するたびに、覚えておいた値を反対\nにしなければいけない。\n\nそれから、このコードはSUCCESSとSUCCESSの否定が交互に登場しているので、\n\nもっとタチが悪い。\n\nネストが増える仕組み\n先ほどのサンプルコードを修正する前に、どうしてこうなったかについて話してお\n\nこう。最初は単純なコードだった。\n\ni\nf (user result == SUCCESS) {\n\ni\nf (permission result != SUCCESS) {\n\nreply.WriteErrors(\"error reading permissions\");\nreply. DoneQ;\nreturn;\n\n} else\n\neply.WriteErrors(\"\");\nreply.WriteErrors(user_result);\n\n｝r\n\neply. DoneQ;\n\n｝r\n\n','.ネストを浅くするʼ  プに置き換え可能だ。基本的にはgotoは使わないほうがいいだろう｡  アネストを浅くする ネストの深いコードは理解しにくい。ネストが深くなると、読み手は「精神的ス タック」に条件をプッシュしなければいけない。閉じ括弧}を見てスタックから ポップしようと思っても、その条件が何だったのかうまく思い出せない。  以下は、比較的単純な例だ。自分がどの条件ブロックにいるのかを常に確認してい  るのがわかるだろうか。  最初の閉じ括弧を見つけると、「permissionjresult   != SUCCESSが終わるんだ な。次は、permissionjresult == SUCCESSか。でも、これはまだuser result == SUCCESSの内部だな」と考える。  つまり、user  resultとpermission  resultの値を常に覚えておかなければいけな いということだ。それに、if  {}ブロックが終了するたびに、覚えておいた値を反対 にしなければいけない。  それから、このコードはSUCCESSとSUCCESSの否定が交互に登場しているので、  もっとタチが悪い。  ネストが増える仕組み 先ほどのサンプルコードを修正する前に、どうしてこうなったかについて話してお  こう。最初は単純なコードだった。  i f (user result == SUCCESS) {  i f (permission result != SUCCESS) {  reply.WriteErrors(\"error reading permissions\"); reply. DoneQ; return;  } else  eply.WriteErrors(\"\"); reply.WriteErrors(user_result);  ｝r  eply. DoneQ;  ｝r  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(109,1,108,'このコードなら完ぺきに理解できる。エラー文字列を決めてから、replyを終了し\n\nているだけだ。\n\nここに新しいコードが追加された。\n\n９４１７章制御フローを読みやすくする\n\ni\nf (user result == SUCCESS) {\n\n} else {\n\nreply・WriteErrorsf\"\');\nreply・WriteErrors(user result):\np\nl\ny・DoneQ;\n\n｝re\n\ni\nf (user result == SUCCESS) {\n\ni\nf (permission result != SUCCESS) {\n\nreply・WriteErrors(\"error reading permissions\")]\nreply・Done   :\nreturn;\n\neply.WriteErrors(\"\");\n\n｝r\n\n、 ●\n\nこの変更には納得がいく。最も簡単にコードを挿入できる場所がここだったのだ。\nこれを書いたプログラマにとって、新しく追加するコードは新鮮で「関心を引く-\nコードだった。そして、この変更の「差分」は何も間違っていない。簡潔な変更であ\n。\nる\nでも、あとで誰かがこのコードを見たときには、こうした文脈はすべて失われてし\nまう。こうして、最初に見たコードができあがっていった。これを瞬時に把握できる\nだろうか。\n\n(cid:20276)となる考え\n変更するときにはコードを新鮮な目で見る。一歩下がって全体を見る。\n\n早めに返してネストを削除する\nそれじゃあ、コードを改善していこう。ネストを削除するには「失敗ケース」をで\n\nきるだけ早めに関数から返せばいい。\n\n','このコードなら完ぺきに理解できる。エラー文字列を決めてから、replyを終了し  ているだけだ。  ここに新しいコードが追加された。  章制御フローを読みやすくする  i f (user result == SUCCESS) {  } else {  reply・WriteErrorsf\"\'); reply・WriteErrors(user result): p l y・DoneQ;  ｝re  i f (user result == SUCCESS) {  i f (permission result != SUCCESS) {  reply・WriteErrors(\"error reading permissions\")] reply・Done   : return;  eply.WriteErrors(\"\");  ｝r  、 ●  この変更には納得がいく。最も簡単にコードを挿入できる場所がここだったのだ。 これを書いたプログラマにとって、新しく追加するコードは新鮮で「関心を引く- コードだった。そして、この変更の「差分」は何も間違っていない。簡潔な変更であ 。 る でも、あとで誰かがこのコードを見たときには、こうした文脈はすべて失われてし まう。こうして、最初に見たコードができあがっていった。これを瞬時に把握できる だろうか。  (cid:)となる考え 変更するときにはコードを新鮮な目で見る。一歩下がって全体を見る。  早めに返してネストを削除する それじゃあ、コードを改善していこう。ネストを削除するには「失敗ケース」をで  きるだけ早めに関数から返せばいい。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(110,1,109,'7.7ネストを浅くするʼ９５\n\nこれでネストの深さが２レベルから１レベルになった。もっと大切なのは、精神\n的なスタックから「ポップ」する必要がなくなったことだ。すべてのifブロックは\nreturnで終わっている。\n\nループ内部のネストを削除する\n早めに返す技法はいつでも使えるわけではない。例えば、ループ内部でネストした\n\nコードを見てみよう。\n\nfor (int i = 0; i < results.sizeQ; i++) {\n\nif (results[i] != NULL) {\n\nnon null count++;\n\nif (results[i]->name != \"\") {\n\neout  \"Considering candidate…\"  endl;\n\n｝\n\n｝\n\nめに返すのと同じようなことをループ内部で行うには、continueを使う。\n\nfor (int i = 0; i < results.sizeQ; i++) {\n\nif (resultsﬁl == NULL) continue;\nnon null count++;\n\ni\nf (user result != SUCCESS) {\n\nreply.WriteErrors(user result);\nreply・DoneQ;\nreturn;\n\n \n(permission result != SUCCESS) {\nreply・WriteErrors(permission result);\nreply. DoneQ;\nreturn;\n\neply. WriteErrorsf\"\');\nr\neply・DoneQ;\n\n｝ if\n\n｝ r\n\n｝ 早\n\n','.ネストを浅くするʼ  これでネストの深さがレベルからレベルになった。もっと大切なのは、精神 的なスタックから「ポップ」する必要がなくなったことだ。すべてのifブロックは returnで終わっている。  ループ内部のネストを削除する 早めに返す技法はいつでも使えるわけではない。例えば、ループ内部でネストした  コードを見てみよう。  for (int i = ; i < results.sizeQ; i++) {  if (results[i] != NULL) {  non null count++;  if (results[i]->name != \"\") {  eout  \"Considering candidate…\"  endl;  ｝  ｝  めに返すのと同じようなことをループ内部で行うには、continueを使う。  for (int i = ; i < results.sizeQ; i++) {  if (resultsﬁl == NULL) continue; non null count++;  i f (user result != SUCCESS) {  reply.WriteErrors(user result); reply・DoneQ; return;    (permission result != SUCCESS) { reply・WriteErrors(permission result); reply. DoneQ; return;  eply. WriteErrorsf\"\'); r eply・DoneQ;  ｝ if  ｝ r  ｝ 早  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(111,1,110,'９６１７章制御フローを読みやすくする\n\nif (results[i]->name == \"\") continue;\neout  \"Considering candidate…\"  endl;\n\n｡ ● １\n\nif…)  return;が関数のガード節になるのと同じように、if  (…)  continue:\n\n文がループのガード節になっている。\n\nただし、continueはわかりにくくなることが多い。gotoと同じようにループを\n行ったり来たりするからだ。でも、このループは１つだけなので、continueが「こ\nの項目は飛ばす」意味だとすぐにわかる。\n7.8実行の流れを追えるかい？\n\nス リ ー カ ー ド モ ン テ\n\n本章では、低レベルの制御フローについて説明してきた。ループや条件などのジャ\nンプを簡単に読めるようにする方法だ。でも、プログラムの高レベルの「流れ」につ\nいても考えなくてはいけない。できることならプログラムのすべての実行パスを簡単\nに追えるようになるといい。mainQから出発して、心のなかでコードを追っていく。\n関数を次々に呼び出していく。それをプログラムが終了するまで続けるのだ。\n\nただし、プログラミング言語やライブラリには、コードを「舞台裏」で実行する構\n\n','章制御フローを読みやすくする  if (results[i]->name == \"\") continue; eout  \"Considering candidate…\"  endl;  ｡ ●   if…)  return;が関数のガード節になるのと同じように、if  (…)  continue:  文がループのガード節になっている。  ただし、continueはわかりにくくなることが多い。gotoと同じようにループを 行ったり来たりするからだ。でも、このループはつだけなので、continueが「こ の項目は飛ばす」意味だとすぐにわかる。 .実行の流れを追えるかい  ス リ ー カ ー ド モ ン テ  本章では、低レベルの制御フローについて説明してきた。ループや条件などのジャ ンプを簡単に読めるようにする方法だ。でも、プログラムの高レベルの「流れ」につ いても考えなくてはいけない。できることならプログラムのすべての実行パスを簡単 に追えるようになるといい。mainQから出発して、心のなかでコードを追っていく。 関数を次々に呼び出していく。それをプログラムが終了するまで続けるのだ。  ただし、プログラミング言語やライブラリには、コードを「舞台裏」で実行する構  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(112,1,111,'7 . 9 ま と め 9 7\n\n成要素がある。こうした構成要素を使っていると、コードを追うのが難しくなる。い\nくつか例を挙げよう。\n\n構成要素\nスレッド\nシグナル/#｣り込みハンドラ\n例外\n関数ポインタとⅢ略lkl数\n\n仮想メソッド\n\n高レベルの流れが不明瞭になる理由;;、：\nどのコードがいつ実行されるのかよくわからない。\n他のコードが実行されるI\'f能眺がある。\nいろんな関数|呼び出しが終｣\'しようとする。\nコンパイル時に判別できないので、どのコードが災行され\nるのかわからない。\nobiect.virtualMethod()は未aのサブクラスのコードをlIf\nOTI1すBI能13ｮがある。\n\nこれらの構成要素を使うことで、コードが読みやすくなったり、冗長性が低くなっ\nたりすることもある。でも、あとで剛岬しにくくなることを考えずに、調子に乗って\n使いすぎてしまうプログラマもいる。そうなると、バグを見つけるのが難しくなる。\nコード全体に,\',める割合を大きくしないことが大切だ。こうした構成要素はうま\nく使わないと、（先ほどの漫、の）スリーカードモンテのように、コードの行ﾉjを兄\n失ってしまう。\n\n7 . 9 ま と め\nコードの制撒IIフローを読みやすくするために君ができることはいくつもある。\n比較(while  (bytes  expected  >  bytes_received))を普くときには、変化す\nる値を左に、より安定した仙を右にm世する(while  (bytes  received  <  bytes\nexpected))。\n\nif/else文のブロックは適切に､iiび粋える。一般的には、肯定形・単純・II立つも\nのを先に処理する。こうした基準は仙j突することもあるけと．、衝突がなければ雅準を\n守っておこう。\n\n三項減算子（？：）・ｄｏ/whileループ・ｇｏｔｏなと奮のプログラミング枇成要素を使う\nと、コードが読みにくくなることが多い。代替となるものが必ずあるので、これらは\n使わないほうがいいだろう。\n\nネストしているとコードを追うのに集中力が必要になる。ネストが贈えるたびに\n｢スタックにプッシュ」することが期える。深いネストを避けるには「Il\'l線的」な\n\n',' .  ま と め    成要素がある。こうした構成要素を使っていると、コードを追うのが難しくなる。い くつか例を挙げよう。  構成要素 スレッド シグナル/#｣り込みハンドラ 例外 関数ポインタとⅢ略lkl数  仮想メソッド  高レベルの流れが不明瞭になる理由;;、 どのコードがいつ実行されるのかよくわからない。 他のコードが実行されるI\'f能眺がある。 いろんな関数|呼び出しが終｣\'しようとする。 コンパイル時に判別できないので、どのコードが災行され るのかわからない。 obiect.virtualMethod()は未aのサブクラスのコードをlIf OTIすBI能ｮがある。  これらの構成要素を使うことで、コードが読みやすくなったり、冗長性が低くなっ たりすることもある。でも、あとで剛岬しにくくなることを考えずに、調子に乗って 使いすぎてしまうプログラマもいる。そうなると、バグを見つけるのが難しくなる。 コード全体に,\',める割合を大きくしないことが大切だ。こうした構成要素はうま く使わないと、先ほどの漫、のスリーカードモンテのように、コードの行ﾉjを兄 失ってしまう。   .  ま と め コードの制撒IIフローを読みやすくするために君ができることはいくつもある。 比較(while  (bytes  expected  >  bytes_received))を普くときには、変化す る値を左に、より安定した仙を右にm世する(while  (bytes  received  <  bytes expected))。  if/else文のブロックは適切に､iiび粋える。一般的には、肯定形・単純・II立つも のを先に処理する。こうした基準は仙j突することもあるけと、衝突がなければ雅準を 守っておこう。  三項減算子・ｄｏ/whileループ・ｇｏｔｏなと奮のプログラミング枇成要素を使う と、コードが読みにくくなることが多い。代替となるものが必ずあるので、これらは 使わないほうがいいだろう。  ネストしているとコードを追うのに集中力が必要になる。ネストが贈えるたびに ｢スタックにプッシュ」することが期える。深いネストを避けるには「Il\'l線的」な  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(113,1,112,'98       7章制御フローを読みやすくする\n\nコードを選択する。\n早めに返してあげると、ネストを削除したりコードをクリーンにしたりできる。特\nに「ガード節」（関数の上部で単純な条件を先に処理するもの）が便利だ。\n\n','       章制御フローを読みやすくする  コードを選択する。 早めに返してあげると、ネストを削除したりコードをクリーンにしたりできる。特 に「ガード節」関数の上部で単純な条件を先に処理するものが便利だ。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(114,1,113,'ʼ９９\n\nＳ章\n巨大な式を分割する\n\n','ʼ  Ｓ章 巨大な式を分割する  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(115,1,114,'100     8章巨大な式を分割する\n\nダイオウイカは驚くほど知的な生物である。しかし、その完ぺきに近い身体の構造\nには、１つの致命的な欠点がある。ドーナツ状の脳が食道を取り囲んでいるために、\n大量の食料を一度に摂取すると脳に損傷を受けてしまうのだ。\n\nこれをコードに置き換えるとどうなるだろう？コードの「塊」が大きすぎると、\n周囲に悪影響を及ぼすことになる。最近の研究では、人間は一度に３〜４の「もの」\nしか考えられないそうだ↑。つまり、コードの式が大きくなれば、それだけ理解が難\nしくなるのである。\n\n(cid:20276)となる考え\n巨大な式は飲み込みやすい大きさに分割する。\n\n本章では、コードを飲み込みやすくするための処理や分割の方法を紹介する。\n8.1説明変数\n式を簡単に分割するには、式を表す変数を使えばいい。この変数を「説明変数」と\n\n呼ぶこともある。式の意味を説明してくれるからだ。\n\n例えば、以下のようなコードがあったとする。\n\nif line.splitQ:\')[0].stripQ == \"root\"\n\n● ● ●\n\n説明変数を使えば、以下のようになる（\n\nusername = line.split(\':\')[o].strip(\nif username == \"root\":\n\n● ● ●\n\n8 . 2 要 約 変 数\n式を説明する必要がない場合でも、式を変数に代入しておくと便利だ。大きなコー\nドの塊を小さな名前に置き換えて、管理や把握を簡単にする変数のことを要約変数と\n呼ぶ。\n\n例えば、以下のコードの式を考えてみよう。\n\nCowan, N. (2001). The magical number 4 in short-term memory: A reconsideration of mental storage\ncapacity. Behavioral and Brain Sciences, 24,97-185.\n\n','     章巨大な式を分割する  ダイオウイカは驚くほど知的な生物である。しかし、その完ぺきに近い身体の構造 には、つの致命的な欠点がある。ドーナツ状の脳が食道を取り囲んでいるために、 大量の食料を一度に摂取すると脳に損傷を受けてしまうのだ。  これをコードに置き換えるとどうなるだろうコードの「塊」が大きすぎると、 周囲に悪影響を及ぼすことになる。最近の研究では、人間は一度に〜の「もの」 しか考えられないそうだ↑。つまり、コードの式が大きくなれば、それだけ理解が難 しくなるのである。  (cid:)となる考え 巨大な式は飲み込みやすい大きさに分割する。  本章では、コードを飲み込みやすくするための処理や分割の方法を紹介する。 .説明変数 式を簡単に分割するには、式を表す変数を使えばいい。この変数を「説明変数」と  呼ぶこともある。式の意味を説明してくれるからだ。  例えば、以下のようなコードがあったとする。  if line.splitQ:\')[].stripQ == \"root\"  ● ● ●  説明変数を使えば、以下のようになる  username = line.split(\':\')[o].strip( if username == \"root\":  ● ● ●   .  要 約 変 数 式を説明する必要がない場合でも、式を変数に代入しておくと便利だ。大きなコー ドの塊を小さな名前に置き換えて、管理や把握を簡単にする変数のことを要約変数と 呼ぶ。  例えば、以下のコードの式を考えてみよう。  Cowan, N. (). The magical number  in short-term memory: A reconsideration of mental storage capacity. Behavioral and Brain Sciences, ,-.  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(116,1,115,'８３ド・モルガンの法則を使う1０1\n\ni\nf (request.user・id == document・owner id) {\n\n／／ユーザはこの文書を編集できる\n\nf (request・user.id != document.owner id) {\n\n／／文書は読み取り専用\n\n｝ ●\n\n● i\n\n｝ r\n\n｝ i\n\nequest・user･id == document・owner idはそれほど大きな式ではない。でも、変\n\n数が５つも入っているから、考えるのにちょっと時間がかかる。\n\nこのコードが言いたいのは「ユーザは文書を所持しているか？」だ。要約変数を追\n\n加すれば、この概念をもっと明確に表現できる。\n\nf\ni\nnal boolean user owns document = (request・user.id == document.owner id);\n\ni\nf (user owns document) {\n\n／／ユーザはこの文書を編集できる\n\n｝ ●\n\n、 。\n\nf (!user owns document) {\ni\n／／文書は読み取り専用\n\nf (user owns document)にしたら少しは考えやすくなった。\ndocumentを最上部に定義したことで、「この関数で参照する概念一\nとができるようになった。\n\nまた、ｕｓｅｒｏｗｎｓ\nを事前に伝えるこ\n\n■\n\n■\n\n■\n\n■\n\nー\n\n８.3ド・モルガンの法則を使う\n電気回路か論理学を学んだことがあれば、ド・モルガンの法則を覚えているかもし\n\nれない。論理式を等価な式に置き換える方法は２つある。\n\nnot (a or b or c)      \nnot (a and b and c)   \n\n(not a) and (not b) and (not c;\n(not a) or (not b) or (not c)\n\n、 〃 、 』\n\n１ ２\n\n','ド・モルガンの法則を使う  i f (request.user・id == document・owner id) {  ユーザはこの文書を編集できる  f (request・user.id != document.owner id) {  文書は読み取り専用  ｝ ●  ● i  ｝ r  ｝ i  equest・user･id == document・owner idはそれほど大きな式ではない。でも、変  数がつも入っているから、考えるのにちょっと時間がかかる。  このコードが言いたいのは「ユーザは文書を所持しているか」だ。要約変数を追  加すれば、この概念をもっと明確に表現できる。  f i nal boolean user owns document = (request・user.id == document.owner id);  i f (user owns document) {  ユーザはこの文書を編集できる  ｝ ●  、 。  f (!user owns document) { i 文書は読み取り専用  f (user owns document)にしたら少しは考えやすくなった。 documentを最上部に定義したことで、「この関数で参照する概念一 とができるようになった。  また、ｕｓｅｒｏｗｎｓ を事前に伝えるこ  ■  ■  ■  ■  ー  .ド・モルガンの法則を使う 電気回路か論理学を学んだことがあれば、ド・モルガンの法則を覚えているかもし  れない。論理式を等価な式に置き換える方法はつある。  not (a or b or c)       not (a and b and c)     (not a) and (not b) and (not c; (not a) or (not b) or (not c)  、 〃 、 』     ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(117,1,116,'10２     8章巨大な式を分割する\n\nこの法則が覚えにくいようであれば、「notを分配してand/orを反転する」（逆方\n\n向は「notをくくりだす｣）と覚えればいい。\n\nこの法則を使えば、論理式を読みやすくできる。例えば、以下のようなコードは、\n\nif (!(ﬁle_exists && !is protected)) Error(\"Sorry, could not read ﬁle.\");\n\n以下のように書き直せる。\n\nif (!ﬁle_exists || is_protected) Error(\"Sorry, could not read ﬁle.\");\n８．４短絡評価の悪用\n\nブール演算子は短絡評価を行うものが多い。例えば､if (a 11 b)のａがtrueな\nら、ｂは評価されない。この動作はすごく便利だけど、悪用すると複雑なロジックに\nなってしまう。\n\n以下は、著者のひとりが過去に書いたコードの例だ。\n\nassert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());\n\nこれは「このキーのバケツを取得する。もしバケツがnullじゃなかったら、中身\n\nが入っていないかを確認する」という意味だ。\n\nたった１行のコードだけど、しばらく立ち止まって考えなきゃいけない感じだ。\n\n以下のコードと比較してみよう。\n\nbucket = FindBucket(key);\ni\nf (bucket != NULL) assert(!bucket->IsOccupied());\n\n全く同じものだけど、こちらは２行になっている。コードは長くなったけど、ずっ\n\nと理解しやすくなった。\n\nどうして１行で書こうとしたのだろう？そのときは「オレは頭がいい」と思っ\nていたのだ。ロジックを簡潔なコードに落とし込むことに一種の喜びを感じていた。\nこの気持ちはみんなにも理解してもらえると思う。まるでパズルを解いているような\n感じだ。仕事は楽しくやりたいからね。問題は、これがコードのスピードバンプ↑に\nなっていたことだ。\n\n1．訳注車を減速させる路面の隆起のこと。ここでは、コードを読む速度を遅くさせるものという意味。\n\n','     章巨大な式を分割する  この法則が覚えにくいようであれば、「notを分配してand/orを反転する」逆方  向は「notをくくりだす｣と覚えればいい。  この法則を使えば、論理式を読みやすくできる。例えば、以下のようなコードは、  if (!(ﬁle_exists && !is protected)) Error(\"Sorry, could not read ﬁle.\");  以下のように書き直せる。  if (!ﬁle_exists || is_protected) Error(\"Sorry, could not read ﬁle.\"); 短絡評価の悪用  ブール演算子は短絡評価を行うものが多い。例えば､if (a  b)のａがtrueな ら、ｂは評価されない。この動作はすごく便利だけど、悪用すると複雑なロジックに なってしまう。  以下は、著者のひとりが過去に書いたコードの例だ。  assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());  これは「このキーのバケツを取得する。もしバケツがnullじゃなかったら、中身  が入っていないかを確認する」という意味だ。  たった行のコードだけど、しばらく立ち止まって考えなきゃいけない感じだ。  以下のコードと比較してみよう。  bucket = FindBucket(key); i f (bucket != NULL) assert(!bucket->IsOccupied());  全く同じものだけど、こちらは行になっている。コードは長くなったけど、ずっ  と理解しやすくなった。  どうして行で書こうとしたのだろうそのときは「オレは頭がいい」と思っ ていたのだ。ロジックを簡潔なコードに落とし込むことに一種の喜びを感じていた。 この気持ちはみんなにも理解してもらえると思う。まるでパズルを解いているような 感じだ。仕事は楽しくやりたいからね。問題は、これがコードのスピードバンプ↑に なっていたことだ。  訳注車を減速させる路面の隆起のこと。ここでは、コードを読む速度を遅くさせるものという意味。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(118,1,117,'８５例：複雑なロジックと格闘するʼ１０３\n\n(cid:20276)となる考え\n｢頭がいい」コードに気を付ける。あとで他の人がコードを読むときにわかりにくくなる。\n\nこれは短絡評価を避けろということだろうか？それは違う。短絡評価は簡潔に使\n\nえることも多い。例えば、こんな感じだ。\n\ni\nf (object && object->method()) ...\n\n他にも言っておきたいイディオムがある。Python・JavaScript・Ｒｕｂｙなどの言語\nでは、複数の引数のなかから１つを返す「OR」演算子が使える（値がブール値にな\nるわけではない)。例えば、以下のようなコードは、\n\nx = a     be\n\na-b・ｃのなかから最初に「真」と評価できるものを選ぶ。\n８．５例：複雑なロジックと格闘する\nRangeクラスを実装しているとしよう。\n\nstruct Range {\nint begin;\nint end;\n\n／／例えば、［0,5)は[3,8)と重なっている。\nbool OverlapsWith(Range other);\n\n下の図は、範囲の例だ。\n\n； 以\n\n}\n\n侯\n\n当\n停\n\n信\n判\n\n当\n\n１\n\n２\n\n３\n\n４\n\n６\n\n５\n\n７\n\n８\n\n９\n\n','例複雑なロジックと格闘するʼ  (cid:)となる考え ｢頭がいい」コードに気を付ける。あとで他の人がコードを読むときにわかりにくくなる。  これは短絡評価を避けろということだろうかそれは違う。短絡評価は簡潔に使  えることも多い。例えば、こんな感じだ。  i f (object && object->method()) ...  他にも言っておきたいイディオムがある。Python・JavaScript・Ｒｕｂｙなどの言語 では、複数の引数のなかからつを返す「OR」演算子が使える値がブール値にな るわけではない)。例えば、以下のようなコードは、  x = a     be  a-b・ｃのなかから最初に「真」と評価できるものを選ぶ。 例複雑なロジックと格闘する Rangeクラスを実装しているとしよう。  struct Range { int begin; int end;  例えば、［,)は[,)と重なっている。 bool OverlapsWith(Range other);  下の図は、範囲の例だ。   以  }  侯  当 停  信 判  当                    ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(119,1,118,'104 I   8章巨大な式を分割する\n\nendは仙を含まない。ここでは、A-B-Cはお互いに重なっていないけど、Ｄは\n\nすべてと重なっている。\n\nいるとしよう。\n\nいずれかの端が他の範囲と重なっているかを確認するOverlapsWithQを実装して\n\nだ２行しか書いていないけど、これからもっと増えていく。以|､-の図は、すべ\n\nてのロジックを示したものだ。\n\n場合分けや条件が多すぎて、バグを見逃しやすい。\nというわけで、もうバグがある。先のコードでは、本当は重なっていない\n\nRange[0,2)と[2,4)が重なってしまうのだ。\n\nbegin/endの値を比較するときには、<=とくの使い分けに注意しなければいけな\n\nい。この\'川題を修正したものがこちらだ。\n\nreturn (begin >= other.begin && begin < other.end) i\n\n(end > other.begin && end <= other･end);\n\nこれで正しくなったよね？いやいや、まだ他にもバグがある。begin/endが他の\n\n範|川を取り囲んでいるケースが抜けている。\n\nｊ ま\n\nｌ\n\nbool Range::OverlapsWith(Range other) {\n\n// \'begin\'または\'end\'が\'other\'のなかにあるかを確認する〃\nreturn (begin >= other.begin 8181 begin <= other.end) I\n\n(end >= other.begin && end <= other.end);\n\n',' I   章巨大な式を分割する  endは仙を含まない。ここでは、A-B-Cはお互いに重なっていないけど、Ｄは  すべてと重なっている。  いるとしよう。  いずれかの端が他の範囲と重なっているかを確認するOverlapsWithQを実装して  だ行しか書いていないけど、これからもっと増えていく。以|､-の図は、すべ  てのロジックを示したものだ。  場合分けや条件が多すぎて、バグを見逃しやすい。 というわけで、もうバグがある。先のコードでは、本当は重なっていない  Range[,)と[,)が重なってしまうのだ。  begin/endの値を比較するときには、<=とくの使い分けに注意しなければいけな  い。この\'川題を修正したものがこちらだ。  return (begin >= other.begin && begin < other.end) i  (end > other.begin && end <= other･end);  これで正しくなったよねいやいや、まだ他にもバグがある。begin/endが他の  範|川を取り囲んでいるケースが抜けている。  ｊ ま  ｌ  bool Range::OverlapsWith(Range other) {  // \'begin\'または\'end\'が\'other\'のなかにあるかを確認する〃 return (begin >= other.begin  begin <= other.end) I  (end >= other.begin && end <= other.end);  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(120,1,119,'８５例：複雑なロジックと格闘するʼ１０５\n\nこの処理を加えたコードがこちらだ。\n\nreturn (begin >= other.begin && begin < other.end) |\n\n(\nend > other.begin && end <= other.end) ||\n(\nbegin <= other・begin && end >= other.end);\n\nおっと、コードが複雑になってしまった。これでは誰もコードを読んでくれない\nし、これが絶対に正しいと自信を持って言うこともできない。それじゃあ、何をすれ\nばいいだろうか？どうすればこの巨大な式を分割できるだろうか？\n\nよ り 優 雅 な 手 法 を 見 つ け る\n\nここは立ち止まって、全く違った手法を考えてみるべきだ。最初は簡単な問題（２\nつの範囲の重なりを確認する）だったのに、驚くほど複雑なロジックのコードになっ\nてしまった。こういう場合には、もっと簡単な方法があるのだ。\n\nそんな解決策を見つけるには創造\'性が必要だ。でも、どうすればいいのだろう？\n\n｢反対」から問題を解決してみるという手がある。例えば、配列を逆順にイテレート\nしてみる。データ後ろから挿入してみる。とにかくいつもと反対のことをやってみる\nのだ。\n\nOverlapsWithQの「反対」を考えると「重ならない」になる。２つの範囲が重な\nらないのは簡単だ。２つの場合しかない。\n\n1．一方の範囲の終点が、ある範囲の始点よりも前にある場合。\n\n2．一方の範囲の始点が、ある範囲の終点よりも後にある場合。\n\nこれをコードに置き換えるのは簡単だ。\n\nbool Range::OverlapsWith(Range other) {\ni\nf (other.end <= begin) return false:\nf (other.begin >= end) return false;\ni\n\n/／一方の終点が、この始点よりも前にある\n/／一方の始点が、この終点よりも後にある\n\n度に１つずつしか比較していないので、コードがずっと単純になった。これで\n\nreturn true; //残ったものは重なっている\n\n｝ 一\n\n','例複雑なロジックと格闘するʼ  この処理を加えたコードがこちらだ。  return (begin >= other.begin && begin < other.end) |  ( end > other.begin && end <= other.end) || ( begin <= other・begin && end >= other.end);  おっと、コードが複雑になってしまった。これでは誰もコードを読んでくれない し、これが絶対に正しいと自信を持って言うこともできない。それじゃあ、何をすれ ばいいだろうかどうすればこの巨大な式を分割できるだろうか  よ り 優 雅 な 手 法 を 見 つ け る  ここは立ち止まって、全く違った手法を考えてみるべきだ。最初は簡単な問題 つの範囲の重なりを確認するだったのに、驚くほど複雑なロジックのコードになっ てしまった。こういう場合には、もっと簡単な方法があるのだ。  そんな解決策を見つけるには創造\'性が必要だ。でも、どうすればいいのだろう  ｢反対」から問題を解決してみるという手がある。例えば、配列を逆順にイテレート してみる。データ後ろから挿入してみる。とにかくいつもと反対のことをやってみる のだ。  OverlapsWithQの「反対」を考えると「重ならない」になる。つの範囲が重な らないのは簡単だ。つの場合しかない。  一方の範囲の終点が、ある範囲の始点よりも前にある場合。  一方の範囲の始点が、ある範囲の終点よりも後にある場合。  これをコードに置き換えるのは簡単だ。  bool Range::OverlapsWith(Range other) { i f (other.end <= begin) return false: f (other.begin >= end) return false; i  /一方の終点が、この始点よりも前にある /一方の始点が、この終点よりも後にある  度につずつしか比較していないので、コードがずっと単純になった。これで  return true; //残ったものは重なっている  ｝ 一  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(121,1,120,'106     8章巨大な式を分割する\n\n<＝が正しいかどうかを集中して見れるようになった。\n８．６巨大な文を分割する\n本章では、式の分割について説明している。同じ技法は文の分割にも使える。例え\n\nば、以下のJavaScriptのコードは、すぐには理解できない。\n\nれぞれの式はそれほど大きなものではないけど、それらがすべて一箇所に集まる\n\nと巨大な文となって一斉に襲いかかってくる。\n幸いなことに同じ式がいくつかあるので、それらを要約変数として関数の最上部に\n\n抽出すればいい（これはDRY原則の実例でもある)。\n\nvar updatejiighlight = function (message num) {\n\nvar thumbsjjp = $(\"#thumbs up\" + message num);\nvar thumbs_down = $(\"#thumbs_down\" + message num);\nvar vote_value = $(\"#vote value\" + message num).html();\nvar hi = \"highlighted\";\nf (votej/alue === \"Up\") {\ni\nt\nhumbs up・addClass(hi);\nt\nhumbs down.removeClass(hi);\nthumbs叩.removeClass(hi);\nt\nhumbs down・addClass(hi);\ne\nl\nse {\nt\nhumbs up・removeClass(hi);\n\n} else if (vote value === \"Down\") {\n\n｝\n\n； そ\n\n}\n\nvar update highlight = function (message num) {\n\ni\nf ($(\"#vote_value\" + message_num).html() === \"Up\") {\n\n$\n(\n\"\n#thumbs_up\" + message_num).addClass(\"highlighted\");\n$\n(\n\"\n#thumbs_down\" + message_num).removeClass(\"highlighted\");\n} else if ($(\"#vote value\" + message num).htmlQ === \"Down\") {\n$\n\"\n(\n#thumbs_up\" + message_num).removeClass(\"highlighted\");\n$(\"#thumbs_down\" + messagejium).addClass(\"highlighted\");\ne\nl\nse\n\"\n$\n#\n(\nhumbs up\" + message num).removeClass(\"highighted\");\nt\n$\n(\n\"\n#thumbs_down\" + messagejium).removeClass(\"highlighted\");\n\n','     章巨大な式を分割する  <が正しいかどうかを集中して見れるようになった。 巨大な文を分割する 本章では、式の分割について説明している。同じ技法は文の分割にも使える。例え  ば、以下のJavaScriptのコードは、すぐには理解できない。  れぞれの式はそれほど大きなものではないけど、それらがすべて一箇所に集まる  と巨大な文となって一斉に襲いかかってくる。 幸いなことに同じ式がいくつかあるので、それらを要約変数として関数の最上部に  抽出すればいいこれはDRY原則の実例でもある)。  var updatejiighlight = function (message num) {  var thumbsjjp = $(\"#thumbs up\" + message num); var thumbs_down = $(\"#thumbs_down\" + message num); var vote_value = $(\"#vote value\" + message num).html(); var hi = \"highlighted\"; f (votej/alue === \"Up\") { i t humbs up・addClass(hi); t humbs down.removeClass(hi); thumbs叩.removeClass(hi); t humbs down・addClass(hi); e l se { t humbs up・removeClass(hi);  } else if (vote value === \"Down\") {  ｝   そ  }  var update highlight = function (message num) {  i f ($(\"#vote_value\" + message_num).html() === \"Up\") {  $ ( \" #thumbs_up\" + message_num).addClass(\"highlighted\"); $ ( \" #thumbs_down\" + message_num).removeClass(\"highlighted\"); } else if ($(\"#vote value\" + message num).htmlQ === \"Down\") { $ \" ( #thumbs_up\" + message_num).removeClass(\"highlighted\"); $(\"#thumbs_down\" + messagejium).addClass(\"highlighted\"); e l se \" $ # ( humbs up\" + message num).removeClass(\"highighted\"); t $ ( \" #thumbs_down\" + messagejium).removeClass(\"highlighted\");  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(122,1,121,'８７式を簡潔にするもう１つの創造的な方法107\n\nar  hi  =  \"highlighted\"の部分は厳密には不要だ。でも、同じものが６回も登場\n\nh v\n\nしているし、こうしたほうが便利なこともある。\n\n●タイプミスを減らすのに役立つ(最初の例の５番めの文字列がmhighighted\"\n\nとスペルミスしていたことに気づいていただろうか？）。\n\n●横幅が縮まるのでコードが読みやすくなる。\n\n●クラス名を変更することになれば、一箇所を変更すればいい。\n\n８.ア式を簡潔にするもう１つの創造的な方法\n以下のコードの式も長い。今回はC++のコードである｡\n\nvoid AddStats(const Stats& add from, Stats* add to) {\n\nadd to->set total memory(add from.total memoryQ + add to->total_memoryQ);\nadd to->set free memory(add from・free memoryQ + add to->free memoryQ);\nadd to->set swap_memory(add_from.swap_memory() + add_to->swap_memory());\nadd to->set status string(add_from.status_string() + add_to->status_string());\nadd to->set num processes(add_from.num_processes() + add_to->num_processes())j\n\nthumbs down.removeClass(hi);\n\nＩ■■■\n\nの式も長くてよく似ているけれど、同じものではなさそうだ。でも、１０秒ほど\nよく見ていれば、フィールド名が違うだけで、どの式も同じことをしていることに気\nづくだろう。\n\n｝ ど\n\nadd to->set XXX(add from.XXXQ + add_to->XXX());\n\nこういうときは、C++ではマクロを定義すればいい。\n\nvoid AddStats(const Stats* add from, Stats* add to) {\n\n#deﬁne ADD FIELD(ﬁeld) add_to->set_##ﬁeld(add_from.ﬁeld() + add_to->ﬁeld())\n\n','式を簡潔にするもうつの創造的な方法  ar  hi  =  \"highlighted\"の部分は厳密には不要だ。でも、同じものが回も登場  h v  しているし、こうしたほうが便利なこともある。  ●タイプミスを減らすのに役立つ(最初の例の番めの文字列がmhighighted\"  とスペルミスしていたことに気づいていただろうか。  ●横幅が縮まるのでコードが読みやすくなる。  ●クラス名を変更することになれば、一箇所を変更すればいい。  .ア式を簡潔にするもうつの創造的な方法 以下のコードの式も長い。今回はC++のコードである｡  void AddStats(const Stats& add from, Stats* add to) {  add to->set total memory(add from.total memoryQ + add to->total_memoryQ); add to->set free memory(add from・free memoryQ + add to->free memoryQ); add to->set swap_memory(add_from.swap_memory() + add_to->swap_memory()); add to->set status string(add_from.status_string() + add_to->status_string()); add to->set num processes(add_from.num_processes() + add_to->num_processes())j  thumbs down.removeClass(hi);  Ｉ■■■  の式も長くてよく似ているけれど、同じものではなさそうだ。でも、秒ほど よく見ていれば、フィールド名が違うだけで、どの式も同じことをしていることに気 づくだろう。  ｝ ど  add to->set XXX(add from.XXXQ + add_to->XXX());  こういうときは、C++ではマクロを定義すればいい。  void AddStats(const Stats* add from, Stats* add to) {  #deﬁne ADD FIELD(ﬁeld) add_to->set_##ﬁeld(add_from.ﬁeld() + add_to->ﬁeld())  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(123,1,122,'１０8     8章巨大な式を分割する\n\nADD FIELDCtotal memory ;\nADD FIELD(free memory);\nADD FIELD(swap memory);\nADD FIELD(status string);\nADD FIELD(num processes);\n\n● ● ●\n\n#undef ADD FIELD\n\nこれですべてのゴミをはぎ取ることができた。コードを見てすぐに本質が理解でき\n\nる。それぞれの行が同じことをしているのも明確だ。\n\n何もマクロを頻繁に使えと言ってるわけじゃない。コードがわかりにくくなるし、\n見つけにくいバグが潜り込んでしまうこともある。ぼくたちはマクロを使うのを避け\nているほどだ。でも、今回のような場面では、簡潔で読みやすくなるという明確な利\n点がもたらされている。\n\n８．８まとめ\n巨大な式を一度に理解しようと思うと難しい。本章では、巨大な式を分割して、読\n\nみ手が１つずつ飲み込めるようにする方法を説明した。\n\n最も簡単な方法は「説明変数」を導入することだ。大きな式の値を保持する説明変\n\n数には、３つの利点がある。\n\n●巨大な式を分割できる。\n\n●簡潔な名前で式を説明することで、コードを文書化できる。\n\n●コードの主要な「概念」を読み手が認識しやすくなる。\n\nその他には、ド・モルガンの法則を使ってロジックを操作する方法がある。これ\nは論理式をキレイに書き直すことにも使える（例えば､if (I(a && lb))は、if   !a\n\nb)になる)。\n複雑な論理条件は「if   a < b)…」のような小さな文に分割した。本章で取り上\nげたすべての改善コードには、if文の中身が２行以上含まれていない。これは理想\n的な状況だ。同じことが常にできるとは限らない。そんなときは、問題を「否定」し\nたり、反対のことを考えてみたりすることが必要になる。\n\n','     章巨大な式を分割する  ADD FIELDCtotal memory ; ADD FIELD(free memory); ADD FIELD(swap memory); ADD FIELD(status string); ADD FIELD(num processes);  ● ● ●  #undef ADD FIELD  これですべてのゴミをはぎ取ることができた。コードを見てすぐに本質が理解でき  る。それぞれの行が同じことをしているのも明確だ。  何もマクロを頻繁に使えと言ってるわけじゃない。コードがわかりにくくなるし、 見つけにくいバグが潜り込んでしまうこともある。ぼくたちはマクロを使うのを避け ているほどだ。でも、今回のような場面では、簡潔で読みやすくなるという明確な利 点がもたらされている。  まとめ 巨大な式を一度に理解しようと思うと難しい。本章では、巨大な式を分割して、読  み手がつずつ飲み込めるようにする方法を説明した。  最も簡単な方法は「説明変数」を導入することだ。大きな式の値を保持する説明変  数には、つの利点がある。  ●巨大な式を分割できる。  ●簡潔な名前で式を説明することで、コードを文書化できる。  ●コードの主要な「概念」を読み手が認識しやすくなる。  その他には、ド・モルガンの法則を使ってロジックを操作する方法がある。これ は論理式をキレイに書き直すことにも使える例えば､if (I(a && lb))は、if   !a  b)になる)。 複雑な論理条件は「if   a < b)…」のような小さな文に分割した。本章で取り上 げたすべての改善コードには、if文の中身が行以上含まれていない。これは理想 的な状況だ。同じことが常にできるとは限らない。そんなときは、問題を「否定」し たり、反対のことを考えてみたりすることが必要になる。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(124,1,123,'8 . 8 ま と め 1 0 9\n\n最後に、本章の分割は式を対象にしたものだったけど、巨大なコードブロックにも\n\n同じ技法が使える。複雑なロジックを見かけたら、積極的に分割して欲しい。\n\n',' .  ま と め     最後に、本章の分割は式を対象にしたものだったけど、巨大なコードブロックにも  同じ技法が使える。複雑なロジックを見かけたら、積極的に分割して欲しい。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(125,1,124,'■\nロ\n■\n■\n■\n・\n\n■\n。\n■\n■\n■\nロ\n\n■\n■\n■\n■\n\nＩ 零\n\n章\n変数と読みやすさ\n\nー\n\n垂\n\n＝\n\nサ ー カ ス の 舞 台 監 督 の 家\n\n','■ ロ ■ ■ ■ ・  ■ 。 ■ ■ ■ ロ  ■ ■ ■ ■  Ｉ 零  章 変数と読みやすさ  ー  垂    サ ー カ ス の 舞 台 監 督 の 家  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(126,1,125,'１１２１９章変数と読みやすさ\n\n本章では、変数を適当に使うとプログラムが理解しにくくなるという話をしよう。\n具体的には、以下の３つの問題に取り組むことになる。\n\n1．変数が多いと変数を追跡するのが難しくなる。\n\n2．変数のスコープが大きいとスコープを把握する時間が長くなる。\n\n3．変数が頻繁に変更されると現在の値を把握するのが難しくなる。\n\nこれらの問題にどう対処するかを議論していこう。\n\n9画１変数を削除する\n「８章巨大な式を分割する」では、「説明変数」や「要約変数」を使ってコードを\n読みやすくした。なぜ読みやすくなったのかというと、変数が巨大な式を分割して、\n説明文のようになったからである。\n\n本節では、コードが読みやすくならない変数を削除する。こうした変数を削除すれ\n\nば、コードは簡潔で理解しやすいものになる。\n\nこのような不要な変数が使われている例をこれから見ていこう。\n\n役に立たない一時変数\n以下のPythonコードにある変数nowを考えてみよう。\n\nnow = datetime.datetime.nowQ\nroot message・last vieﾚj time = now\n\nこのｎｏＷを使う意味はあるだろうか？意味がない理由を以下に挙げよう。\n\n●複雑な式を分割していない。\n●より明確になっていない。datetime.datetime.now()のままでも十分に明確\n\nだ\n。\n\n●一度しか使っていないので、重複コードの削除になっていない。\n\nnowがなくても楽に理解できる。\n\n','章変数と読みやすさ  本章では、変数を適当に使うとプログラムが理解しにくくなるという話をしよう。 具体的には、以下のつの問題に取り組むことになる。  変数が多いと変数を追跡するのが難しくなる。  変数のスコープが大きいとスコープを把握する時間が長くなる。  変数が頻繁に変更されると現在の値を把握するのが難しくなる。  これらの問題にどう対処するかを議論していこう。  画変数を削除する 「章巨大な式を分割する」では、「説明変数」や「要約変数」を使ってコードを 読みやすくした。なぜ読みやすくなったのかというと、変数が巨大な式を分割して、 説明文のようになったからである。  本節では、コードが読みやすくならない変数を削除する。こうした変数を削除すれ  ば、コードは簡潔で理解しやすいものになる。  このような不要な変数が使われている例をこれから見ていこう。  役に立たない一時変数 以下のPythonコードにある変数nowを考えてみよう。  now = datetime.datetime.nowQ root message・last vieﾚj time = now  このｎｏＷを使う意味はあるだろうか意味がない理由を以下に挙げよう。  ●複雑な式を分割していない。 ●より明確になっていない。datetime.datetime.now()のままでも十分に明確  だ 。  ●一度しか使っていないので、重複コードの削除になっていない。  nowがなくても楽に理解できる。  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(127,1,126,'９１変数を削除するʼ１１３\n\nroot message・last view time = datetime・datetime. nowQ\n\nｎｏｗのような変数は、コードを編集した「残骸」だ。変数nowも最初は複数の場所\nで使われていたのだろう。あるいは、何度もｎｏｗを使おうと思っていたのに、一度し\nか使う機会がなかったのかもしれない。\n\n中間結果を削除する\n\n以下は、配列から値を削除するJavaScriptの関数の例だ。\n\n数index  to  removeは、中間結果を保持するためだけに使っている。結果をそ\n\nのまま使えば、このような変数は削除できる。\n\nー\n\n_\n\nvar remove one = function (array, value to remove) {\n\nfor (var i = 0; i < array.length; i += l) {\n\nvar remove one = function (array, value to_remove) {\n\nvar index to remove = null;\nfor (var i = 0; i < array.length; i += l) {\n\nif (array[i] === value to remove) {\n\ni\nndex to remove = i;\nbreak;\n\nf (index to remove !== null) {\n\narray・splice(index to remove, l);\n\n｝\n\n｝i\n\n｝\n\n； 変\n\n}\n\n','変数を削除するʼ  root message・last view time = datetime・datetime. nowQ  ｎｏｗのような変数は、コードを編集した「残骸」だ。変数nowも最初は複数の場所 で使われていたのだろう。あるいは、何度もｎｏｗを使おうと思っていたのに、一度し か使う機会がなかったのかもしれない。  中間結果を削除する  以下は、配列から値を削除するJavaScriptの関数の例だ。  数index  to  removeは、中間結果を保持するためだけに使っている。結果をそ  のまま使えば、このような変数は削除できる。  ー  _  var remove one = function (array, value to remove) {  for (var i = ; i < array.length; i += l) {  var remove one = function (array, value to_remove) {  var index to remove = null; for (var i = ; i < array.length; i += l) {  if (array[i] === value to remove) {  i ndex to remove = i; break;  f (index to remove !== null) {  array・splice(index to remove, l);  ｝  ｝i  ｝   変  }  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(128,1,127,'１14     9章変数と読みやすさ\n\nif (array[i] === value to remove) {\n\narray・splice(l, l)j\nreturn;\n\n｝\n\nー\n\n卓\n一\n一\n一\n一\n■\nニ\nタ\n\n関数から早く返すことで、index to removeをすべて削除できた。これでコードが\n\nずっと簡潔になった。\n\nタスクはできるだけ早く完了するほうがいい。\n\n制御フロー変数を削除する\nループでこんなコードを見かけることがある。\n\nboolean done = false:\nwhile (/*条件*/ && Idone) {\n\n● ● ●\n\nif…）｛\n\ndone = true:\ncontinue;\n\n｝\n\nこの変数doneは、ループのいろんなところでtrueに設定されている。\nこのようなコードは、「ループの途中から抜け出してはいけない」という暗黙的な\n\nルールを守ろうとしているのだろう。だが、そんなルールなど存在しない！\n\ndoneのような変数のことをぼくたちは「制御フロー変数」と呼んでいる。これは\nプログラムの実行を制御するためだけの変数であり、実際のプログラムに関係のある\nデータは含まれていない。ぼくたちの経験からすると、うまくプログラミングすれ\nば、制御フロー変数は削除できる。\n\nwhile (/*条件*/\n\nif…）｛\nbreak;\n\n','     章変数と読みやすさ  if (array[i] === value to remove) {  array・splice(l, l)j return;  ｝  ー  卓 一 一 一 一 ■ ニ タ  関数から早く返すことで、index to removeをすべて削除できた。これでコードが  ずっと簡潔になった。  タスクはできるだけ早く完了するほうがいい。  制御フロー変数を削除する ループでこんなコードを見かけることがある。  boolean done = false: while (/*条件*/ && Idone) {  ● ● ●  if…｛  done = true: continue;  ｝  この変数doneは、ループのいろんなところでtrueに設定されている。 このようなコードは、「ループの途中から抜け出してはいけない」という暗黙的な  ルールを守ろうとしているのだろう。だが、そんなルールなど存在しない  doneのような変数のことをぼくたちは「制御フロー変数」と呼んでいる。これは プログラムの実行を制御するためだけの変数であり、実際のプログラムに関係のある データは含まれていない。ぼくたちの経験からすると、うまくプログラミングすれ ば、制御フロー変数は削除できる。  while (/*条件*/  if…｛ break;  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(129,1,128,'９２変数のスコープを縮めるʼ１１５\n\nこれなら修正は簡単だ。でも、breakが使えないようなネストが何段階もあるルー\nプはどうすればいいのだろう？そうした複雑な場合には、コード（ループの内部の\nコードやループ全体）を新しい関数に移動するといい。\n\n四六時中、面接を受けるっていうのはどういう気持ち？\n\nMicrosoft社のエリック・ブレックナーは、面接の質問には少なくとも３つの変数がな\nければいけないと言っている十．３つの変数を同時に処理するには、しっかりと考えなけれ\nばいけないからだろう！これが面接ならいい。候補者を追い込むのが目的だからだ。で\nも、君のコードを同僚が読んでいるときに、面接を受けているような気分になるとしたら\nどうだろう。そんな気持ちにさせたいだろうか？\n\n9.2変数のスコープを縮める\n「グローバル変数は避ける」というアドバイスは、誰もが一度は耳にしたことがあ\nるはずだ。これは素晴らしいアドバイスである。グローバル変数というのは、どこで\nどのように使われるのかを追跡するのが難しい。また、「名前空間を汚染する」（ロー\nカル変数と衝突する可能性がある）ことから、ローカル変数を使っているつもりでグ\nローバル変数を修正したり、グローバル変数を使っているつもりでローカル変数を修\n正したりしてしまう。\n\nグローバル変数に限らず、すべての変数の「スコープを縮める」のはいい考えだ。\n\n(cid:20276)となる考え\n変数のことが見えるコード行数をできるだけ減らす。\n\n多くのプログラミング言語には、スコープやアクセスのレベルが複数用意されてい\nる。例えば、モジュール・クラス・関数・ブロックスコープなどがそうだ。アクセス\nはできるだけ制限して、変数のことが「見えてしまう」コードを減らすのがいいとさ\nれている。\nt       Eric Brechner\'s I. M. Wright\'s \"Hard Code\" (Microsoft Press, 2007), p. 166.\n\n','変数のスコープを縮めるʼ  これなら修正は簡単だ。でも、breakが使えないようなネストが何段階もあるルー プはどうすればいいのだろうそうした複雑な場合には、コードループの内部の コードやループ全体を新しい関数に移動するといい。  四六時中、面接を受けるっていうのはどういう気持ち  Microsoft社のエリック・ブレックナーは、面接の質問には少なくともつの変数がな ければいけないと言っている十つの変数を同時に処理するには、しっかりと考えなけれ ばいけないからだろうこれが面接ならいい。候補者を追い込むのが目的だからだ。で も、君のコードを同僚が読んでいるときに、面接を受けているような気分になるとしたら どうだろう。そんな気持ちにさせたいだろうか  .変数のスコープを縮める 「グローバル変数は避ける」というアドバイスは、誰もが一度は耳にしたことがあ るはずだ。これは素晴らしいアドバイスである。グローバル変数というのは、どこで どのように使われるのかを追跡するのが難しい。また、「名前空間を汚染する」ロー カル変数と衝突する可能性があることから、ローカル変数を使っているつもりでグ ローバル変数を修正したり、グローバル変数を使っているつもりでローカル変数を修 正したりしてしまう。  グローバル変数に限らず、すべての変数の「スコープを縮める」のはいい考えだ。  (cid:)となる考え 変数のことが見えるコード行数をできるだけ減らす。  多くのプログラミング言語には、スコープやアクセスのレベルが複数用意されてい る。例えば、モジュール・クラス・関数・ブロックスコープなどがそうだ。アクセス はできるだけ制限して、変数のことが「見えてしまう」コードを減らすのがいいとさ れている。 t       Eric Brechner\'s I. M. Wright\'s \"Hard Code\" (Microsoft Press, ), p. .  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(130,1,129,'１１６１９章変数と読みやすさ\n\nでは、なぜそうするのがいいとされているのだろう？それは、一度に考えなけれ\nばいけない変数を減らせるからだ。すべての変数のスコープを１/２に縮めることが\nできれば、スコープに存在する変数の数は平均して１/２になる。\n\n例えば、巨大なクラスがあるとしよう。メンバ変数は２つのメソッドから使用さ\n\nれている。\n\nclass LargeClass {\n\nstring str ;\n\n/  strを使っていないメソッドがたくさんある\n\nー\n\nｈ\n\nメンバ変数というのは、クラスのなかで「ミニグローバル」になっているとも言え\nる。大きなクラスでは、すべてのメンバ変数を追跡したり、どのメソッドが変数を変\n更しているかを把握したりするのは難しい。したがって、ミニグローバルはできるだ\nけ減らしたほうがいい。\n\nこの場合は、strをローカル変数に「格下げ」するといいかもしれない。\n\nass LargeClass {\nc\nl\nvoid MethodlQ {\nstring str二…：j\nMethod2(str);\n\noid Method2(string str) {\n\n// strを使っている\n\n／その他のメソッドはstrが見えない。\n\nＩ\n\nvoid Methodl {\nstr   =…j\nMethod2();\n\nd Method2() {\no\ni\n// strを使っている\n\n｝ v\n\n｝ /\n\n｝ v\n\n｝ /\n\n','章変数と読みやすさ  では、なぜそうするのがいいとされているのだろうそれは、一度に考えなけれ ばいけない変数を減らせるからだ。すべての変数のスコープを/に縮めることが できれば、スコープに存在する変数の数は平均して/になる。  例えば、巨大なクラスがあるとしよう。メンバ変数はつのメソッドから使用さ  れている。  class LargeClass {  string str ;  /  strを使っていないメソッドがたくさんある  ー  ｈ  メンバ変数というのは、クラスのなかで「ミニグローバル」になっているとも言え る。大きなクラスでは、すべてのメンバ変数を追跡したり、どのメソッドが変数を変 更しているかを把握したりするのは難しい。したがって、ミニグローバルはできるだ け減らしたほうがいい。  この場合は、strをローカル変数に「格下げ」するといいかもしれない。  ass LargeClass { c l void MethodlQ { string str二…j Method(str);  oid Method(string str) {  // strを使っている  その他のメソッドはstrが見えない。  Ｉ  void Methodl { str   =…j Method();  d Method() { o i // strを使っている  ｝ v  ｝ /  ｝ v  ｝ /  ','2017-11-20 15:02:17','2017-11-20 15:02:17'),(131,1,130,'９２変数のスコープを縮めるʼ１１７\n\nクラスのメンバへのアクセスを制限するもう１つの方法は、メソッドをできるだ\nけstaticにすることだ。staticメソッドを使えば「メンバ変数とは関係ない」こと\nがよくわかる。\n\nもう１つの方法は、大きなクラスを小さなクラスに分割することだ。ただし、分\n割後のクラスが独立していれば問題ないけど、クラスで相互にメンバを参照し合うよ\nうならやっても意味がない。\n\nこのことは、大きなファイルを小さなファイルに分割したり、大きな関数を小さな\n関数に分割したりするときも同じだ。分割したいのはデータ（つまり、変数）なので\nある。\n\nただし、言語によってスコープの決め方は違う。変数などのスコープに関する興味\n\n深い規則をいくつか紹介しよう。\n\nC++のif文のスコープ\n以下のようなC++のコードがあるとしよう。\n\nPaymentlnfo* info = database・ReadPaymentlnfoQ;\nif (info) {\n\neout  \"User paid: \"  info->amount()  endl;\n\n／以下、コードが続く\n\n｝ /\n\n｝ こ\n\n変数infoは関数のスコープ内にあるので、またいつどのように使われるかを考え\n\nながらコードを読まなければいけない。\n\n変数infoが必要なのは、if文のなかだけである。このような場合には、C++の条\n\n件式で変数infoを定義すればいい。\n\nf (Paymentlnfo* info = database.ReadPaymentlnfoQ) {\ni\neout  \"User paid: \"  info->amount()  endl;\n\nうしておけば、スコープをすぎたらinfoを忘れることができる。\n\nJ a v a S c r i p t で 「 プ ラ イ ベ ー ト 」 変 数 を 作 る\n永続的な変数があるとしよう。これは１つの関数でしか使われていない。\n\n','変数のスコープを縮めるʼ  クラスのメンバへのアクセスを制限するもうつの方法は、メソッドをできるだ けstaticにすることだ。staticメソッドを使えば「メンバ変数とは関係ない」こと がよくわかる。  もうつの方法は、大きなクラスを小さなクラスに分割することだ。ただし、分 割後のクラスが独立していれば問題ないけど、クラスで相互にメンバを参照し合うよ うならやっても意味がない。  このことは、大きなファイルを小さなファイルに分割したり、大きな関数を小さな 関数に分割したりするときも同じだ。分割したいのはデータつまり、変数なので ある。  ただし、言語によってスコープの決め方は違う。変数などのスコープに関する興味  深い規則をいくつか紹介しよう。  C++のif文のスコープ 以下のようなC++のコードがあるとしよう。  Paymentlnfo* info = database・ReadPaymentlnfoQ; if (info) {  eout  \"User paid: \"  info->amount()  endl;  以下、コードが続く  ｝ /  ｝ こ  変数infoは関数のスコープ内にあるので、またいつどのように使われるかを考え  ながらコードを読まなければいけない。  変数infoが必要なのは、if文のなかだけである。このような場合には、C++の条  件式で変数infoを定義すればいい。  f (Paymentlnfo* info = database.ReadPaymentlnfoQ) { i eout  \"User paid: \"  info->amount()  endl;  うしておけば、スコープをすぎたらinfoを忘れることができる。  J a v a S c r i p t で 「 プ ラ イ ベ ー ト 」 変 数 を 作 る 永続的な変数があるとしよう。これはつの関数でしか使われていない。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(132,1,131,'ubmittedのようなグローバル変数は、コードを読む人を不安にさせる。\nsubmittedを使っているのはsubmit formQ関数だけのように見えるけど､本当にそ\nうなのかはよくわからない。他のファイルからグローバル変数submittedを使ってい\nる可能ʻ性だってある。しかも、別の目的で！\n\nこの問題を回避するには、変数submittedをクロージャで包んであげればいい。\n\nvar submit form = (function () {\n\nvar submitted = false;   //注意：以下の関数からしかアクセスされない\n\n１１８１９章変数と読みやすさ\n\nsubmitted  =  false;  //注意：グローバル変数\n\nvar submitjorm = function (form name) {\n\nif (submitted) {\n\nreturn;   //二重投稿禁止\n\n｝ ●\n\n● ●\n\nsubmitted = true;\n\n}\n\n； s\n\n最終行にある括弧に注目して欲しい。外側の無名関数がすぐに実行されて、内側の\n\n関数を返している。\n\nこの技法をはじめて見たのであれば、最初は奇妙に見えるかもしれない。これに\nは、内側の関数だけがアクセスできる「プライベート」スコープを作る効果がある。\nこれで読み手は「submittedはいつ使われるの？」と気になったり、同じ名前のグ\nローバル変数と衝突しないかと不安になったりすることはない（他にも同様の技法が\n[JavaScript: The Good PartsJ (Douglas Crockford, O\'Reilly, 2008)↑に載っている)。\n\n↑訳注FJavaScript: The Good Parts-「良いパーツ」によるベストプラクテイス」（ダグラス・クロック\n\nフォード著、水野貴明訳、オライリー・ジャパン）\n\nreturn function (form name) {\n\nif (submitted) {\n\nreturn;   //二重投稿禁止\n\nubmitted = true;\n\n｝ s\n\n；\n｝\n}())；\n\n','ubmittedのようなグローバル変数は、コードを読む人を不安にさせる。 submittedを使っているのはsubmit formQ関数だけのように見えるけど､本当にそ うなのかはよくわからない。他のファイルからグローバル変数submittedを使ってい る可能ʻ性だってある。しかも、別の目的で  この問題を回避するには、変数submittedをクロージャで包んであげればいい。  var submit form = (function () {  var submitted = false;   //注意以下の関数からしかアクセスされない  章変数と読みやすさ  submitted  =  false;  //注意グローバル変数  var submitjorm = function (form name) {  if (submitted) {  return;   //二重投稿禁止  ｝ ●  ● ●  submitted = true;  }   s  最終行にある括弧に注目して欲しい。外側の無名関数がすぐに実行されて、内側の  関数を返している。  この技法をはじめて見たのであれば、最初は奇妙に見えるかもしれない。これに は、内側の関数だけがアクセスできる「プライベート」スコープを作る効果がある。 これで読み手は「submittedはいつ使われるの」と気になったり、同じ名前のグ ローバル変数と衝突しないかと不安になったりすることはない他にも同様の技法が [JavaScript: The Good PartsJ (Douglas Crockford, O\'Reilly, )↑に載っている)。  ↑訳注FJavaScript: The Good Parts-「良いパーツ」によるベストプラクテイス」ダグラス・クロック  フォード著、水野貴明訳、オライリー・ジャパン  return function (form name) {  if (submitted) {  return;   //二重投稿禁止  ubmitted = true;  ｝ s   ｝ }())  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(133,1,132,'９２変数のスコープを縮めるʼ１１９\n\nJ a v a S c r i p t の グ ロ ー バ ル ス コ ー プ\n\nJavaScriptでは、変数の定義にvarをつけないと（例えば、var x = 1じゃなくて\nx = 1にすると)、その変数はグローバルスコープに入ってしまう。グローバルスコー\nプに入ると、すべてのJavaScriptフアイルや<script>ブロックからアクセスできて\nしまう。以下に例を挙げよう。\n\nこのコードでは、意図せずに変数ｉをグローバルスコープに入れている。したがっ\n\nて、他のブロックからも変数が見えてしまう。\n\n<script>\n\n</script>\n\nalert(i);      //  \'10\'が表示される。\'i\'はｸﾛｰﾊﾙ変数なのだ！\n\nこのスコープの規則のことを知らないプログラマが多い。そして、この驚くべき振\nる舞いによって、奇妙なバグが生み出されている。よくあるのは、２つの関数でｖａｒ\nのない同じ名前のローカル変数を作ってしまうことだ。これだと２つの関数が「混\n線」してしまう。未熟なプログラマであれば、コンピュータのプロセッサやメモリが\n壊れたと思い込んでしまうだろう。\n\nJavaScriptの「ベストプラクテイス」は、「変数を定義するときには常にvarキー\nワードをつける（例: var x = 1)」だ。このプラクテイスを使えば、変数のスコープ\nをその変数が定義された（最も内側の）関数に制限してくれる。\n\nP y t h o n と J a v a S c r i p t の ネ ス ト し な い ス コ ー プ\n\nC++やJavaのような言語にはブロックスコープがある。ｉｆ・ｆｏｒ・tryなどのブ\n\nロックで定義された変数は、スコープがそのブロックに制限されるのだ。\n\n／／危険:  \'i\'は\'var\'で宣言されていない！\nfor (i = o; i < 10; i += 1) ...\n\n｝\n  ;\n</script>\n\n； f\n\n<script>\n\nvar f = function () {\n\n','変数のスコープを縮めるʼ  J a v a S c r i p t の グ ロ ー バ ル ス コ ー プ  JavaScriptでは、変数の定義にvarをつけないと例えば、var x = じゃなくて x = にすると)、その変数はグローバルスコープに入ってしまう。グローバルスコー プに入ると、すべてのJavaScriptフアイルや<script>ブロックからアクセスできて しまう。以下に例を挙げよう。  このコードでは、意図せずに変数ｉをグローバルスコープに入れている。したがっ  て、他のブロックからも変数が見えてしまう。  <script>  </script>  alert(i);      //  \'\'が表示される。\'i\'はｸﾛｰﾊﾙ変数なのだ  このスコープの規則のことを知らないプログラマが多い。そして、この驚くべき振 る舞いによって、奇妙なバグが生み出されている。よくあるのは、つの関数でｖａｒ のない同じ名前のローカル変数を作ってしまうことだ。これだとつの関数が「混 線」してしまう。未熟なプログラマであれば、コンピュータのプロセッサやメモリが 壊れたと思い込んでしまうだろう。  JavaScriptの「ベストプラクテイス」は、「変数を定義するときには常にvarキー ワードをつける例: var x = )」だ。このプラクテイスを使えば、変数のスコープ をその変数が定義された最も内側の関数に制限してくれる。  P y t h o n と J a v a S c r i p t の ネ ス ト し な い ス コ ー プ  C++やJavaのような言語にはブロックスコープがある。ｉｆ・ｆｏｒ・tryなどのブ  ロックで定義された変数は、スコープがそのブロックに制限されるのだ。  危険:  \'i\'は\'var\'で宣言されていない for (i = o; i < ; i += ) ...  ｝   ; </script>   f  <script>  var f = function () {  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(134,1,133,'PythonやJavaScriptでは、ブロックで定義された変数はその関数全体に「こぼれ\n\n出る｣。例えば、以下のPythonのコードにある変数example valueに注目しよう。\n\n＃ここまではexample valueを使っていない。\nif request:\n\nfor value in request・values:\n\nif value > 0:\n\nexample value = value\nbreak\n\nfor logger in debug・loggers:\n\nlogger.log(\"Example:\", example value\n\nこのスコープ規則に驚くプログラマは多い。それに、このようなコードは読みにく\nい。その他の言語では、example valueが定義された場所はすぐに見つかる。関数α\n｢左端」を見ていけばいいからだ。\n\n先ほどの例にはバグもある。example valueに値が設定されていなければ、最後⑦\nところで「NameError: \'example value\' is not defined」という例外が発生するc\nexample  valueを使っている場所の「最も近い共通の祖先（ネスト的な意味で)」て\n変数を定義すれば、この問題を解決できるし、コードも読みやすくなる。\n\nexample value = None\n\nif request:\n\nfor value in request･values:\n\nif value > 0:\n\nexample value = value\nbreak\n\nif example value\n\nfor logger in debug･loggers:\n\nl\nogger.log(\"Example:\", example value\'\n\n++;   //コンパイルエラー!  Yは未定義です。\n\nif…）｛\n\nint x = 1;\n\n｝x\n\n12０   g章変数と読みやすさ\n\n','PythonやJavaScriptでは、ブロックで定義された変数はその関数全体に「こぼれ  出る｣。例えば、以下のPythonのコードにある変数example valueに注目しよう。  ここまではexample valueを使っていない。 if request:  for value in request・values:  if value > :  example value = value break  for logger in debug・loggers:  logger.log(\"Example:\", example value  このスコープ規則に驚くプログラマは多い。それに、このようなコードは読みにく い。その他の言語では、example valueが定義された場所はすぐに見つかる。関数α ｢左端」を見ていけばいいからだ。  先ほどの例にはバグもある。example valueに値が設定されていなければ、最後⑦ ところで「NameError: \'example value\' is not defined」という例外が発生するc example  valueを使っている場所の「最も近い共通の祖先ネスト的な意味で)」て 変数を定義すれば、この問題を解決できるし、コードも読みやすくなる。  example value = None  if request:  for value in request･values:  if value > :  example value = value break  if example value  for logger in debug･loggers:  l ogger.log(\"Example:\", example value\'  ++;   //コンパイルエラー!  Yは未定義です。  if…｛  int x = ;  ｝x     g章変数と読みやすさ  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(135,1,134,'９２変数のスコープを縮めるʼ１２１\n\nただし、このexample  valueは完全に削除することもできる。example_valueは中\n間結果を保持しているだけなので、「中間結果を削除する」で見たように、「タスクを\nできるだけ早く完了」すればいい。この場合は、値を見つけたらすぐにログに書き込\nむようにする。\n\n新しいコードは以下のようになる。\n\ndef LogExample(value):\n\nfor logger in debug・loggers:\n\nl\nogger・log(\"Example:\", value)\n\nif request:\n\nfor value in request・values:\n\nif value > 0:\n\nLogExample(value) #すぐに\'value\'を使う\nb\nreak\n\n元々のＣ言語では、関数やブロックの先頭で変数を定義する必要があった。長い\n関数のなかで変数をたくさん使っていると、ずっとあとにしか使わないとしても、す\nべての変数を先頭で定義しなければいけなかったのだ(C99とC++にこの制約はな\nい\n)\n\n下の例では、すべての変数が関数の先頭にだらだらと定義されている。\n\n。以\n\n定 義 の 位 置 を 下 げ る\n\ndef ViewFilteredReplies(original_id):\n\nﬁltered replies = []\nroot message = Messages.objects.get(original_id)\na\nl\nl replies = Messages.objects.select(root_id=original_id)\n\nroot message・view count += 1\nroot message.last view time = datetime.datetime.nowQ\nroot message.save()\n\nfor reply in all replies:\n\ni\nf reply,spam votes <= MAX_SPAM_VOTES:\n\nﬁltered replies.append(reply)\n\nreturn  ﬁltered  replies\n\n','変数のスコープを縮めるʼ  ただし、このexample  valueは完全に削除することもできる。example_valueは中 間結果を保持しているだけなので、「中間結果を削除する」で見たように、「タスクを できるだけ早く完了」すればいい。この場合は、値を見つけたらすぐにログに書き込 むようにする。  新しいコードは以下のようになる。  def LogExample(value):  for logger in debug・loggers:  l ogger・log(\"Example:\", value)  if request:  for value in request・values:  if value > :  LogExample(value) #すぐに\'value\'を使う b reak  元々のＣ言語では、関数やブロックの先頭で変数を定義する必要があった。長い 関数のなかで変数をたくさん使っていると、ずっとあとにしか使わないとしても、す べての変数を先頭で定義しなければいけなかったのだ(CとC++にこの制約はな い )  下の例では、すべての変数が関数の先頭にだらだらと定義されている。  。以  定 義 の 位 置 を 下 げ る  def ViewFilteredReplies(original_id):  ﬁltered replies = [] root message = Messages.objects.get(original_id) a l l replies = Messages.objects.select(root_id=original_id)  root message・view count +=  root message.last view time = datetime.datetime.nowQ root message.save()  for reply in all replies:  i f reply,spam votes <= MAX_SPAM_VOTES:  ﬁltered replies.append(reply)  return  ﬁltered  replies  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(136,1,135,'１２２１９章変数と読みやすさ\n\nこのコードの問題点は、常に３つの変数のことを切り替えて考えなければいけな\n\nいことだ。\n\n最初からすべての変数を知る必要はないのだから、変数の定義は変数を使う直前に\n\n移動すればいい。\n\ndef ViewFilteredReplies(original id):\n\nroot message = Messages.objects・get(original id)\nr\noot message・view count += 1\nroot message.last view time = datetime.datetime.nowQ\nroot_message.save()\n\nalljreplies = Messages・objects.select(root id=original id]\nﬁltered replies = []\nfor reply in alljreplies:\n\ni\nf reply・spam votes <= MAX SPAM VOTES:\n\ni\nf\nl\ntered replies・append(reply)\n\nreturn ﬁltered replies\n\n変数alljrepliesは必要ないので、以下のように削除できると思ったかもしれな\n\nい。\n\nfor reply in Messages.objects.select(root id二orig加1 id):\n\n● ● ●\n\nこの場合は、alljrepliesが優れた説明変数になっているので、そのままにしてお\n\nこう。\n\n','章変数と読みやすさ  このコードの問題点は、常につの変数のことを切り替えて考えなければいけな  いことだ。  最初からすべての変数を知る必要はないのだから、変数の定義は変数を使う直前に  移動すればいい。  def ViewFilteredReplies(original id):  root message = Messages.objects・get(original id) r oot message・view count +=  root message.last view time = datetime.datetime.nowQ root_message.save()  alljreplies = Messages・objects.select(root id=original id] ﬁltered replies = [] for reply in alljreplies:  i f reply・spam votes <= MAX SPAM VOTES:  i f l tered replies・append(reply)  return ﬁltered replies  変数alljrepliesは必要ないので、以下のように削除できると思ったかもしれな  い。  for reply in Messages.objects.select(root id二orig加 id):  ● ● ●  この場合は、alljrepliesが優れた説明変数になっているので、そのままにしてお  こう。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(137,1,136,'9.3変数は一度だけ書き込む\n\n９４最後の例ʼ１２３\n\n本章では、「生きている」変数が多いとコードが理解しにくくなることを説明した。\nでも、もっと理解しにくいのは、変数が絶えず変更され続けることだ。値を追跡する\n難易度が格段に上がってしまう。\n\nこの問題と戦うために、ちょっと変わったものを提案したい。それは、変数は一度\n\nだけ書き込むというものだ。\n\n「永続的に変更されない」変数は扱いやすい。例えば、以下のような定数は、\n\n','.変数は一度だけ書き込む  最後の例ʼ  本章では、「生きている」変数が多いとコードが理解しにくくなることを説明した。 でも、もっと理解しにくいのは、変数が絶えず変更され続けることだ。値を追跡する 難易度が格段に上がってしまう。  この問題と戦うために、ちょっと変わったものを提案したい。それは、変数は一度  だけ書き込むというものだ。  「永続的に変更されない」変数は扱いやすい。例えば、以下のような定数は、  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(138,1,137,'１２４１９章変数と読みやすさ\n\nstatic const int NUM THREADS = 10:\n\n多くのことを考える必要がない。これと同じ理由で、C++のconst  (やJavaの伽al)\nは是非とも使うべきだ。\n\n実際、多くの言語(PythonやJavaなど）では、Stringなどの組み込み型はイ\nミュータブルになっている。ジェームズ・ゴスリング(Javaの作者）が言うには、\n｢(イミュータブルは）トラブルになる傾向が少ない」そうだ。\n\n変数を一度だけ書き込む手法が使えないとしても、変数の変更箇所はできるだけ少\n\nなくしたほうがいいだろう。\n\n(cid:20276)となる考え\n変数を操作する場所が増えると、現在値の判断が難しくなる。\n\nそれでは、変数を一度だけ書き込むにはどうすればいいだろう？以下の例のよう\n\nに、少しずつ何度もコードを再構築することになるだろう。\n\n９．４最後の例\n本章の最後の例として、これまでに紹介した原則を使ったものを示そう。\n以下のように配置された入力テキストフィールドがウェブページにあるとする。\n\ndnput type=\"text\" id=\"inputl\" value=\"Dustin\">\ndnput type=\"text\" id=\"input2\" value=\"Trevor\">\ndnput type=\"text\" id=\"i叩ut3\" value=\"\">\nd叩ut type=\"text\" id=\"input4\" value=\"Melissa\">\n\n● ● ●\n\nご覧のように、idはinputlから始まって１ずつ増加している。\n君の仕事は、setFirstEmptylnputQという関数を書くことだ。この関数は、文字\n列を受け取って、ウエブページにある最初の空の<input>に入力するというものだ\n(この例では「input3J)。関数の戻り値は、更新したDOM要素（空の入力フィール\nドがなければnull)になる。以下に、本章の原則を適用していないコードがある。\n\nvar setFirstEmptylnput = function (neﾚ¥i value) {\n\nvar found = false;\nvar i = l;\n\n','章変数と読みやすさ  static const int NUM THREADS = :  多くのことを考える必要がない。これと同じ理由で、C++のconst  (やJavaの伽al) は是非とも使うべきだ。  実際、多くの言語(PythonやJavaなどでは、Stringなどの組み込み型はイ ミュータブルになっている。ジェームズ・ゴスリング(Javaの作者が言うには、 ｢(イミュータブルはトラブルになる傾向が少ない」そうだ。  変数を一度だけ書き込む手法が使えないとしても、変数の変更箇所はできるだけ少  なくしたほうがいいだろう。  (cid:)となる考え 変数を操作する場所が増えると、現在値の判断が難しくなる。  それでは、変数を一度だけ書き込むにはどうすればいいだろう以下の例のよう  に、少しずつ何度もコードを再構築することになるだろう。  最後の例 本章の最後の例として、これまでに紹介した原則を使ったものを示そう。 以下のように配置された入力テキストフィールドがウェブページにあるとする。  dnput type=\"text\" id=\"inputl\" value=\"Dustin\"> dnput type=\"text\" id=\"input\" value=\"Trevor\"> dnput type=\"text\" id=\"i叩ut\" value=\"\"> d叩ut type=\"text\" id=\"input\" value=\"Melissa\">  ● ● ●  ご覧のように、idはinputlから始まってずつ増加している。 君の仕事は、setFirstEmptylnputQという関数を書くことだ。この関数は、文字 列を受け取って、ウエブページにある最初の空の<input>に入力するというものだ (この例では「inputJ)。関数の戻り値は、更新したDOM要素空の入力フィール ドがなければnull)になる。以下に、本章の原則を適用していないコードがある。  var setFirstEmptylnput = function (neﾚ¥i value) {  var found = false; var i = l;  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(139,1,138,'９４最後の例ʼ１２５\n\n１\n\nＦ\n\nこのコードは動くけど、あまりキレイじゃない。どこがダメで、どうすれば改善で\nきるだろうか？考え方はいろいろあると思うけど、ここでは変数から考えていきた\nいｏ\n\nの３つの変数は関数のなかで何度も書き換えられている。これらの変数の使い\n\n方を改善してみよう。\n\n本章の最初で説明したように、foundなどの中間変数は早めに返せば削除できる。\n\n以下が改善結果だ。\n\nvar found\nv a r l\nvar elem\n\n● ● ● こ\n\nvar elem = document.getElementById(\'i叩ut\' + i :\nwhile (elem !== null) {\n\nif (elem.value === \") {\n\nfound = true;\nbreak;\n\n｝１++；\n\ne\nl\nem = document, get ElementByldQ input\' + i);\n\nf (found) elem.value = new value;\nreturn elem;\n\n｝i\n\nvar setFirstEmptylnput = function (new_value) {\n\nvar i = i;\nvar elem = document.getElementById(\'i叩ut\' + i):\nwhile (elem !== null) {\n\nif (elem・value === \") {\n\ne\nl\nem･value = new value;\nreturn elem;\n\nelem = document.getElementByldQinput\' + i);\n\n｝ユ++；\n\neturn null;\n\n｝r\n\n}\n；\n\n','最後の例ʼ    Ｆ  このコードは動くけど、あまりキレイじゃない。どこがダメで、どうすれば改善で きるだろうか考え方はいろいろあると思うけど、ここでは変数から考えていきた いｏ  のつの変数は関数のなかで何度も書き換えられている。これらの変数の使い  方を改善してみよう。  本章の最初で説明したように、foundなどの中間変数は早めに返せば削除できる。  以下が改善結果だ。  var found v a r l var elem  ● ● ● こ  var elem = document.getElementById(\'i叩ut\' + i : while (elem !== null) {  if (elem.value === \") {  found = true; break;  ｝++  e l em = document, get ElementByldQ input\' + i);  f (found) elem.value = new value; return elem;  ｝i  var setFirstEmptylnput = function (new_value) {  var i = i; var elem = document.getElementById(\'i叩ut\' + i): while (elem !== null) {  if (elem・value === \") {  e l em･value = new value; return elem;  elem = document.getElementByldQinput\' + i);  ｝ユ++  eturn null;  ｝r  }   ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(140,1,139,'１２６１９章変数と読みやすさ\n\n次に、elemを見ていこう。いろんなところで「ループ状」に何度も使用されてい\nて、値を追いかけるのが難しくなっている。elemはｉに合わせてイテレートしてい\nるように見える。だから、whileをforループに書き換えてみよう。\n\n数elemがループ内で一度だけ書き込まれていることに注目して欲しい。forルー\nプの条件にtrueを使うことはあまりないかもしれないけど、これによってｉの定義\nと増加が１行で書けるようになった（伝統的なwhile (true)でも大丈夫だ)。\n\nJ 変\n\n}\n\n９ ． ５ ま と め\n\n本章では、プログラムの変数はすぐに増えるので、いずれ追跡できなくなるという\n話をした。変数を減らして、できるだけ「軽量」にすれば、コードは読みやすくな\nる。具体的には、\n\n●邪魔な変数を削除する。­本章では、結果をすぐに使って、「中間結果一\n\nの変数を削除する例を示した。\n\n●\n\n●\n\n変数のスコープをできるだけ小さくする。­変数を数行のコードからし\nか見えない位置に移動する。「去る者は日々に疎し」って言うからね（いい\n意味で)。\n­度だけ書き込む変数を使う。­変数に一度だけ値を設定すれば（あるい\nは、constやfinalなどのイミュータブルにする方法を使えば)、コードが\n理解しやすくなる。\n\nif (elem.value === \"   {\n\ne\nl\nem･value = new value:\nreturn elem;\n\nｑ\n\n■\n\n■\n\n■\n\n夕\n\n｝\n\nvar setFirstEmptylnput = function (neﾚ4 value) {\n\nfor (var i = l; true; i++) {\n\nvar elem = document・getElementByldQ input\' + i);\ni\nf (elem === null)\n\nreturn null; //検索失敗。空の入力フィールドは見つからなかった。\n\n','章変数と読みやすさ  次に、elemを見ていこう。いろんなところで「ループ状」に何度も使用されてい て、値を追いかけるのが難しくなっている。elemはｉに合わせてイテレートしてい るように見える。だから、whileをforループに書き換えてみよう。  数elemがループ内で一度だけ書き込まれていることに注目して欲しい。forルー プの条件にtrueを使うことはあまりないかもしれないけど、これによってｉの定義 と増加が行で書けるようになった伝統的なwhile (true)でも大丈夫だ)。  J 変  }     ま と め  本章では、プログラムの変数はすぐに増えるので、いずれ追跡できなくなるという 話をした。変数を減らして、できるだけ「軽量」にすれば、コードは読みやすくな る。具体的には、  ●邪魔な変数を削除する。­本章では、結果をすぐに使って、「中間結果一  の変数を削除する例を示した。  ●  ●  変数のスコープをできるだけ小さくする。­変数を数行のコードからし か見えない位置に移動する。「去る者は日々に疎し」って言うからねいい 意味で)。 ­度だけ書き込む変数を使う。­変数に一度だけ値を設定すればあるい は、constやfinalなどのイミュータブルにする方法を使えば)、コードが 理解しやすくなる。  if (elem.value === \"   {  e l em･value = new value: return elem;  ｑ  ■  ■  ■  夕  ｝  var setFirstEmptylnput = function (neﾚ value) {  for (var i = l; true; i++) {  var elem = document・getElementByldQ input\' + i); i f (elem === null)  return null; //検索失敗。空の入力フィールドは見つからなかった。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(141,1,140,'蕊 剛 離\nコードの再構成\n\n第Ⅱ部では、コードを読みやすくするために、プログラムの「ループとロジック｜\nを変更する方法を説明した。そして、プログラムの構造を少しだけ変更する技法をい\nくつか紹介した。\n\n第Ⅲ部では、コードを大きく変更する技法を紹介する。具体的には、コードを再構\n\n成する３つの方法について説明する。\n\n●プログラムの主目的と関係のない「無関係の下位問題」を抽出する。\n\n●コードを再構成して、一度に１つのことをやるようにする。\n\n●最初にコードを言葉で説明する。その説明を元にしてキレイな解決策を作\n\nる\n。\n\n最後に、コードを完全に削除できる状況について説明する。また、コードを書かず\nに済ませる状況についても説明する（コードを理解しやすくするには、コードを書か\nないのがいちばんだ)。\n\n','蕊 剛 離 コードの再構成  第Ⅱ部では、コードを読みやすくするために、プログラムの「ループとロジック｜ を変更する方法を説明した。そして、プログラムの構造を少しだけ変更する技法をい くつか紹介した。  第Ⅲ部では、コードを大きく変更する技法を紹介する。具体的には、コードを再構  成するつの方法について説明する。  ●プログラムの主目的と関係のない「無関係の下位問題」を抽出する。  ●コードを再構成して、一度につのことをやるようにする。  ●最初にコードを言葉で説明する。その説明を元にしてキレイな解決策を作  る 。  最後に、コードを完全に削除できる状況について説明する。また、コードを書かず に済ませる状況についても説明するコードを理解しやすくするには、コードを書か ないのがいちばんだ)。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(142,1,141,'１ 129\n10章\n無関係の下位問題を抽出する\n\nｆ1\n\n口 ！ 一\n\n１\n\n箪\n\n二 ʻ\n琴\n\n匠\n\n5分\n\n１\n０\n夕\n\n','  章 無関係の下位問題を抽出する  ｆ  口  一    箪  二 ʻ 琴  匠  分    夕  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(143,1,142,'130      １0章無関係の下位問題を抽出する\n\nエンジニアリングとは、大きな問題を小さな問題に分割して、それぞれの解決策を\n組み立てることに他ならない。この原則をコードに当てはめれば、堅ろうで読みやす\nいコードになる。\n\n本章のアドバイスは、無関係の下位問題を積極的に見つけて抽出することだ。ぼく\n\nたちは以下のことを考えている。\n\n1．関数やコードブロックを見て「このコードの高レベルの目標は何か？」と自\n\n問する。\n\n2．コードの各行に対して「高レベルの目標に直接的に効果があるのか？ある\n\nいは、無関係の下位問題を解決しているのか？」と自問する。\n\n3．無関係の下位問題を解決しているコードが相当量あれば、それらを抽出して\n\n別の関数にする。\n\nコードを抽出して別の関数にするなんて毎日やっていることかもしれないけど、本\n章では無関係の下位問題を抽出する場合に限定している。このようにして抽出された\nコードは、自分がアプリケーションからどのように呼び出されるのかわかっていな\nいｏ\n\nこの技法は簡単に使えるのに、コードを大幅に改善できる。だけど、なぜだか知ら\nないけど、多くのプログラマがうまく使いこなせていない。うまく使うコツは、無関\n係の下位問題を積極的に探し出すことだ。\n\n本章では、君がこれから直面するさまざまな状況に対して、この技法を適用した例\n\nをいくつか紹介していこう。\n10.1入門的な例: findClosestLocationO\n以下にJavaScriptのコードがある。このコードの高レベルの目標は「与えられた\n地点から最も近い場所を見つける」ことだ（斜体のところで難しい幾何学の計算が出\nてきてるけど怖がらないで)。\n\n/／与えられた緯度経度に最も近い\'array\'の要素を返す。\n/／地球が完全な球体であることを前提としている。\nvar ﬁndClosestLocation = function (lat, Ing, array) {\n\nvar closest;\n\n','      章無関係の下位問題を抽出する  エンジニアリングとは、大きな問題を小さな問題に分割して、それぞれの解決策を 組み立てることに他ならない。この原則をコードに当てはめれば、堅ろうで読みやす いコードになる。  本章のアドバイスは、無関係の下位問題を積極的に見つけて抽出することだ。ぼく  たちは以下のことを考えている。  関数やコードブロックを見て「このコードの高レベルの目標は何か」と自  問する。  コードの各行に対して「高レベルの目標に直接的に効果があるのかある  いは、無関係の下位問題を解決しているのか」と自問する。  無関係の下位問題を解決しているコードが相当量あれば、それらを抽出して  別の関数にする。  コードを抽出して別の関数にするなんて毎日やっていることかもしれないけど、本 章では無関係の下位問題を抽出する場合に限定している。このようにして抽出された コードは、自分がアプリケーションからどのように呼び出されるのかわかっていな いｏ  この技法は簡単に使えるのに、コードを大幅に改善できる。だけど、なぜだか知ら ないけど、多くのプログラマがうまく使いこなせていない。うまく使うコツは、無関 係の下位問題を積極的に探し出すことだ。  本章では、君がこれから直面するさまざまな状況に対して、この技法を適用した例  をいくつか紹介していこう。 .入門的な例: findClosestLocationO 以下にJavaScriptのコードがある。このコードの高レベルの目標は「与えられた 地点から最も近い場所を見つける」ことだ斜体のところで難しい幾何学の計算が出 てきてるけど怖がらないで)。  /与えられた緯度経度に最も近い\'array\'の要素を返す。 /地球が完全な球体であることを前提としている。 var ﬁndClosestLocation = function (lat, Ing, array) {  var closest;  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(144,1,143,'10.1入門的な例: findClosestLocationO   I 131\n\nvar closest dist = Number・MAX VALUE;\nfor (var i = 0; i < array.length; i += l) {\n\n／／２つの地点をラジアンに変換する。\nvar lat rad = ra曲\"s (latノノ\nvar Ing rad = radians (Ing);\nvar lat2 rad = ra曲\"s(array[i],latitudeノノ\nvar 1ﾉ(cid:7721)込rad = ra曲\"s(array何.lo昭加de,\n\n〃/球面三角法の第二余弦定理ノの公式を使う。\nvar dist = Math.acos伽仇sin (lat radﾉ＊陥th.sin(lat2 rad) i\n〃a仇cos (lat rad) *陥仇cos(lat2 rad）鍬\nMatﾉ\'・ＣＯＳ(Iﾉig2 rad - Ing radノル\n\nープ内のコードは無関係の下位問題を扱っている。それは「２つの地点（緯度\n経度）の球面距離を算出する」だ。コード量が多いので、新しい関数spherical\ndistancef)に抽出するといいだろう。\n\nif (dist < closest dist) {\n\nclosest = array[i];\nclosest dist = dist;\n\n｝\n\neturn closest;\n\n｝r\n\n; ル\n\nvar spherical distance = function (latl, Ingl, lat2, lng2) {\n\nvar latl rad = radians(latl);\nvar Ingljad = radians(lngl);\nvar lat2 rad = radians(lat2);\nvar lng2 rad = radians(lng2);\n\n／／「球面三角法の第二余弦定理」の公式を使う。\nreturn Math.acos(Math.sin(latl rad) * Math.sin(lat2 rad) 4\nMath.cos(latl rad) * Math.cos(lat2_rad) *\nMath.cos(lng2 rad - Ingl rad));\n\nったコードは以下のようになる。\n\n； 残\n\n}\n\nvar ﬁndClosestLocation = function (lat, Ing, array) {\n\nvar closest;\n\n','.入門的な例: findClosestLocationO   I   var closest dist = Number・MAX VALUE; for (var i = ; i < array.length; i += l) {  つの地点をラジアンに変換する。 var lat rad = ra曲\"s (latノノ var Ing rad = radians (Ing); var lat rad = ra曲\"s(array[i],latitudeノノ var ﾉ(cid:)込rad = ra曲\"s(array何.lo昭加de,  〃/球面三角法の第二余弦定理ノの公式を使う。 var dist = Math.acos伽仇sin (lat radﾉ陥th.sin(lat rad) i 〃a仇cos (lat rad) *陥仇cos(lat rad鍬 Matﾉ\'・ＣＯＳ(Iﾉig rad - Ing radノル  ープ内のコードは無関係の下位問題を扱っている。それは「つの地点緯度 経度の球面距離を算出する」だ。コード量が多いので、新しい関数spherical distancef)に抽出するといいだろう。  if (dist < closest dist) {  closest = array[i]; closest dist = dist;  ｝  eturn closest;  ｝r  ; ル  var spherical distance = function (latl, Ingl, lat, lng) {  var latl rad = radians(latl); var Ingljad = radians(lngl); var lat rad = radians(lat); var lng rad = radians(lng);  「球面三角法の第二余弦定理」の公式を使う。 return Math.acos(Math.sin(latl rad) * Math.sin(lat rad)  Math.cos(latl rad) * Math.cos(lat_rad) * Math.cos(lng rad - Ingl rad));  ったコードは以下のようになる。   残  }  var ﬁndClosestLocation = function (lat, Ing, array) {  var closest;  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(145,1,144,'var closest dist = Number･MAX VALUE;\nfor (var i = 0; i < array.length; i += l) {\n\nvar dist = spherical_distance(lat, Ing, array[i]・latitude, array[i]・longitude);\nif (dist < closest dist) {\n\nclosest = array[i];\nclosest dist = dist;\n\n｝\n\neturn closest;\n\n｝r\n\nＩ\n\nコードがずっと読みやすくなった。難しそうな幾何学の計算に心を奪われることな\n\nく、高レベルの目標に集中できるようになった。\n\nさらに言うと、spherical  distancef)は個別にテストができる関数だ。\nspherical distancef)は将来的に再利用可能な関数だ。これが「無関係の」下位問\n題と呼ばれる理由だ。完全に自己完結しているので、自分がアプリケーションにどの\nように使われるかを知らないのだ。\n1０.２純粋なユーティリティコード\nプログラムの核となる基本的なタスクというものがある。例えば、文字列の操作・\n\nハシシュテーブルの使用・ファイルの読み書きなどがそうだ。\n\nこうした「基本的なユーティリティ」は、プログラミング言語の組み込みライ\nブラリとして実装されている。例えば、ファイルの中身をすべて読み込みたけれ\nば､PHPならfile_get_contents(\"filename\")が､Pythonならopenf\'filename\").\nread()が使える。\n\nでも、たまに自分でこの溝を埋めなきゃいけないことがある。例えばC++では、\nファイルの中身をすべて読み込む方法が用意されていない。したがって、以下のよう\nなコードを自分で書くことになる。\n\nifstream ﬁle(ﬁle name);\n\n/／ファイルサイズを計算して、バッファにそのサイズを割り当てる。\nﬁle.seekg(0, ios::end);\nconst int ﬁle size = ﬁle.tellgQ;\nchar* ﬁle buf = new char [ﬁle size];\n\n１３2      １0章無関係の下位問題を抽出する\n\n','var closest dist = Number･MAX VALUE; for (var i = ; i < array.length; i += l) {  var dist = spherical_distance(lat, Ing, array[i]・latitude, array[i]・longitude); if (dist < closest dist) {  closest = array[i]; closest dist = dist;  ｝  eturn closest;  ｝r  Ｉ  コードがずっと読みやすくなった。難しそうな幾何学の計算に心を奪われることな  く、高レベルの目標に集中できるようになった。  さらに言うと、spherical  distancef)は個別にテストができる関数だ。 spherical distancef)は将来的に再利用可能な関数だ。これが「無関係の」下位問 題と呼ばれる理由だ。完全に自己完結しているので、自分がアプリケーションにどの ように使われるかを知らないのだ。 .純粋なユーティリティコード プログラムの核となる基本的なタスクというものがある。例えば、文字列の操作・  ハシシュテーブルの使用・ファイルの読み書きなどがそうだ。  こうした「基本的なユーティリティ」は、プログラミング言語の組み込みライ ブラリとして実装されている。例えば、ファイルの中身をすべて読み込みたけれ ば､PHPならfile_get_contents(\"filename\")が､Pythonならopenf\'filename\"). read()が使える。  でも、たまに自分でこの溝を埋めなきゃいけないことがある。例えばC++では、 ファイルの中身をすべて読み込む方法が用意されていない。したがって、以下のよう なコードを自分で書くことになる。  ifstream ﬁle(ﬁle name);  /ファイルサイズを計算して、バッファにそのサイズを割り当てる。 ﬁle.seekg(, ios::end); const int ﬁle size = ﬁle.tellgQ; char* ﬁle buf = new char [ﬁle size];        章無関係の下位問題を抽出する  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(146,1,145,'10.3その他の汎用コード1３3\n\n/／ファイルをバッファに読み込む。\nf\ni\nl\ne・seekg(0, ios::beg);\nﬁle.read(ﬁle buf, ﬁle size);\nﬁle.close();\n\n■ ● ●\n\nこれは「無関係の下位問題」の古典的な例だ。この部分は､ReadFileToStringQな\nどの新しい関数に置き換えるべきだろう。そうすれば､C++がReadFileToStringQ\nという関数をあらかじめ用意しているかのようなコードになる。\n「このライブラリにxyzo関数があればなあ」と思ったら、その関数を自分で書け\nばいいのだ！（ただし、既存の関数がない場合に限る）そうしたコードは複数のプロ\nジェクトで使えるユーティリティコードになっていくだろう。\n\n10.3その他の汎用コード\nJavaScriptをデバッグするときには、alertでメッセージボックスをポップアッ\nプして､何らかの情報を表示させることが多い。これはウェブ版の「printf()デバッ\nグ」だ。以下の関数呼び出しでは、釘ａｘでデータをサーバに送信して、返ってきた\nディクショナリを表示している。\n\nstr += \"   \" + key + \" = \" + response_data[key] + \"¥n\";\n\nlert(str + \"}\");\n\n｝a\n\najax_post({\n\nurl: \'http://example・com/submit\',\ndata: data.\non success: function (response data) {\nvar str = \"{¥n\";\nfor (var key in response_data) {\n\nのコードの高レベルの目標は「サーバをAjaxで呼び出してレスポンスを処理す\nる」である。でも、このコードの大部分は「ディクショナリをキレイに印字(pretty\nprint)する」という「無関係の下位問題」を解決しようとしている。このコードを\n\n； こ\n\n}\n)\n\n/／引き続き\'response  data\'の処理\n\n','.その他の汎用コード  /ファイルをバッファに読み込む。 f i l e・seekg(, ios::beg); ﬁle.read(ﬁle buf, ﬁle size); ﬁle.close();  ■ ● ●  これは「無関係の下位問題」の古典的な例だ。この部分は､ReadFileToStringQな どの新しい関数に置き換えるべきだろう。そうすれば､C++がReadFileToStringQ という関数をあらかじめ用意しているかのようなコードになる。 「このライブラリにxyzo関数があればなあ」と思ったら、その関数を自分で書け ばいいのだただし、既存の関数がない場合に限るそうしたコードは複数のプロ ジェクトで使えるユーティリティコードになっていくだろう。  .その他の汎用コード JavaScriptをデバッグするときには、alertでメッセージボックスをポップアッ プして､何らかの情報を表示させることが多い。これはウェブ版の「printf()デバッ グ」だ。以下の関数呼び出しでは、釘ａｘでデータをサーバに送信して、返ってきた ディクショナリを表示している。  str += \"   \" + key + \" = \" + response_data[key] + \"¥n\";  lert(str + \"}\");  ｝a  ajax_post({  url: \'・com/submit\', data: data. on success: function (response data) { var str = \"{¥n\"; for (var key in response_data) {  のコードの高レベルの目標は「サーバをAjaxで呼び出してレスポンスを処理す る」である。でも、このコードの大部分は「ディクショナリをキレイに印字(pretty print)する」という「無関係の下位問題」を解決しようとしている。このコードを   こ  } )  /引き続き\'response  data\'の処理  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(147,1,146,'}\nいも寄らない恩恵\nformat pretty()を抽出する理由はたくさんある。呼び出し側のコードは簡潔にな\nるし、format pretty()ならあとから再利用できる。\nでも、もう１つ大きな理由がある。気づきにくいかもしれないけど、「コードが独\n立していれば、format_pre甘y()の改善が楽になるから」だ。関数というのは、小さ\nくて独立したものになっていれば、機能追加・読みやすさの向上・エッジケースの処\n理などが楽にできる。\n\n； 思\n\n以下は、formatj)retty(obj)が処理できないケースだ。\n\n●obiにはオブジェクトを期待している。普通の文字列（やundefined)だと\n\n例外が発生する。\n\n●objには単純な型を期待している。ネストしたオブジェクトだとobject\n\nObjectのように表示されるので、プリテイとは言えない。\n\nformat_pretty()が独立した関数になっていなければ、これらを改善するのは大変\n\nだったと思う（特にネストしたオブジェクトを再帰的に印字するのは難しい)。\n\nでも、関数になっていれば、こうした機能は簡単に追加できる。改善したコードは\n\n以下のようになる。\n\nvar format_pretty = function (obj, indent) {\n\n// null  undefined・文字列・非オブジェクトを処理する。\nif (obj === null) return \"null\";\ni\nf (obj === undeﬁned) return \"undeﬁned\";\nif (typeof obj === \"string\") return \"\" + obj + \"\";\nif (typeof obj !== \"object\") return String(obj);\n\nvar format_pretty = function (obj) {\n\nvar str = \"{¥n\";\nfor (var key in obj) {\n\nstr += \"   \" + key + \" = \" + obj[key] + \"¥n\";\n\neturn str + \"}\";\n\n｝r\n\n１３4      １０章無関係の下位問題を抽出する\n\n抽出して、format_pretty(obj)のような関数にするのは簡単だ。\n\n','} いも寄らない恩恵 format pretty()を抽出する理由はたくさんある。呼び出し側のコードは簡潔にな るし、format pretty()ならあとから再利用できる。 でも、もうつ大きな理由がある。気づきにくいかもしれないけど、「コードが独 立していれば、format_pre甘y()の改善が楽になるから」だ。関数というのは、小さ くて独立したものになっていれば、機能追加・読みやすさの向上・エッジケースの処 理などが楽にできる。   思  以下は、formatj)retty(obj)が処理できないケースだ。  ●obiにはオブジェクトを期待している。普通の文字列やundefined)だと  例外が発生する。  ●objには単純な型を期待している。ネストしたオブジェクトだとobject  Objectのように表示されるので、プリテイとは言えない。  format_pretty()が独立した関数になっていなければ、これらを改善するのは大変  だったと思う特にネストしたオブジェクトを再帰的に印字するのは難しい)。  でも、関数になっていれば、こうした機能は簡単に追加できる。改善したコードは  以下のようになる。  var format_pretty = function (obj, indent) {  // null  undefined・文字列・非オブジェクトを処理する。 if (obj === null) return \"null\"; i f (obj === undeﬁned) return \"undeﬁned\"; if (typeof obj === \"string\") return \"\" + obj + \"\"; if (typeof obj !== \"object\") return String(obj);  var format_pretty = function (obj) {  var str = \"{¥n\"; for (var key in obj) {  str += \"   \" + key + \" = \" + obj[key] + \"¥n\";  eturn str + \"}\";  ｝r        章無関係の下位問題を抽出する  抽出して、format_pretty(obj)のような関数にするのは簡単だ。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(148,1,147,'10.4汎用コードをたくさん作るI 1３５\n\n}\n；\nこれは先ほどの欠点を解決している。出力は以下のようになる。\n\nkeyi = 1\nkey2 = true\nkeys = undeﬁned\nkey4 = null\nkeys = {\n\nkeysa = {\n\n｝\n\n｝\n\nkey5al = \"hello world\n\n1 0 ． ４ 汎 用 コ ー ド を た く さ ん 作 る\nReadFileToStringQやformat_pretty()は「無関係の下位問題」のいい例だ。い\nずれも基本的で広く適用可能なので、複数のプロジェクトで再利用できる。このよう\nなコードには、簡単に共有できるように特別なディレクトリ（例: util/を用意す\nる\n。\n汎用コードは素晴らしい。プロジェクトから完全に切り離されているからだ。この\nようなコードは開発もテストも理解も楽だ。すべてのコードがこうなればいいのに１\n便利なライブラリやシステムのことを考えてみよう。SQLデータベース・\nJavaScriptのライブラリ・ＨｒＭＬのテンプレートシステム。いずれも内部のことを\n考えずに使えている。つまり、君のプロジェクトから完全に切り離されているわけ\nだ。結果として、君のプロジェクトのコードは小さく保たれている。\n\n君のプロジェクトもできるだけ独立したライブラリに分離したほうがいい。そうす\n\nstr += indent + \"   \" + key + \"=Ⅲｊ\nstr += format pretty(obj[key], indent + \" \") + \"¥n\";\n\neturn str + indent + \"}\";\n\n｝r\n\ni\nf (indent === undeﬁned) indent = \' \';\n／／（非null)オブジェクトを処理する。\nvar str = \"{¥n\";\nfor (var key in obj) {\n\n','.汎用コードをたくさん作るI   }  これは先ほどの欠点を解決している。出力は以下のようになる。  keyi =  key = true keys = undeﬁned key = null keys = {  keysa = {  ｝  ｝  keyal = \"hello world      汎 用 コ ー ド を た く さ ん 作 る ReadFileToStringQやformat_pretty()は「無関係の下位問題」のいい例だ。い ずれも基本的で広く適用可能なので、複数のプロジェクトで再利用できる。このよう なコードには、簡単に共有できるように特別なディレクトリ例: util/を用意す る 。 汎用コードは素晴らしい。プロジェクトから完全に切り離されているからだ。この ようなコードは開発もテストも理解も楽だ。すべてのコードがこうなればいいのに 便利なライブラリやシステムのことを考えてみよう。SQLデータベース・ JavaScriptのライブラリ・ＨｒＭＬのテンプレートシステム。いずれも内部のことを 考えずに使えている。つまり、君のプロジェクトから完全に切り離されているわけ だ。結果として、君のプロジェクトのコードは小さく保たれている。  君のプロジェクトもできるだけ独立したライブラリに分離したほうがいい。そうす  str += indent + \"   \" + key + \"=Ⅲｊ str += format pretty(obj[key], indent + \" \") + \"¥n\";  eturn str + indent + \"}\";  ｝r  i f (indent === undeﬁned) indent = \' \'; 非null)オブジェクトを処理する。 var str = \"{¥n\"; for (var key in obj) {  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(149,1,148,'13６     １0章無関係の下位問題を抽出する\n\nれば、残りのコードは小さくて考えやすいものになる。\n\nこのプログラミングはトップダウン？ボトムアッブ？\n\nトップダウンプログラミングとは、先に高レベルのモジュールや関数を設計してから、\n\nそれらをサポートする低レベルの関数を実装していく方式だ。\n\nボトムアッププログラミングとは、先にすべての下位問題を解決してから、それらを利\n\n用する高レベルのコンポーネントを実装していく方式だ。\n\n本章はいずれかの手法を推奨するものではない。プログラミングとは両方の側面を持っ\n\nたものだと思う。大切なのは、下位問題を分離して処理できるかどうかだ。\n\n１0.5プロジェクトに特化した機能\n抽出する下位問題というのは、プロジェクトから完全に独立したものであるほうが\nいい。ただし、完全に独立していなくても、それはそれで問題ない。下位問題を取り\n除くだけでも効果がある。\n\nビジネスレビューサイトから例を持ってきた。このPythonコードでは、新しい\n\nBusinessオブジェクトを作って、ｎａｍｅ・ｕｒｌ・datecreatedを設定している。\n\nbusiness = BusinessQ\nbusiness.name = request・POSTPname\"]\n\nurl path name = business.name・lower()\nurl_path_name = re・sub(r\"[\'¥.]\", \"\", urlpath name)\nurl_path_name = re・sub(r\"[八a-zO-9]+\", \"-\", url_path name)\nurl_path_name = url path name.strip(\"-\")\nbusiness・url = \"/biz/\" + url_path name\nbusiness.date created = datetime.datetime・utcnowQ\nbusiness.save to databaseQ\n\nurlはnameの「クリーン」バージョンだ。例えば、nameが「A､C.  Joe\'s  Tire  &\n\nSmog, Inc.,」であれば、urlは「/biz/ac-joes-tire-smog-inc」になる。\n\nこのコードの「無関係の下位問題」は、「名前を有効なＵｍに変換する」だ。こ\nれは楽に抽出できる。ついでに、正規表現もプリコンパイルしておこう（読みやすい\n\n','     章無関係の下位問題を抽出する  れば、残りのコードは小さくて考えやすいものになる。  このプログラミングはトップダウンボトムアッブ  トップダウンプログラミングとは、先に高レベルのモジュールや関数を設計してから、  それらをサポートする低レベルの関数を実装していく方式だ。  ボトムアッププログラミングとは、先にすべての下位問題を解決してから、それらを利  用する高レベルのコンポーネントを実装していく方式だ。  本章はいずれかの手法を推奨するものではない。プログラミングとは両方の側面を持っ  たものだと思う。大切なのは、下位問題を分離して処理できるかどうかだ。  .プロジェクトに特化した機能 抽出する下位問題というのは、プロジェクトから完全に独立したものであるほうが いい。ただし、完全に独立していなくても、それはそれで問題ない。下位問題を取り 除くだけでも効果がある。  ビジネスレビューサイトから例を持ってきた。このPythonコードでは、新しい  Businessオブジェクトを作って、ｎａｍｅ・ｕｒｌ・datecreatedを設定している。  business = BusinessQ business.name = request・POSTPname\"]  url path name = business.name・lower() url_path_name = re・sub(r\"[\'¥.]\", \"\", urlpath name) url_path_name = re・sub(r\"[八a-zO-]+\", \"-\", url_path name) url_path_name = url path name.strip(\"-\") business・url = \"/biz/\" + url_path name business.date created = datetime.datetime・utcnowQ business.save to databaseQ  urlはnameの「クリーン」バージョンだ。例えば、nameが「A､C.  Joe\'s  Tire  &  Smog, Inc.,」であれば、urlは「/biz/ac-joes-tire-smog-inc」になる。  このコードの「無関係の下位問題」は、「名前を有効なＵｍに変換する」だ。こ れは楽に抽出できる。ついでに、正規表現もプリコンパイルしておこう読みやすい  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(150,1,149,'10.6既存のインタフエースを簡潔にする137\n\n名前もつけておこう)。\n\nCHARS TO REMOVE = re.compile(r\"[\'¥.]+\")\nCHARS TO DASH = re.compile(r\"[ﾊa-zO-9]+\")\ndef make url friendly(text):\n\ntext = text・lower()\nt\next = CHARS TO REMOVE.sub(\", text]\nt\next = CHARS TO DASH.subQ-\', text)\nreturn text.strip(\"-\")\n\n元のコードに「規則性」のあるパターンができた。\n\nbusiness = BusinessQ\nbusiness.name = request・POSTPname\"]\nbusiness・url = \"/biz/\" + make url friendly(business.name,\nbusiness･date created = datetime.datetime.utcnowQ\nbusiness・save to databaseQ\n\nコードが読みやすくなった。これで正規表現や文字列処理に心を奪われずに済む。\nmake  url  friendly()はどこに置けばいいのだろう？汎用的な関数なので、\nutil/ディレクトリに入れてもいいと思う。でも、この正規表現はアメリカのビジネ\nス名だけを対象にしているので、元のファイルと同じ場所に置いたほうがいいかもし\nれない。大切なことじゃないので、あとで決めてもいいだろう。大切なのは、make\nurl friendly()を抽出するということだ。\n１0.6既存のインタフェースを簡潔にする\n誰もがキレイなインタフェースを提供するライブラリが好きだ。引数は少なくて、\n事前設定も必要なくて、面倒なことをしなくても使えるライブラリ。インタフェース\nがキレイだとコードが優雅に見える。簡潔で、しかも強力だ。\n\nインタフェースがキレイじゃなくても、自分で「ラップ」関数を作ることができ\n\nる\n。\n例えば、JavaScriptでブラウザのクッキーを扱うのはすごく残念な感じだ。クッ\nキーは名前と値のペアになっているはずなのに、ブラウザが提供するインタフェース\nには、以下のような構文のdocument・cookieという文字列しかない。\n\n','.既存のインタフエースを簡潔にする  名前もつけておこう)。  CHARS TO REMOVE = re.compile(r\"[\'¥.]+\") CHARS TO DASH = re.compile(r\"[ﾊa-zO-]+\") def make url friendly(text):  text = text・lower() t ext = CHARS TO REMOVE.sub(\", text] t ext = CHARS TO DASH.subQ-\', text) return text.strip(\"-\")  元のコードに「規則性」のあるパターンができた。  business = BusinessQ business.name = request・POSTPname\"] business・url = \"/biz/\" + make url friendly(business.name, business･date created = datetime.datetime.utcnowQ business・save to databaseQ  コードが読みやすくなった。これで正規表現や文字列処理に心を奪われずに済む。 make  url  friendly()はどこに置けばいいのだろう汎用的な関数なので、 util/ディレクトリに入れてもいいと思う。でも、この正規表現はアメリカのビジネ ス名だけを対象にしているので、元のファイルと同じ場所に置いたほうがいいかもし れない。大切なことじゃないので、あとで決めてもいいだろう。大切なのは、make url friendly()を抽出するということだ。 .既存のインタフェースを簡潔にする 誰もがキレイなインタフェースを提供するライブラリが好きだ。引数は少なくて、 事前設定も必要なくて、面倒なことをしなくても使えるライブラリ。インタフェース がキレイだとコードが優雅に見える。簡潔で、しかも強力だ。  インタフェースがキレイじゃなくても、自分で「ラップ」関数を作ることができ  る 。 例えば、JavaScriptでブラウザのクッキーを扱うのはすごく残念な感じだ。クッ キーは名前と値のペアになっているはずなのに、ブラウザが提供するインタフェース には、以下のような構文のdocument・cookieという文字列しかない。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(151,1,150,'1３８     10章無関係の下位問題を抽出する\n\nnamel=valuel; name2=value2;．．，\n\n必要なクッキーを探すには、この巨大な文字列を自分でパースしなければいけな\n\nい。以下は、max resultsという名前のクッキーを読み込むコードだ。\n\n０ ■ ■ ■ ■\n\nへえ。汚いコードだ。これは関数get cookieQを作ってから、以下のように書\n\nvar maxjesults = Number(get_cookie(\"max results\"));\n\nクッキーの値の作成や変更もおかしなことになっている。document・cookieに正し\n\nい構文で値を設定する必要があるのだ。\n\ndocument.cookie =   maxjesults=50; expires=Wed, 1 3an 2020 20:53:47 UTC; path=/\";\n\nこの文はすべてのクッキーを書き換えるように思えるけど、（不思議なことに）書\n\nき換えないのである！↑\n\nクッキーを設定する理想的なインタフェースはこうだ。\n\nset_cookie(name, value, days to expire);\n\nクッキーの削除も直感的ではない。有効期限を過去にして設定しなければいけない\n\nのだ。理想的なインタフェースはもっと簡潔だ。\n\ndelete cookie(name):\n\n■ ■ ■\n\nここでの教訓は「理想とは程遠いインタフェースに妥協することはない」というこ\n\n↑ 訳 注 書 き 換 え ず に 追 記 す る 。\n\nvar max results;\nvar cookies = document.cookie.split(*;\');\nfor (var i = 0; i < cookies・length; i++) {\n\nvar c = cookies[il;\nc＝ｃ・replace /M ]+/, \"):   //先頭の空白を削除\ni\nf (c･indexOff\'max results=\") === o)\n\nmax results = Number(c・substring(l2, c・length));\n\n｝ う\n\nきたい。\n\n','     章無関係の下位問題を抽出する  namel=valuel; name=value;  必要なクッキーを探すには、この巨大な文字列を自分でパースしなければいけな  い。以下は、max resultsという名前のクッキーを読み込むコードだ。   ■ ■ ■ ■  へえ。汚いコードだ。これは関数get cookieQを作ってから、以下のように書  var maxjesults = Number(get_cookie(\"max results\"));  クッキーの値の作成や変更もおかしなことになっている。document・cookieに正し  い構文で値を設定する必要があるのだ。  document.cookie =   maxjesults=; expires=Wed,  an  :: UTC; path=/\";  この文はすべてのクッキーを書き換えるように思えるけど、不思議なことに書  き換えないのである↑  クッキーを設定する理想的なインタフェースはこうだ。  set_cookie(name, value, days to expire);  クッキーの削除も直感的ではない。有効期限を過去にして設定しなければいけない  のだ。理想的なインタフェースはもっと簡潔だ。  delete cookie(name):  ■ ■ ■  ここでの教訓は「理想とは程遠いインタフェースに妥協することはない」というこ  ↑ 訳 注 書 き 換 え ず に 追 記 す る 。  var max results; var cookies = document.cookie.split(*;\'); for (var i = ; i < cookies・length; i++) {  var c = cookies[il; cｃ・replace /M ]+/, \"):   //先頭の空白を削除 i f (c･indexOff\'max results=\") === o)  max results = Number(c・substring(l, c・length));  ｝ う  きたい。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(152,1,151,'10.7必要に応じてインタフェースを整える139\n\nとだ。自分でラッパー関数を用意して、手も足も出ない汚いインタフェースを覆い隠\nすのだ。\n10.７必要に応じてインタフェースを整える\nプログラムの多くのコードは、その他のコードを支援するためだけに存在する。例\nえば、関数の事前処理や事後処理などがそうだ。こうした「グルー」コードは、プロ\nグラムの本質的なロジックとは関係ないことが多い。別の関数に分離するのはこうい\nうコードになる。\n\n例えば、{  \"username\": \n\n  \"…\",  \"password\":  \"…\"}のようにユーザの機密情報\nを含んだPythonのディクショナリがあるとする。これらの情報をＵｍに使いたい。\nでも、機密情報なので、Cipherクラスで暗号化したい。\n\nただし、Cipherクラスはディクショナリではなく文字列を受け取る。こちらが欲\nしいのはＵⅢセーフな文字列だけど、Cipherクラスは単なる文字列を返すように\nなっている。また、Cipherクラスは、他にも引数が必要なので使いにくい。\n\n最初は単純なタスクだったのに、多くのグルーコードが必要になった。\n\nuser info = { \"username\": \"…\", \"password\": \"...\" }\nuser str = json・dumps(user info)\nc\ni\npher = Cipher(\"aes 128 cbc\", key=PRIVATE KEY, init vector=INIT VECTOR, op=ENCODE)\nencrypted bytes = cipher.update(user str)\nencrypted_bytes += cipher・finalQ   #現在の128ビツトブロツクをフラッシュする\nurl = \"http://example.com/Puser info=\" + base64.urlsafe b64encode(encrypted bytes)\n\n● ● ●\n\nここで取り組んでいるのは「ユーザの情報を暗号化してURLに含める」だけど、\nコードの大部分が「PythonのオブジェクトをURLセーフな文字列にする」ものに\nなっている。こうした下位問題は抽出しておこう。\n\ndef url safe encrypt(obj):\n\nobj str = json.dumps(obj)\nc\ni\npher = Cipher(\"aes 128 cbc\", key=PRIVATE KEY,皿t vector=INIT VECTOR, op=ENCODE)\nencrypted bytes = cipher.update(obj str)\nencrypted bytes += cipher.finalQ #現在の128ビツトブロツクをフラッシュする\nreturn base64.urlsafe b64encode(encrypted bytes)\n\nその結果、プログラムの本質的なロジックを扱うコードは簡潔になる。\n\n','.必要に応じてインタフェースを整える  とだ。自分でラッパー関数を用意して、手も足も出ない汚いインタフェースを覆い隠 すのだ。 .必要に応じてインタフェースを整える プログラムの多くのコードは、その他のコードを支援するためだけに存在する。例 えば、関数の事前処理や事後処理などがそうだ。こうした「グルー」コードは、プロ グラムの本質的なロジックとは関係ないことが多い。別の関数に分離するのはこうい うコードになる。  例えば、{  \"username\":     \"…\",  \"password\":  \"…\"}のようにユーザの機密情報 を含んだPythonのディクショナリがあるとする。これらの情報をＵｍに使いたい。 でも、機密情報なので、Cipherクラスで暗号化したい。  ただし、Cipherクラスはディクショナリではなく文字列を受け取る。こちらが欲 しいのはＵⅢセーフな文字列だけど、Cipherクラスは単なる文字列を返すように なっている。また、Cipherクラスは、他にも引数が必要なので使いにくい。  最初は単純なタスクだったのに、多くのグルーコードが必要になった。  user info = { \"username\": \"…\", \"password\": \"...\" } user str = json・dumps(user info) c i pher = Cipher(\"aes  cbc\", key=PRIVATE KEY, init vector=INIT VECTOR, op=ENCODE) encrypted bytes = cipher.update(user str) encrypted_bytes += cipher・finalQ   #現在のビツトブロツクをフラッシュする url = \" info=\" + base.urlsafe bencode(encrypted bytes)  ● ● ●  ここで取り組んでいるのは「ユーザの情報を暗号化してURLに含める」だけど、 コードの大部分が「PythonのオブジェクトをURLセーフな文字列にする」ものに なっている。こうした下位問題は抽出しておこう。  def url safe encrypt(obj):  obj str = json.dumps(obj) c i pher = Cipher(\"aes  cbc\", key=PRIVATE KEY,皿t vector=INIT VECTOR, op=ENCODE) encrypted bytes = cipher.update(obj str) encrypted bytes += cipher.finalQ #現在のビツトブロツクをフラッシュする return base.urlsafe bencode(encrypted bytes)  その結果、プログラムの本質的なロジックを扱うコードは簡潔になる。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(153,1,152,'140     10章無関係の下位問題を抽出する\n\nuser info = { \"username\": \"...\", \"password\": \"…\"\nurl = \"http://example.com/Puser info=\" + url safe encrypt(user info)\n1 0 . 8 や り す ぎ\n本章の最初に言ったけど、ぼくたちの目標は「無関係の下位問題を積極的に見つけ\nて抽出する」ことだ。「積極的に」と言ったのは、みんなの積極性が足りないからだ。\nでも、やりすぎたり、度を越したりする可能\'性もある。\n\n例えば、前節のコードをさらに分割すると、以下のようになる。\n\nuser info = { \"username\": \"…\", \"password\": \"…Ⅲ｝\nurl = \"http://example・com/?userJnfo=\" + url_safe_encrypt obj (user info)\ndef url safe encrypt obj(obj):\nobj str = json・dumps(obj)\nreturn url safe encrypt str(obj str)\n\ndef url safe encrypt str(data):\n\nencrypted bytes = encrypt(data)\nreturn base64.urlsafe b64encode(encrypted bytes)\n\ndef encrypt(data):\n\nc\ni\npher = make cipherQ\nencrypted_bytes = cipher.update(data)\nencrypted_bytes += cipher.finalQ #残りをフラツシユする\nreturn encrypted bytes\n\ndef make cipherQ:\n\nreturn Cipher(\"aesj28_cbc\", key=PRIVATE_KEY, init_vector=INIT VECTOR, op=ENCODE)\n\n小さな関数を作りすぎると、逆に読みにくくなってしまう。あちこちに飛び回る実\n\n行パスを追いかけることになるからだ。\n\n新しい関数をコードに追加すると、ごくわずかに（でも確実に）読みにくさのコス\nトが発生する。上記の例は、このコストを相殺できるようなものではない。プロジェ\nクトの他の部分から再利用できるのであれば、小さな関数を追加するのも意味のある\nことかもしれない。でも、それまでは必要ない。\n\n','     章無関係の下位問題を抽出する  user info = { \"username\": \"...\", \"password\": \"…\" url = \" info=\" + url safe encrypt(user info)   .  や り す ぎ 本章の最初に言ったけど、ぼくたちの目標は「無関係の下位問題を積極的に見つけ て抽出する」ことだ。「積極的に」と言ったのは、みんなの積極性が足りないからだ。 でも、やりすぎたり、度を越したりする可能\'性もある。  例えば、前節のコードをさらに分割すると、以下のようになる。  user info = { \"username\": \"…\", \"password\": \"…Ⅲ｝ url = \"・com/?userJnfo=\" + url_safe_encrypt obj (user info) def url safe encrypt obj(obj): obj str = json・dumps(obj) return url safe encrypt str(obj str)  def url safe encrypt str(data):  encrypted bytes = encrypt(data) return base.urlsafe bencode(encrypted bytes)  def encrypt(data):  c i pher = make cipherQ encrypted_bytes = cipher.update(data) encrypted_bytes += cipher.finalQ #残りをフラツシユする return encrypted bytes  def make cipherQ:  return Cipher(\"aesj_cbc\", key=PRIVATE_KEY, init_vector=INIT VECTOR, op=ENCODE)  小さな関数を作りすぎると、逆に読みにくくなってしまう。あちこちに飛び回る実  行パスを追いかけることになるからだ。  新しい関数をコードに追加すると、ごくわずかにでも確実に読みにくさのコス トが発生する。上記の例は、このコストを相殺できるようなものではない。プロジェ クトの他の部分から再利用できるのであれば、小さな関数を追加するのも意味のある ことかもしれない。でも、それまでは必要ない。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(154,1,153,'10.9まとめ1４1\n\n10．９まとめ\n本章を簡単にまとめると、プロジェクト固有のコードから汎用コードを分離すると\nいうことだ。ほとんどのコードは汎用化できる。一般的な問題を解決するライブラリ\nやヘルパー関数を作っていけば、プログラムに固有の小さな核だけが残る。\n\nこの技法が役に立つのは、プロジェクトの他の部分から分離された、境界線の明確\nな小さな問題に集中できるからだ。こうした下位問題に対する解決策は、より綴密で\n正確なものになる。それに、あとでコードを再利用できるかもしれない。\n\nあわせて読みたい\n\nマーチン・ファウラーのiRefactoring: Improving the Design of Existing Code』\n(Fowler et al., Addison-Wesley Professional, 1999)十では、「メソッドの抽出」とい\nうリファクタリング手法が紹介されている。また、さまざまなリファクタリングカタログ\nも掲載されている。\n\nケント・ベツクの『Smalltalk Best Practice Pattemsl (Prentice Hall, 1996)↑す\nでは、「Composed Method」パターンが紹介されている。これは、小さな関数に分割す\nる原則をまとめたものだ。特に「メソッド内部の処理は同じ抽象度のレベルになるように\nします＊」の原則が大切だ。\n\nこれらの考えは、ぼくたちの「無関係の下位問題を抽出する」というアドバイスとよく\n\n似ている。本章で説明したのは、メソッドを抽出する手法の一例だ。\n\n↑訳注『リファクタリングープログラムの体質改善テクニック』（マーチン・ファウラー著、児玉公信、\n\n平深章、友野晶夫、梅沢典史訳、ピアソンエデュケーション）\n\n↑↑訳注『ケント・ベックのSmalltalkベストプラクティス・パターンーシンプル・デザインへの宝石集』\n\n（ケント・ベック著、梅沢真史、皆川誠、小黒直樹、森島みどり訳、ピアソンエデュケーション）\n\n*訳注訳書では「メソッド内部のメッセージは同じ抽象度のレベルになるようにします」になってい\nるけど、「メッセージ」ではなく「処理」または「操作」が妥当と思われる。原文は「Keep  all  of  the\noperations in a single method at the same level of abstraction.｣。\n\n','.まとめ  まとめ 本章を簡単にまとめると、プロジェクト固有のコードから汎用コードを分離すると いうことだ。ほとんどのコードは汎用化できる。一般的な問題を解決するライブラリ やヘルパー関数を作っていけば、プログラムに固有の小さな核だけが残る。  この技法が役に立つのは、プロジェクトの他の部分から分離された、境界線の明確 な小さな問題に集中できるからだ。こうした下位問題に対する解決策は、より綴密で 正確なものになる。それに、あとでコードを再利用できるかもしれない。  あわせて読みたい  マーチン・ファウラーのiRefactoring: Improving the Design of Existing Code』 (Fowler et al., Addison-Wesley Professional, )十では、「メソッドの抽出」とい うリファクタリング手法が紹介されている。また、さまざまなリファクタリングカタログ も掲載されている。  ケント・ベツクの『Smalltalk Best Practice Pattemsl (Prentice Hall, )↑す では、「Composed Method」パターンが紹介されている。これは、小さな関数に分割す る原則をまとめたものだ。特に「メソッド内部の処理は同じ抽象度のレベルになるように します」の原則が大切だ。  これらの考えは、ぼくたちの「無関係の下位問題を抽出する」というアドバイスとよく  似ている。本章で説明したのは、メソッドを抽出する手法の一例だ。  ↑訳注『リファクタリングープログラムの体質改善テクニック』マーチン・ファウラー著、児玉公信、  平深章、友野晶夫、梅沢典史訳、ピアソンエデュケーション  ↑↑訳注『ケント・ベックのSmalltalkベストプラクティス・パターンーシンプル・デザインへの宝石集』  ケント・ベック著、梅沢真史、皆川誠、小黒直樹、森島みどり訳、ピアソンエデュケーション  *訳注訳書では「メソッド内部のメッセージは同じ抽象度のレベルになるようにします」になってい るけど、「メッセージ」ではなく「処理」または「操作」が妥当と思われる。原文は「Keep  all  of  the operations in a single method at the same level of abstraction.｣。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(155,1,154,'１４３\nʼ\n洲 章\n一度I司つのことを\n\n',' ʼ 洲 章 一度I司つのことを  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(156,1,155,'１４４１１１章一度に１つのことを\n\n一度に複数のことをするコードは理解しにくい。例えば、オブジェクトを生成し\nて、データをキレイにして、入力をパースして、ビジネスロジックを適用しているよ\nうなコードだ。これらのコードがすべて絡み合っていると、「タスク」が個別に完結\nしているコードよりも理解するのが難しい。\n\n(cid:20276)となる考え\nコードは１つずつタスクを行うようにしなければいけない緑\n\n別の言い方をすれば、本章はコードの「デフラグ」について説明している。以下の\n図は、デフラグの手Itmを示したものだ。左flには、さまざまなタスクを行なうコード\nを描いている。右側には、一度に１つのタスクを行うように再構成したコードを描\nいている。\n\n一度に複数の\n\nタスクを行うコード\n\n一度に１つの\n\nタスクを行うコード\n\n行されているさまざまなタスク\n\n■(cid:7767)幽=実\n\nL\ni\nne 1-4\n\nL\ni\nne 5-8\n\nL\ni\nne 9-12\n\nL\ni\nnei:ミ\n\n(cid:7767)(cid:106)識\n\nE 晶 写 … 露 (cid:7761) 緊一叩\n\n(cid:7767) (cid:106)\n\n[\nｐ\nー\n\nLine!\n\nL\ni\nne 2-4\n\nL\ni\nne 5-7\n\nL\ni\nne 8-10\n\n­\n\nL\ni\nne 11-15\n\n「関数は一度に１つのことを行うべきだ」というアドバイスを聞いたことがあるか\nもしれない。ぼくたちのアドバイスもこれと似ている。でも、関数に限った話じゃな\nい。もちろん、大きな関数は小さな複数の関数に分割したほうがいい。でも、関数の\nなかでコードを小さく椛成することもできる。例えば、論理的な区分に分けてあげる\nのだ。\n\n「一度に１つのタスクをする」ためにぼくたちが使っている手順を紹介しよう。\n\n','章一度につのことを  一度に複数のことをするコードは理解しにくい。例えば、オブジェクトを生成し て、データをキレイにして、入力をパースして、ビジネスロジックを適用しているよ うなコードだ。これらのコードがすべて絡み合っていると、「タスク」が個別に完結 しているコードよりも理解するのが難しい。  (cid:)となる考え コードはつずつタスクを行うようにしなければいけない緑  別の言い方をすれば、本章はコードの「デフラグ」について説明している。以下の 図は、デフラグの手Itmを示したものだ。左flには、さまざまなタスクを行なうコード を描いている。右側には、一度につのタスクを行うように再構成したコードを描 いている。  一度に複数の  タスクを行うコード  一度につの  タスクを行うコード  行されているさまざまなタスク  ■(cid:)幽=実  L i ne -  L i ne -  L i ne -  L i nei:ミ  (cid:)(cid:)識  E 晶 写 … 露 (cid:) 緊一叩  (cid:) (cid:)  [ ｐ ー  Line!  L i ne -  L i ne -  L i ne -  ­  L i ne -  「関数は一度につのことを行うべきだ」というアドバイスを聞いたことがあるか もしれない。ぼくたちのアドバイスもこれと似ている。でも、関数に限った話じゃな い。もちろん、大きな関数は小さな複数の関数に分割したほうがいい。でも、関数の なかでコードを小さく椛成することもできる。例えば、論理的な区分に分けてあげる のだ。  「一度につのタスクをする」ためにぼくたちが使っている手順を紹介しよう。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(157,1,156,'1川タスクは小さくできるʼ１４５\n\n1\n．\n\nコードが行っている「タスク」をすべて列挙する。この「タスク」という言\n葉はユル<使っている。「オブジェクトが妥当かどうかを確認する」のよう\nに小さなこともあれば、「ツリーのすべてのノードをイテレートする」のよ\nうにあいまいなこともある。\n\n2．タスクをできるだけ異なる関数に分割する。少なくとも異なる領域に分割す\n\nる\n。\n\n本章では、このための方法をいくつか紹介する。\n\n１１．１タスクは小さくできる\nブログに設置する投票用のウイジットがあるとする◎ユーザは「アップ（賛成)」\nと「ダウン（反対)」を投票できる。scoreは、すべての投票を合計したものである。\n｢アップ」は１点で、「ダウン」は-1点だ。\n\nユーザの投票には３つの状態がある。これらがscoreに与える影響を見てみよう。\n\n \"Down\'？』\n\n△=\n\nvote\n\ntotal  score  =  4\n\n△\n岬\n▽\n\n０Ｖ\n\n“ ，\n\ntotal  score  =  5\n\n曇\n､\nvote = \"Up\'▽\n\ntotal  score  =  6\n\nユーザが（投票や更新のために）ボタンをクリックしたら、以下のJavaScriptが\n\n呼び出される。\n\nvote changed(old vote, new vote); //投票はⅢUp\"・\'\'Down\'\'・\'\'11のいずれか\n\n以下の関数は、old  voteとnew  voteのすべての組み合わせを考慮して、scoreを\n\n更新している。\n\nvar vote changed = function (old vote, neItf vote) {\n\nvar score = get_score();\ni\nf (new vote !== old vote)\n\n','川タスクは小さくできるʼ     コードが行っている「タスク」をすべて列挙する。この「タスク」という言 葉はユル<使っている。「オブジェクトが妥当かどうかを確認する」のよう に小さなこともあれば、「ツリーのすべてのノードをイテレートする」のよ うにあいまいなこともある。  タスクをできるだけ異なる関数に分割する。少なくとも異なる領域に分割す  る 。  本章では、このための方法をいくつか紹介する。  タスクは小さくできる ブログに設置する投票用のウイジットがあるとする◎ユーザは「アップ賛成)」 と「ダウン反対)」を投票できる。scoreは、すべての投票を合計したものである。 ｢アップ」は点で、「ダウン」は-点だ。  ユーザの投票にはつの状態がある。これらがscoreに与える影響を見てみよう。   \"Down\'』  △=  vote  total  score  =    △ 岬 ▽  Ｖ  “   total  score  =    曇 ､ vote = \"Up\'▽  total  score  =    ユーザが投票や更新のためにボタンをクリックしたら、以下のJavaScriptが  呼び出される。  vote changed(old vote, new vote); //投票はⅢUp\"・\'\'Down\'\'・\'\'のいずれか  以下の関数は、old  voteとnew  voteのすべての組み合わせを考慮して、scoreを  更新している。  var vote changed = function (old vote, neItf vote) {  var score = get_score(); i f (new vote !== old vote)  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(158,1,157,'Ｉ\n\n短いコードだけど、いろんなことをやっている。難しいところがたくさんあるの\n\nで、エラーやタイポやバグがあっても一目見ただけではわからない。\n\nこのコードはたった１つのこと（スコアを更新すること）をしているように見え\n\nて、実際には一度に２つのタスクを行っている。\n\n１．old voteとnew voteを数値に「パース」する。\n\n■ ■ ■ ■\n\nー\n\n2.   scoreを更新する。\n\n２つのタスクを別々に解決すれば、読みやすいコードになる。以下のコードは、最\n\n初のタスク（投票を数値にパースする）を解決したものである。\n\ni\nf (new vote === \'Up\') {\n\nscore＋＝(old-vote＝=＝!Downʼ？Z：１)ｊ\nscore-＝(o1d-vote＝＝\'Up！？２：１)ｊ\nscore+＝(old-vote==＝\'Upʼ？-１：１)；\n\n} else if (new vote === \'Down\') {\n} else if (new vote === \") {\n｝\n\net score(score);\n\n｝ s\n\n１４６１１１章一度に１つのことを\n\nりのコードは、２つめのタスク（スコアの更新）を解決している。\n\nvar vote_changed = function (old_vote, new_vote) {\n\nvar score = get score();\n\n； 残\n\n}\n\nvar vote value = function (vote) {\n\nif (vote === \'Up\') {\n\nreturn +l;\n\nf (vote === \'Down\') {\n\nreturn -l;\n\neturn 0;\n\n｝i\n\n｝r\n\n','Ｉ  短いコードだけど、いろんなことをやっている。難しいところがたくさんあるの  で、エラーやタイポやバグがあっても一目見ただけではわからない。  このコードはたったつのことスコアを更新することをしているように見え  て、実際には一度につのタスクを行っている。  old voteとnew voteを数値に「パース」する。  ■ ■ ■ ■  ー  .   scoreを更新する。  つのタスクを別々に解決すれば、読みやすいコードになる。以下のコードは、最  初のタスク投票を数値にパースするを解決したものである。  i f (new vote === \'Up\') {  score(old-vote=!DownʼZ)ｊ score-(od-vote\'Up)ｊ score+(old-vote==\'Upʼ-)  } else if (new vote === \'Down\') { } else if (new vote === \") { ｝  et score(score);  ｝ s  章一度につのことを  りのコードは、つめのタスクスコアの更新を解決している。  var vote_changed = function (old_vote, new_vote) {  var score = get score();   残  }  var vote value = function (vote) {  if (vote === \'Up\') {  return +l;  f (vote === \'Down\') {  return -l;  eturn ;  ｝i  ｝r  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(159,1,158,'１１２オブジェクトから値を抽出するʼ１４？\n\nscore -= vote value(old vote);   //古い値を削除する\nscore += vote valuefnew vote):    //新しい値を追加する\nset score(score);\n\n新しいコードは、一目見ただけで正しく動きそうだ。これがコードを「楽に理解で\n\nきる」ようにすることである。\n\n１１．２オブジェクトから値を抽出する\n以前、ユーザの所在地を読みやすい文字列（｢都市，国｣）に整形するJavaScriptの\nコードを書いたことがある。例えば、「Santa Monica, USA」や「Paris, France」の\nような感じだ。location  infoディクショナリに構造化された情報があって、そこか\nらすべてのフィールドの「都市」と「国」を選んで連結するのである。\n\n以下は、入出力の例を示したものだ。\n\nlocation  info\n\nLocalityNarm\n\nSubAdministrativeAreaNam\nAdministrativeAreaNarra\n・悪蝿稔CountryName\n\n\"Santa Monica\'\n\"Los Angeles\n\"\nCaliforn旧〃；\n\n蝋\"USA\"(cid:7767)：\n\nＵ\"Santa Monica, USA\"\n\nここまでは簡単だ。ややこしいのは、この４つの値のいずれかが（あるいはすべ\n\nてが）存在しない可能性があることだ。以下に対応策を示そう。\n\n｢都市」を選ぶときには、「LocalityNameJ  (市や町）→「SubAdministrative\nAreaNameJ (都市や郡）→「AdministrativeAreaNameJ   (州や地域）の順\n番で使川可能なものを使う。\n\n●以上の３つすべてが使えない場合は、「都市」に「Middle-of-NowhereJ    (何\n\nでもない場所）というデフォルト値を設定する。\n\n','オブジェクトから値を抽出するʼ  score -= vote value(old vote);   //古い値を削除する score += vote valuefnew vote):    //新しい値を追加する set score(score);  新しいコードは、一目見ただけで正しく動きそうだ。これがコードを「楽に理解で  きる」ようにすることである。  オブジェクトから値を抽出する 以前、ユーザの所在地を読みやすい文字列｢都市国｣に整形するJavaScriptの コードを書いたことがある。例えば、「Santa Monica, USA」や「Paris, France」の ような感じだ。location  infoディクショナリに構造化された情報があって、そこか らすべてのフィールドの「都市」と「国」を選んで連結するのである。  以下は、入出力の例を示したものだ。  location  info  LocalityNarm  SubAdministrativeAreaNam AdministrativeAreaNarra ・悪蝿稔CountryName  \"Santa Monica\' \"Los Angeles \" Californ旧〃  蝋\"USA\"(cid:)  Ｕ\"Santa Monica, USA\"  ここまでは簡単だ。ややこしいのは、このつの値のいずれかがあるいはすべ  てが存在しない可能性があることだ。以下に対応策を示そう。  ｢都市」を選ぶときには、「LocalityNameJ  (市や町→「SubAdministrative AreaNameJ (都市や郡→「AdministrativeAreaNameJ   (州や地域の順 番で使川可能なものを使う。  ●以上のつすべてが使えない場合は、「都市」に「Middle-of-NowhereJ    (何  でもない場所というデフォルト値を設定する。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(160,1,159,'１４８１１１１章一度に１つのことを\n\n●「国」に「CountryNameJ   (国名）が使えない場合は、「Planet EarthJ   (地\n\n球）というデフォルI､値を設定する。\n\n以下の図は、値がないときの対処法の例だ\n\nLocalityNanne\n\nlocation  info\n(\nunde伽ed)\n(undeﬁned)\n(\nundeﬁned\n\"Canad.\n\nSubAdministrativeAreaName\nAdminlstrativeAreaName\n\nCountryName\n\n４\"Middle-of-Nowhere, Canada\"\n\nこのタスクを実装したコードが以下になる：\n\nLocalityName\n\nlocation  info\nundeﬁned\n(\nWashington, D\n\'\nundeﬁned\n\"\nUSA\n\nSubAdministrativeAreaNam!\nAdministratlveAreaNami\n\nCountryNam\n\nａ\"Washington, DC, USA\"\n\nvar place = location inforLocalityName\"];   //例: \"Santa Monica\"\nif (Iplace) {\n\np\nl\nace = location_info[\"SubAdministrativeAreaName\"];   //例: \"Los Angeles\"\n\np\nl\nace = location info[\"AdministrativeAreaName\"]; //例: \"California\"\n\nif (Iplace) {\n\nf (Iplace) {\n\np\nl\nace = \"Middle-of-Nowhere\";\n\nf (location info[\"CoiintryName\"]) {\n\n１\nＪ\n\n１ノi\n\nｌｊi\n\nlJ r\n\neturn place;\n\nplace += \", \" + location infof\"CountryName\"]; //例: \"USA\"\n\n} else {\n\nplace += \", Planet Earth\";\n\nひどいコードなのはわかってるけど、これでもちゃんと動く。\n数日後、機能を追加することになった。アメリカの場合は、国名ではなく（可能で\nあれば）州名を表示するそうだ。例えば、「Santa Monica, USA」は「Santa Monica,\n\n','章一度につのことを  ●「国」に「CountryNameJ   (国名が使えない場合は、「Planet EarthJ   (地  球というデフォルI､値を設定する。  以下の図は、値がないときの対処法の例だ  LocalityNanne  location  info ( unde伽ed) (undeﬁned) ( undeﬁned \"Canad.  SubAdministrativeAreaName AdminlstrativeAreaName  CountryName  \"Middle-of-Nowhere, Canada\"  このタスクを実装したコードが以下になる  LocalityName  location  info undeﬁned ( Washington, D \' undeﬁned \" USA  SubAdministrativeAreaNam! AdministratlveAreaNami  CountryNam  ａ\"Washington, DC, USA\"  var place = location inforLocalityName\"];   //例: \"Santa Monica\" if (Iplace) {  p l ace = location_info[\"SubAdministrativeAreaName\"];   //例: \"Los Angeles\"  p l ace = location info[\"AdministrativeAreaName\"]; //例: \"California\"  if (Iplace) {  f (Iplace) {  p l ace = \"Middle-of-Nowhere\";  f (location info[\"CoiintryName\"]) {   Ｊ  ノi  ｌｊi  lJ r  eturn place;  place += \", \" + location infof\"CountryName\"]; //例: \"USA\"  } else {  place += \", Planet Earth\";  ひどいコードなのはわかってるけど、これでもちゃんと動く。 数日後、機能を追加することになった。アメリカの場合は、国名ではなく可能で あれば州名を表示するそうだ。例えば、「Santa Monica, USA」は「Santa Monica,  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(161,1,160,'１１．２オブジエクトから値を抽出するʼ１４９\n\nCalifornia」になるわけだ。\n\n先ほどのコードにこの機能を追加したら、もっとひどいコードになるだろう。\n\n｢ 一 度 に １ つ の タ ス ク 」 を 適 用 す る\n\nコードを変更する前に、このコードが一度に複数のタスクを行っていることに気づ\n\nいただろう。\n\n1.  location  infoディクショナリから値を抽出する。\n\nｌ■■■■\n\n2．「都市」の優先順位を調べる。何も見つからなかったら、デフォルトで\n\n「Middle-of-Nowhere」にする。\n\n3．「国」を取得する。\n\nなければ「Planet Earth」にする。\n\n4.    placeを更新する。\n\nこれらのタスクを個別に解決するようなコードに書き換えよう。\n最初のタスク(location  infoから値を抽出）は、そのままでいいだろう。\n\n■■■■\n\n\"Santa Monica\n\"Los Angeles\"\n\"CA\"\n\"USA\"\n\n例例例例\n\nノ ノ ノ ノ\nノ ノ ノ ノ\n\n= location infof\"LocalityName\"];\n= location infof SubAdministrativeAreaName\"];\n= location infof\"Adm加strativeAreaName\"];\n= location infof\"CountryName\"];\n\nvar town\nvar  city\nvar state\nvar country\n\nこれでlocation  infoがなくなって、長くて直感的ではないキーを覚える必要がな\n\nくなった。これからは４つの簡潔な変数を扱えばいい。\n次に、戻り値の「後半」を見つけなければいけない。\n\n/／先にデフォルト値を設定して、値が見つかったら書き換える。\nvar second half = \"Planet Earth\";\nif (country) {\n\nsecond half = country;\n\n (state && country === \"USA\") {\n\nsecond half = state;\n\n｝if\n\n｝\n\n','オブジエクトから値を抽出するʼ  California」になるわけだ。  先ほどのコードにこの機能を追加したら、もっとひどいコードになるだろう。  ｢ 一 度 に  つ の タ ス ク 」 を 適 用 す る  コードを変更する前に、このコードが一度に複数のタスクを行っていることに気づ  いただろう。  .  location  infoディクショナリから値を抽出する。  ｌ■■■■  「都市」の優先順位を調べる。何も見つからなかったら、デフォルトで  「Middle-of-Nowhere」にする。  「国」を取得する。  なければ「Planet Earth」にする。  .    placeを更新する。  これらのタスクを個別に解決するようなコードに書き換えよう。 最初のタスク(location  infoから値を抽出は、そのままでいいだろう。  ■■■■  \"Santa Monica \"Los Angeles\" \"CA\" \"USA\"  例例例例  ノ ノ ノ ノ ノ ノ ノ ノ  = location infof\"LocalityName\"]; = location infof SubAdministrativeAreaName\"]; = location infof\"Adm加strativeAreaName\"]; = location infof\"CountryName\"];  var town var  city var state var country  これでlocation  infoがなくなって、長くて直感的ではないキーを覚える必要がな  くなった。これからはつの簡潔な変数を扱えばいい。 次に、戻り値の「後半」を見つけなければいけない。  /先にデフォルト値を設定して、値が見つかったら書き換える。 var second half = \"Planet Earth\"; if (country) {  second half = country;   (state && country === \"USA\") {  second half = state;  ｝if  ｝  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(162,1,161,'return  ﬁrstjialf  +  \",  \"  +  second  half;\n\n最初に示した「デフラグ」の図は、実はこのコードを表したものだった。以下に\n\nもっと詳細なものを示そう。\n\n■\na\no\nc\n^\nl\no\nt\ni\nn infoから値を抽出す愚\n口\n=\n｢\n都市｣の部分を作る\nロー｢国｣の部分を作る\nc\na\n画\ni\np\nl\nを更新する\ne\n\n一度に1つの\nタスクを行う\n\nL\ni\nne 1-4\n\n一\n\nL\ni\nne 5-8\n\n調 繊 Ⅷ\n\nL\ni\nne 9-12\n\njnel3\n\n元のコー夢\n\n理\n\n一 無\n\n心\n垂\n帝\n．\n母\n一\n\nLine!\n\nL\ni\nne 2-4\n\nL\ni\nne 5-7\n\n一\n\n▲\n\n二\n\nL\ni\nne 8-10\n\n爵(cid:20291)識\n\n副 “ X L 『 鴨 i 韓 群 詩 昭 蹄\n\n窮歯型\n鐸\n\n­\n\n.\ni\nne 11-15\n\n《\n鵜\n賎\n：\n\nご覧のように、解決策のコードでは、４つのタスクが別々の領域にデフラグされて\n\nいる。\n\n150 I   11章一度に１つのことを\n\n|司じようにして「前半」を見つけることができる露\n\nvar ﬁrst half = \"Middle-of-Nowhere\";\nif (state m country !== \"USA\") {\n\nﬁrst half = state;\n\nf (city) {\n\nﬁrstjialf = city;\n\nf (town) {\n\nﬁrst half = town;\n\n後に情報をつなぎ合わせる。\n\nｌｊi\n\nＪi\n\nｌ\n\n｝ 最\n\n','return  ﬁrstjialf  +  \",  \"  +  second  half;  最初に示した「デフラグ」の図は、実はこのコードを表したものだった。以下に  もっと詳細なものを示そう。  ■ a o c ^ l o t i n infoから値を抽出す愚 口 = ｢ 都市｣の部分を作る ロー｢国｣の部分を作る c a 画 i p l を更新する e  一度につの タスクを行う  L i ne -  一  L i ne -  調 繊 Ⅷ  L i ne -  jnel  元のコー夢  理  一 無  心 垂 帝  母 一  Line!  L i ne -  L i ne -  一  ▲  二  L i ne -  爵(cid:)識  副 “ X L 『 鴨 i 韓 群 詩 昭 蹄  窮歯型 鐸  ­  . i ne -  《 鵜 賎   ご覧のように、解決策のコードでは、つのタスクが別々の領域にデフラグされて  いる。   I   章一度につのことを  |司じようにして「前半」を見つけることができる露  var ﬁrst half = \"Middle-of-Nowhere\"; if (state m country !== \"USA\") {  ﬁrst half = state;  f (city) {  ﬁrstjialf = city;  f (town) {  ﬁrst half = town;  後に情報をつなぎ合わせる。  ｌｊi  Ｊi  ｌ  ｝ 最  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(163,1,162,'１１３もつと大きな例ʼ１５１\n\nその他の手法\n\nコードをリファクタリングするときには、複数の手法が使えることが多い。今回\nも例外ではない。タスクを分割すると、コードのことを考えやすくなる。その結果、\nもっとうまくリファクタリングできる方法を思いつく可能ʻ性がある。\n\n例えば、if文が連続していると、すべての場合分けを注意深く読まなければいけ\n\nない。このコードには２つのサブタスクがある。\n\n複数の変数を調べて、最も適したものを選択する。\n\n１．国が「USA」ならば、別の変数を使う。\n\n2．先ほどのコードには「if USA」のロジックが他のロジックと混ざっていた。\n\n「USA」と「非USA」は別々に処理できる。\n\nJavaScriptに詳しくない人のために説明すると、a II b      cは、最初に「真」と\n評価できる値（ここでは定義された空ではない文字列）を取り出すイディオムだ。こ\nれで検査や更新の処理が簡潔になった。if文が少なくなって、ビジネスロジックを\n扱うコードも短くなった。\n１１．３もつと大きな例\nぼくたちが作ったウェブクローリングシステムがある。UpdateCounts()はさまざ\nまな統計値を更新する関数だ。ウェブページをダウンロードしたあとに毎回呼ばれる\nことになっている。\n\nvar ﬁrst half, second half;\ni\nf (country === \"USA\") {\n\n} else {\n\nﬁrst half = town 11 city || \"Middle-of-Nowhere\";\nsecond half = state 11 \"USA\";\nﬁrst half = town 11 city || state || \"Middle-of-Nowhere\";\nsecond half = country || \"Planet Earth\";\n\neturn ﬁrst half + \", \" + second half;\n\n｝ r\n\n','もつと大きな例ʼ  その他の手法  コードをリファクタリングするときには、複数の手法が使えることが多い。今回 も例外ではない。タスクを分割すると、コードのことを考えやすくなる。その結果、 もっとうまくリファクタリングできる方法を思いつく可能ʻ性がある。  例えば、if文が連続していると、すべての場合分けを注意深く読まなければいけ  ない。このコードにはつのサブタスクがある。  複数の変数を調べて、最も適したものを選択する。  国が「USA」ならば、別の変数を使う。  先ほどのコードには「if USA」のロジックが他のロジックと混ざっていた。  「USA」と「非USA」は別々に処理できる。  JavaScriptに詳しくない人のために説明すると、a II b      cは、最初に「真」と 評価できる値ここでは定義された空ではない文字列を取り出すイディオムだ。こ れで検査や更新の処理が簡潔になった。if文が少なくなって、ビジネスロジックを 扱うコードも短くなった。 もつと大きな例 ぼくたちが作ったウェブクローリングシステムがある。UpdateCounts()はさまざ まな統計値を更新する関数だ。ウェブページをダウンロードしたあとに毎回呼ばれる ことになっている。  var ﬁrst half, second half; i f (country === \"USA\") {  } else {  ﬁrst half = town  city || \"Middle-of-Nowhere\"; second half = state  \"USA\"; ﬁrst half = town  city || state || \"Middle-of-Nowhere\"; second half = country || \"Planet Earth\";  eturn ﬁrst half + \", \" + second half;  ｝ r  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(164,1,163,'\"SUCCESS\" or \"FAILURE\"\n\"404 NOT FOUND\"\n\"text/html\"\n\n例例例\n\nノ ノ ノ\nノ ノ ノ\n\ncountsf\'Exit State\"     ][hd・exit state()]++;\ncountsf\'Http Response\"][hd.http response()]++;\ncounts[\"Content-Type\" ][hd・content type()]++;\n\n｝\nまだ、こんなふうになったらいいなと思っている段階だ！\n実際のHttpDownloadオブジェクトには、上記のようなメソッドはない。HttpDown\nloadは巨大で複雑なクラスになっていて、ネストしたクラスもたくさん入っている。\n必要な値は自分で探さなければいけない。しかも、値がどこかへ消えてしまっている\nこともある。そういう場合は、デフォルト値に「unknown」を使うことにしよう。\n\nvoid UpdateCounts(HttpDownload hd) {\n\nというわけで、すごく汚いコードになった。\n\n１５２１１１章一度に１つのことを\n\n/／警告：このコードを長時間直視しないでください。\nvoid UpdateCounts(HttpDownload hd) {\n\n／／可能であればExit Stateを見つける。\nif (!hd.has_event_log() || !hd・event_log().has exit stateQ) {\n\n} else {\n\ncounts[\"Exit State\"][\"unknown\"]++;\nstring state_str = ExitStateTypeName(hd・event_log().exit stateQ);\ncountsf\'Exit State\"][state-str]++;\n\n/ HTTPヘッダがなければ、残りの要素に\"unknownⅢを設定する。\nif (Ihd.has http headersQ) {\n\ncounts[\"Http Response\"][\"unknown\"]++;\ncounts[\"Content-Type\"][\"unknown\"]++;\nreturn;\n\nttpHeaders headers = hd.http headersQ;\n\n// HTTPレスポンスをログに記録する。なければ\"unknown\"と記録する。\nf (!headers.hasjresponse codeQ) {\ni\ncounts[\"Http Response\"][\"unknown\"]++;\ne\nl\nse {\nstring code = StringPrintf(\"%d\", headers.response codeQ);\ncountsf\'Http Response\"][code]++;\n\n｝ /\n\n｝ H\n\n','\"SUCCESS\" or \"FAILURE\" \" NOT FOUND\" \"text/html\"  例例例  ノ ノ ノ ノ ノ ノ  countsf\'Exit State\"     ][hd・exit state()]++; countsf\'Http Response\"][hd.http response()]++; counts[\"Content-Type\" ][hd・content type()]++;  ｝ まだ、こんなふうになったらいいなと思っている段階だ 実際のHttpDownloadオブジェクトには、上記のようなメソッドはない。HttpDown loadは巨大で複雑なクラスになっていて、ネストしたクラスもたくさん入っている。 必要な値は自分で探さなければいけない。しかも、値がどこかへ消えてしまっている こともある。そういう場合は、デフォルト値に「unknown」を使うことにしよう。  void UpdateCounts(HttpDownload hd) {  というわけで、すごく汚いコードになった。  章一度につのことを  /警告このコードを長時間直視しないでください。 void UpdateCounts(HttpDownload hd) {  可能であればExit Stateを見つける。 if (!hd.has_event_log() || !hd・event_log().has exit stateQ) {  } else {  counts[\"Exit State\"][\"unknown\"]++; string state_str = ExitStateTypeName(hd・event_log().exit stateQ); countsf\'Exit State\"][state-str]++;  / HTTPヘッダがなければ、残りの要素に\"unknownⅢを設定する。 if (Ihd.has http headersQ) {  counts[\"Http Response\"][\"unknown\"]++; counts[\"Content-Type\"][\"unknown\"]++; return;  ttpHeaders headers = hd.http headersQ;  // HTTPレスポンスをログに記録する。なければ\"unknown\"と記録する。 f (!headers.hasjresponse codeQ) { i counts[\"Http Response\"][\"unknown\"]++; e l se { string code = StringPrintf(\"%d\", headers.response codeQ); countsf\'Http Response\"][code]++;  ｝ /  ｝ H  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(165,1,164,'１１３もつと大きな例１53\n\n// Content-Typeをログに記録する。なければⅢunknown\"と記録する。\ni\nf (Iheaders.has content typeQ) {\ncounts[\"Content-Type\"][\"unknown\"]++;\nse\ne\nl\nstring contentjtype = ContentTypeMime(headers.content typeQ);\ncounts[\"Content-Type\"][content type]++;\n\n｝\n\n大量のコードだ。ロジックもいっぱい。重複コードだってある。読んでて楽しくな\n\nいｏ\n\nこのコードは、複数のタスクを交互に切り替えている。タスクには以下のようなも\n\nのがある。\n\n1．キーのデフォルト値に「unknown」を使う。\n\n2. HttpDownloadのメンバがあるかどうかを確認する。\n\n３．値を抽出して文字列に変換する。\n\n4.    counts[1を更新する。\n\nこのコードを改善するには、タスクを別々の領域に分割すればいい。\n\nvoid UpdateCounts(HttpDownload hd) {\n\n／／タスク：抽出したい値にデフォルト値を設定する。\nstring exit state = \"unknown\";\nstring http response = \"unknown\";\nstring contentjtype = \"unknown\";\n\n/／タスク: HttpDownloadから値を１つずつ抽出する。\ni\nf (hd・has event logQ && hd.event_log().has_exit_state()) {\n\nexit state = ExitStateTypeName(hd.event log().exit_state());\n\n (hd.has http headersQ && hd.http_headers().has_response_code()) {\n\nhttp response = StringPrintf(\"%d\", hd.http headersQ.response codeQ);\n\n (hd・has http headersQ && hd.http headers().has_content_type()) {\ncontent type = ContentTypeMime(hd.http headersQ.contentjtypeQ);\n｝\n\n｝if\n\n｝if\n\n','もつと大きな例  // Content-Typeをログに記録する。なければⅢunknown\"と記録する。 i f (Iheaders.has content typeQ) { counts[\"Content-Type\"][\"unknown\"]++; se e l string contentjtype = ContentTypeMime(headers.content typeQ); counts[\"Content-Type\"][content type]++;  ｝  大量のコードだ。ロジックもいっぱい。重複コードだってある。読んでて楽しくな  いｏ  このコードは、複数のタスクを交互に切り替えている。タスクには以下のようなも  のがある。  キーのデフォルト値に「unknown」を使う。  . HttpDownloadのメンバがあるかどうかを確認する。  値を抽出して文字列に変換する。  .    counts[を更新する。  このコードを改善するには、タスクを別々の領域に分割すればいい。  void UpdateCounts(HttpDownload hd) {  タスク抽出したい値にデフォルト値を設定する。 string exit state = \"unknown\"; string http response = \"unknown\"; string contentjtype = \"unknown\";  /タスク: HttpDownloadから値をつずつ抽出する。 i f (hd・has event logQ && hd.event_log().has_exit_state()) {  exit state = ExitStateTypeName(hd.event log().exit_state());   (hd.has http headersQ && hd.http_headers().has_response_code()) {  http response = StringPrintf(\"%d\", hd.http headersQ.response codeQ);   (hd・has http headersQ && hd.http headers().has_content_type()) { content type = ContentTypeMime(hd.http headersQ.contentjtypeQ); ｝  ｝if  ｝if  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(166,1,165,'１．３つのキーのデフオルト値を定義する。\n2．可能であれば、キーの値を抽出して文字列に変換する。\n\n3．キーのcounts[]を更新する。\n\n領域に分けておくといいのは、それぞれが分離されているからだ。ある領域にいる\n\nときは、他の領域のことは考えなくて済む。\n\nタスクは４つあったのに、領域は３つに分かれている。でも、これでいい。最初\nに挙げたタスクは出発点にすぎない。ここでやったように、そこからいくつかに分割\nできれば、それでいいのだ。\n\nさ ら な る 改 善\n\n新しいバージョンのコードは、元の巨大怪物から大きく改善されたものになった。\nでも、新しい関数は作らなかった。前にも言ったように、「一度に１つのこと」は関\n数に限った話ではない。\n\n他にもこのコードを改善する方法はある。３つのヘルパー関数を導入するのだ。\n\n／／タスク: counts[]を更新する。\ncounts[\"Exit State\"][exit state]++;\ncounts[\"Http Response\"][http response]++;\ncounts[\"Content-Type\"][content type]++;\n\nのコードには目的を持った３つの領域がある。\n\n｝ こ\n\n１５４１１１章一度に１つのことを\n\nれらの関数は、対応する値を抽出して、もしなければ「unknown」を返すもの\n\nvoid UpdateCounts(HttpDownload hd) {\n\ncounts[\"Exit State\"][ExitState(hd)]++;\ncounts[\"Http Response\"][HttpResponse(hd)]++;\ncounts[\"Content-Type\"][ContentType(hd)]++;\n\n｝ こ\n\nだ\n。\n\n','つのキーのデフオルト値を定義する。 可能であれば、キーの値を抽出して文字列に変換する。  キーのcounts[]を更新する。  領域に分けておくといいのは、それぞれが分離されているからだ。ある領域にいる  ときは、他の領域のことは考えなくて済む。  タスクはつあったのに、領域はつに分かれている。でも、これでいい。最初 に挙げたタスクは出発点にすぎない。ここでやったように、そこからいくつかに分割 できれば、それでいいのだ。  さ ら な る 改 善  新しいバージョンのコードは、元の巨大怪物から大きく改善されたものになった。 でも、新しい関数は作らなかった。前にも言ったように、「一度につのこと」は関 数に限った話ではない。  他にもこのコードを改善する方法はある。つのヘルパー関数を導入するのだ。  タスク: counts[]を更新する。 counts[\"Exit State\"][exit state]++; counts[\"Http Response\"][http response]++; counts[\"Content-Type\"][content type]++;  のコードには目的を持ったつの領域がある。  ｝ こ  章一度につのことを  れらの関数は、対応する値を抽出して、もしなければ「unknown」を返すもの  void UpdateCounts(HttpDownload hd) {  counts[\"Exit State\"][ExitState(hd)]++; counts[\"Http Response\"][HttpResponse(hd)]++; counts[\"Content-Type\"][ContentType(hd)]++;  ｝ こ  だ 。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(167,1,166,'１１４まとめʼ１５５\n\nの解決策では、変数の定義すらしていない！「９章変数と読みやすさ」で言っ\n\nたように、中間結果を保持する変数は削除できることが多い。\n\n２つの解決策は、問題を異なる方向に「スライス」している。どちらの解決策も読\n\nみやすく、一度に１つのタスクのことだけを考えられるようになっている。\n\n１１．４まとめ\n本章では、コードを構成する簡単な技法「一度に１つのタスクを行う」を紹介し\n。\nた\n読みにくいコードがあれば、そこで行われているタスクをすべて列挙する。そこに\nは別の関数（やクラス）に分割できるタスクがあるだろう。それ以外は、関数の論理\n的な「段落」になる。タスクをどのように分割するかよりも、分割するということが\n大切なのだ。いちばん難しいのは、プログラムが行っていることを正確に説明するこ\nとである。\n\n｝\n\n｝ こ\n\nstring ExitState(HttpDownload hd) {\n\nif (hd.has event logQ && hd.event logQ.has exit stateQ) {\nreturn ExitStateTypeName(hd.event logQ.exit stateQ);\nse\ne\nl\nreturn \"unknown\";\n\n','まとめʼ  の解決策では、変数の定義すらしていない「章変数と読みやすさ」で言っ  たように、中間結果を保持する変数は削除できることが多い。  つの解決策は、問題を異なる方向に「スライス」している。どちらの解決策も読  みやすく、一度につのタスクのことだけを考えられるようになっている。  まとめ 本章では、コードを構成する簡単な技法「一度につのタスクを行う」を紹介し 。 た 読みにくいコードがあれば、そこで行われているタスクをすべて列挙する。そこに は別の関数やクラスに分割できるタスクがあるだろう。それ以外は、関数の論理 的な「段落」になる。タスクをどのように分割するかよりも、分割するということが 大切なのだ。いちばん難しいのは、プログラムが行っていることを正確に説明するこ とである。  ｝  ｝ こ  string ExitState(HttpDownload hd) {  if (hd.has event logQ && hd.event logQ.has exit stateQ) { return ExitStateTypeName(hd.event logQ.exit stateQ); se e l return \"unknown\";  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(168,1,167,'\'\n１５７\n\n増憲章\nコードに思いを込める\n\n２\n\n○\n○\n\nく＞\n\n○\n＄Ｆｂｊ頓\n○\nｉ【Ｉ\n動(cid:7665)⑤ ③\nﾖｰＺｐ〉ノ\n\nｒ­１\n\nｰ … ＝\n\n、 、 、\n\n','\'   増憲章 コードに思いを込める    ○ ○  く  ○ Ｆｂｊ頓 ○ ｉ【Ｉ 動(cid:)⑤ ③ ﾖｰＺｐ〉ノ  ｒ­  ｰ …   、 、 、  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(169,1,168,'158      1２章コードに思いを込める\n\nおばあちゃんがわかるように説明できなければ、本当に理解したとは言えない。\n­アルバート・アインシュタイン\n\n誰かに複雑な考えを伝えるときには、細かいことまで話しすぎると相手を混乱させ\nてしまう。自分よりも知識が少ない人が理解できるような「簡単な言葉」で説明する\n能力が大切だ。自分の考えを凝縮して、最も大切な概念にすることが必要になる。こ\nれは誰かに理解してもらうだけでなく、自分の考えをより明確にすることにもなる。\nコードを読み手に「プレゼント」するときにも、これと同じ能力を使うべきだ。\nソースコードというのは、プログラムの動作を説明する最も大切な手段だとぼくたち\nは考えている。つまり、コードも「簡単な言葉で」書くべきなのだ。\n\n本章では、コードをより明確にする簡単な手順を使う。\n\n1．コードの動作を簡単な言葉で同僚にもわかるように説明する。\n\n2．その説明のなかで使っているキーワードやフレーズに注目する。\n\n3．その説明に合わせてコードを書く。\n\n１２．１ロジックを明確に説明する\n以下は、あるウェブページから取ってきたPHPのコードの一部である。セキュア\nページを扱うコードの最上部にあったものだ。ユーザにページを閲覧する権限がある\nかどうかを確認して、もし権限がなければ、権限がないことをユーザに知らせるペー\nジに戻す。\n\nreturn not authorized();\n\ni\nf (!$is_admin && ($document[\'username\'] != $ SESSION[\'username\'])) {\n｝\ne\nl\nse {\nif (!$is admin) {\n｝\n\nreturn not authorized();\n\n$\ni\ns admin = is admin request();\ni\nf ($document) {\n\n／引き続きページのレンダリング\n\n｝ /\n\n','      章コードに思いを込める  おばあちゃんがわかるように説明できなければ、本当に理解したとは言えない。 ­アルバート・アインシュタイン  誰かに複雑な考えを伝えるときには、細かいことまで話しすぎると相手を混乱させ てしまう。自分よりも知識が少ない人が理解できるような「簡単な言葉」で説明する 能力が大切だ。自分の考えを凝縮して、最も大切な概念にすることが必要になる。こ れは誰かに理解してもらうだけでなく、自分の考えをより明確にすることにもなる。 コードを読み手に「プレゼント」するときにも、これと同じ能力を使うべきだ。 ソースコードというのは、プログラムの動作を説明する最も大切な手段だとぼくたち は考えている。つまり、コードも「簡単な言葉で」書くべきなのだ。  本章では、コードをより明確にする簡単な手順を使う。  コードの動作を簡単な言葉で同僚にもわかるように説明する。  その説明のなかで使っているキーワードやフレーズに注目する。  その説明に合わせてコードを書く。  ロジックを明確に説明する 以下は、あるウェブページから取ってきたPHPのコードの一部である。セキュア ページを扱うコードの最上部にあったものだ。ユーザにページを閲覧する権限がある かどうかを確認して、もし権限がなければ、権限がないことをユーザに知らせるペー ジに戻す。  return not authorized();  i f (!$is_admin && ($document[\'username\'] != $ SESSION[\'username\'])) { ｝ e l se { if (!$is admin) { ｝  return not authorized();  $ i s admin = is admin request(); i f ($document) {  引き続きページのレンダリング  ｝ /  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(170,1,169,'１２２ライブラリを知るʼ１５９\n\nこのコードにはロジックがたくさんある。第Ⅱ部でも見たように、大きなロジック\nツリーは理解するのが難しい。このロジックはもっと単純化できるだろう。でも、ど\nうやって？簡単な言葉でロジックを説明してみよう。\n\n権限があるのは、以下の２つ。\n1）管理者\n2）文書の所有者(文書がある場合）\nその他は、権限がない。\n\nこの説明から新しい解決策を思いついた。\n\nこのバージョンは少し変だ。if文の中身が２つも空になっている。でも、コードは\n小さくなったし、ロジックも単純になった。否定形がなくなったからだ（以前は「!」\nが３つもあった)。つまり、こちらのほうが理解しやすい。\n\n１２．２ライブラリを知る\n以下のようなユーザの助けになる「ヒント」を表示するウェブサイトを持っていた\n\nことがある。\n\nヒント：過去のクエリを見るにはログインしてください。［その他のヒントを見る！：\n\nヒントは数十個ほどあって、すべてHTMLに隠してあった。\n\n<div  id=\"tip-l\"  class=\"tip\">ヒント：過去のクエリを見るにはログインしてください。</div>\n<div  id=\"tip-2\"  class=\"tip\">ヒント：拡大するには画像をクリックしてください。</div>\n\n● ● ●\n\n／引き続きページのレンダリング\n\n｝ /\n\n} elseif ($document && ($document[\'username\'] == $ SESSION[\'username\'])) ¥\n\nif (is admin request()) {\n\n／／権限あり\n\n／／権限あり\n\n} else {\n\nreturn not authorized();\n\n','ライブラリを知るʼ  このコードにはロジックがたくさんある。第Ⅱ部でも見たように、大きなロジック ツリーは理解するのが難しい。このロジックはもっと単純化できるだろう。でも、ど うやって簡単な言葉でロジックを説明してみよう。  権限があるのは、以下のつ。 管理者 文書の所有者(文書がある場合 その他は、権限がない。  この説明から新しい解決策を思いついた。  このバージョンは少し変だ。if文の中身がつも空になっている。でも、コードは 小さくなったし、ロジックも単純になった。否定形がなくなったからだ以前は「!」 がつもあった)。つまり、こちらのほうが理解しやすい。  ライブラリを知る 以下のようなユーザの助けになる「ヒント」を表示するウェブサイトを持っていた  ことがある。  ヒント過去のクエリを見るにはログインしてください。［その他のヒントを見る  ヒントは数十個ほどあって、すべてHTMLに隠してあった。  <div  id=\"tip-l\"  class=\"tip\">ヒント過去のクエリを見るにはログインしてください。</div> <div  id=\"tip-\"  class=\"tip\">ヒント拡大するには画像をクリックしてください。</div>  ● ● ●  引き続きページのレンダリング  ｝ /  } elseif ($document && ($document[\'username\'] == $ SESSION[\'username\'])) ¥  if (is admin request()) {  権限あり  権限あり  } else {  return not authorized();  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(171,1,170,'160      12章コードに思いを込める\n\nユーザがページを訪問すると、divの１つがランダムに表示される。残りは隠れた\n\nままだ。\n\n「その他のヒントを見る！」をクリックすると、次のヒントの番になる。以下は、\n\njQueryというJavaScriptライブラリで実装したコードだ。\n\n肘\n\n問題のないコードだ。でも、もっとよくできる。まずは説明するところから始めて\nみよう。できれば口に出してみるといい。このコードは何をしようとしているだろう\nか\n。\n\n今見えているヒントを見つけて隠す。\n次のヒントを見つけて表示する。\nヒントがなくなったら、最初のヒントに戻る。\n\nこの説明を元に作った解決策がこちらだ。\n\n今見えているヒントを見つけて隠す。\n次のヒントを見つける。\nヒントがなくなったら、\n\n最初のヒントに戻る。\n\n●““ノ・一”●ノ．”●Ｉ．”．Ｊ\n\nノ\n\nノ\n\nノ\n\nノ\n\n/／新しいヒントを表示する。\n\nvar show next tip = function Q {\n\nvar cur tip = $(\'.tip:visible\').hide();\nvar next tip = cur tip.next(\'.tip\');\nif (next tip.sizeQ === 0) {\n\nnext tip = $(\'・tip:first\');\n\next tip.showQ;\n\n｝n\n\n}\n；\n\nコードは短くなったし、数値を直接操作する必要もなくなった。人間がどのように\n\nvar show next tip = function () {\n\nvar num tips = $(\'､tip\').sizeQ;\nvar shown tip = $(\'・tiprvisible\');\nvar shown tip num = Number(shown tip.attr(\'id\').slice(4));\nf (shown tip num === num tips) {\ni\n$(\'#tip-l\').show();\ne\nl\nse\n$(\'#tip-\' + (shown tip num + l)).show();\n\nhown tip・hide   :\n\n｝s\n\n','      章コードに思いを込める  ユーザがページを訪問すると、divのつがランダムに表示される。残りは隠れた  ままだ。  「その他のヒントを見る」をクリックすると、次のヒントの番になる。以下は、  jQueryというJavaScriptライブラリで実装したコードだ。  肘  問題のないコードだ。でも、もっとよくできる。まずは説明するところから始めて みよう。できれば口に出してみるといい。このコードは何をしようとしているだろう か 。  今見えているヒントを見つけて隠す。 次のヒントを見つけて表示する。 ヒントがなくなったら、最初のヒントに戻る。  この説明を元に作った解決策がこちらだ。  今見えているヒントを見つけて隠す。 次のヒントを見つける。 ヒントがなくなったら、  最初のヒントに戻る。  ●““ノ・一”●ノ”●Ｉ”Ｊ  ノ  ノ  ノ  ノ  /新しいヒントを表示する。  var show next tip = function Q {  var cur tip = $(\'.tip:visible\').hide(); var next tip = cur tip.next(\'.tip\'); if (next tip.sizeQ === ) {  next tip = $(\'・tip:first\');  ext tip.showQ;  ｝n  }   コードは短くなったし、数値を直接操作する必要もなくなった。人間がどのように  var show next tip = function () {  var num tips = $(\'､tip\').sizeQ; var shown tip = $(\'・tiprvisible\'); var shown tip num = Number(shown tip.attr(\'id\').slice()); f (shown tip num === num tips) { i $(\'#tip-l\').show(); e l se $(\'#tip-\' + (shown tip num + l)).show();  hown tip・hide   :  ｝s  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(172,1,171,'１２３この手法を大きな問題に適用する161\n\n考えるかをjE祝したコードになっている。\n\nここでは、jQueryの.nextQメソッドが役に立った。簡潔なコードを書くのに欠\n\nかせないのは、ライブラリが何を提供してくれるかを知ることだ。\n\n１２．３この手法を大きな問題に適用する\n先ほどの例では、小さなコードブロックを題材に使った。次の例では、大きな関数\nを使ってみよう。この手法を使えば、コードを分割する単位を見つけることができ\n。\nる\n例えば、株式の購入を記録するシステムがあるとしよう。取引には４つのデータ\n\nがある。\n\n●time (正確な購入日時）\n\n＝ ＝ (cid:9356)\n\n●ticker  symbol  (銘柄、例:  GOOG)\n●price (ｲ111!格、例: $600)\n●number of shares (株式数、例: 100)\n\nこれらのデータはどういうわけか３つのテーブルに散らばっている。以下に図を\n\n示そう。各テーブルの主キーはtimeである。\n\nnumber of sha\n．\"ʻｼ\"５０(cid:7767)\n\n（7５ 101\n\n泌\n\n蕊 潤 8 0\n\n騨 手\n\ntiIne\n４\n，\n識(cid:106)\n4:(cid:7708)\n4\n:\n3C\n5\n:\n20\n\n凸 Ｇ\n\n１\n）\n\n１１\n\npric(\n＄\n1\n2\n（\n｡$60(\n(cid:106)蕊\n$\n2\n0\n\n( γ対》\n\n静\n溌\n(cid:7785)\n\n録\n識\n誇\n\n琴 曲 (cid:7961) 歩\n\nt\nｍｇ\n3\n:\n４５”\n寧鳥噛\n蔦４:：\n20\n5\n:\n黙；蹴雑\n\nt\ni\ncker_syml\n\nI\nBM\nI蹄\n6OOG\nAAPL\n燃廊\n\nti｢､e蕊\n”\n．\n３\n:\n4５\n\n4\n:\n3\n（\n5\n:\n0\n（\n5\n:\n2(\n６蝋\n\n３つのテーブルを(SQLの]OINのように）結合するう．ログラムを書かなくてはい\nけない。すべての行がｔ加ｅでソートされているので簡単にできる。でも、データが\n欠けている行もある。図に示したように、３つすべてのtimeが一致する行だけを検\n索して、一致しないものは無視したい。\n\n以下は、一致する行だけを検索するPythonのコードだ。\n\n','この手法を大きな問題に適用する  考えるかをjE祝したコードになっている。  ここでは、jQueryの.nextQメソッドが役に立った。簡潔なコードを書くのに欠  かせないのは、ライブラリが何を提供してくれるかを知ることだ。  この手法を大きな問題に適用する 先ほどの例では、小さなコードブロックを題材に使った。次の例では、大きな関数 を使ってみよう。この手法を使えば、コードを分割する単位を見つけることができ 。 る 例えば、株式の購入を記録するシステムがあるとしよう。取引にはつのデータ  がある。  ●time (正確な購入日時    (cid:)  ●ticker  symbol  (銘柄、例:  GOOG) ●price (ｲ!格、例: $) ●number of shares (株式数、例: )  これらのデータはどういうわけかつのテーブルに散らばっている。以下に図を  示そう。各テーブルの主キーはtimeである。  number of sha \"ʻｼ\"(cid:)     泌  蕊 潤    騨 手  tiIne   識(cid:) :(cid:)  : C  :   凸 Ｇ       pric(     ｡$( (cid:)蕊 $    ( γ対》  静 溌 (cid:)  録 識 誇  琴 曲 (cid:) 歩  t ｍｇ  : ” 寧鳥噛 蔦:   : 黙蹴雑  t i cker_syml  I BM I蹄 OOG AAPL 燃廊  ti｢､e蕊 ”   :    :    :    : ( 蝋  つのテーブルを(SQLの]OINのように結合するうログラムを書かなくてはい けない。すべての行がｔ加ｅでソートされているので簡単にできる。でも、データが 欠けている行もある。図に示したように、つすべてのtimeが一致する行だけを検 索して、一致しないものは無視したい。  以下は、一致する行だけを検索するPythonのコードだ。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(173,1,172,'1６2      12章コードに思いを込める\n\nロ\nロ\nヨ\n、\n『（房。》\n亜\n一\n》\n\nPrintStockTransactionsQ:\nstock iter = db read(\"SELECT time, ticker_symbol FROM…\" ノ\nprice iter =．.、\nnum shares iter =．．．\n\n＃３つのテーブルの行を一度にイテレートする。\nwhile stock iter and price iter and num shares iter:\n\nstock time = stock iter･time\nprice time = price iter･time\nnum shares time = num shares iter･time\n\n＃３つの行に同じtimeが含まれていない場合は、最も過去の行をスキップする。\n＃注意：最も過去の行が２つ一致していることもあるので、ʼ1<二”は\"<\"にできない〔\nif stock time != price time or stock time != num shares time:\n\nif stock time <= price time and stock time <= num shares time:\n\nstock iter.NextRowQ\n\nprice iter.NextRowQ\n\nelif price time <= stock time and price time <= num shares time:\n\nelif num shares time <= stock time and num shares time <= price time:\n\nnum shares iter.NextRowQ\n\nassert False #不可能\n\nelse:\n\ncontinue\n\nassert stock time == price time == num shares time\n\n＃一致した行を印字する。\nprint  T,  stock  time,\nprint stock iter.ticker symbol,\nprint price iter･price,\nprint num shares iter･number of shares\ns\nt\nock iter・NextRowQ\nprice iter・NextRowQ\nnum shares iter・NextRowQ\n\nこのコードは動くけど、一致しない行をスキップするのに多くの行を費やしてい\nる。「行を抜かしていないだろうか？」とか「イテレータを読み込みすぎていないだ\nろうか？」などの「警告フラグ」が頭をよぎったかもしれない。\n\nというわけで、もっと読みやすくするのはどうすればいいだろうか？\n\n','      章コードに思いを込める  ロ ロ ヨ 、 『房。》 亜 一 》  PrintStockTransactionsQ: stock iter = db read(\"SELECT time, ticker_symbol FROM…\" ノ price iter =.、 num shares iter =  つのテーブルの行を一度にイテレートする。 while stock iter and price iter and num shares iter:  stock time = stock iter･time price time = price iter･time num shares time = num shares iter･time  つの行に同じtimeが含まれていない場合は、最も過去の行をスキップする。 注意最も過去の行がつ一致していることもあるので、ʼ<二”は\"<\"にできない〔 if stock time != price time or stock time != num shares time:  if stock time <= price time and stock time <= num shares time:  stock iter.NextRowQ  price iter.NextRowQ  elif price time <= stock time and price time <= num shares time:  elif num shares time <= stock time and num shares time <= price time:  num shares iter.NextRowQ  assert False #不可能  else:  continue  assert stock time == price time == num shares time  一致した行を印字する。 print  T,  stock  time, print stock iter.ticker symbol, print price iter･price, print num shares iter･number of shares s t ock iter・NextRowQ price iter・NextRowQ num shares iter・NextRowQ  このコードは動くけど、一致しない行をスキップするのに多くの行を費やしてい る。「行を抜かしていないだろうか」とか「イテレータを読み込みすぎていないだ ろうか」などの「警告フラグ」が頭をよぎったかもしれない。  というわけで、もっと読みやすくするのはどうすればいいだろうか  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(174,1,173,'１２３この手法を大きな問題に適用するʼ１６３\n\n解決策を言葉で説明する\n\nもう一度、これからやろうとしていることを簡単な言葉で説明しよう。\n\n3つの行のイテレータを一度に読み込む。\n行のtimeが一致していなければ、一致するまで行を進める。\n一致した行を印字して、行を進める。\n一致する行がなくなるまでこれを繰り返す。\n\n元のコードを見返してみよう。いちばん汚いのは「一致するまで行を進める」部分\nだ。これをもっとキレイにするには、汚いロジックを新しい関数AdvanceToMatching\nTimeOに抽出すればいい。\n\n新しい関数を使ったバージョンがこちらだ。\n\ndef PrintStockTransactionsQ:\n\nstock iter二．.、\nprice  iter=…\nnum shares iter =．．．\n\nwhile True:\n\nreturn\n\ntime = AdvanceToMatchingTime(stock_iter, price_iter, num shares iter)\nif time is None:\n\n＃一致した行を印字する。\nprint \"@\", time,\nprint stock iter・ticker symbol,\nprint price iter・price,\nprint num shares iter・number of shares\ns\nt\nock iter・NextRowQ\nprice iter.NextRowQ\nnum shares iter.NextRowQ\n\nすごく理解しやすくなった。行を一致させる汚い部分がすべて隠れた。\n\n手法を再帰的に適用する\nAdvanceToMatchingTimeQを書いたらどうなるかは容易に想像できる。最初のバー\nジョンはひどいものになるだろう。\n\n','この手法を大きな問題に適用するʼ  解決策を言葉で説明する  もう一度、これからやろうとしていることを簡単な言葉で説明しよう。  つの行のイテレータを一度に読み込む。 行のtimeが一致していなければ、一致するまで行を進める。 一致した行を印字して、行を進める。 一致する行がなくなるまでこれを繰り返す。  元のコードを見返してみよう。いちばん汚いのは「一致するまで行を進める」部分 だ。これをもっとキレイにするには、汚いロジックを新しい関数AdvanceToMatching TimeOに抽出すればいい。  新しい関数を使ったバージョンがこちらだ。  def PrintStockTransactionsQ:  stock iter二.、 price  iter=… num shares iter =  while True:  return  time = AdvanceToMatchingTime(stock_iter, price_iter, num shares iter) if time is None:  一致した行を印字する。 print \"\", time, print stock iter・ticker symbol, print price iter・price, print num shares iter・number of shares s t ock iter・NextRowQ price iter.NextRowQ num shares iter.NextRowQ  すごく理解しやすくなった。行を一致させる汚い部分がすべて隠れた。  手法を再帰的に適用する AdvanceToMatchingTimeQを書いたらどうなるかは容易に想像できる。最初のバー ジョンはひどいものになるだろう。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(175,1,174,'１６４１１２章コードに思いを込める\n\ndef AdvanceToMatchingTime(stock iter, price iter, num shares iter):\n\n＃３つのテーブルの行を一度にイテレートする。\nwhile stock iter and price iter and num shares_iter:\n\nstock time = stock iter.time\nprice time = price iter.time\nnum shares time = num shares iter･time\n\n＃３つの行に同じtimeが含まれていない場合は、最も過去の行をスキップする。\nif stock time != price time or stock time != num shares time:\n\nif stock time <= price time and stock time <= num shares time:\n\nelif price time <= stock time and price time <= num shares time:\n\nstock iter・NextRowQ\n\nprice iter.NextRowQ\n\nelif num shares time <= stock time and num shares time <= price time:\n\nnum shares iter・NextRowQ\n\nassert False # impossible\n\nelse:\n\ncontinue\n\nassert stock time == price time == num shares time\nreturn stock time\n\nAdvanceToMatchingTimeQにも同じ手法を使って改善していこう。以下は、この\nコードに必要なことを説明したものである。\n\n現在の行のtimeを見る。一致していれば終了する。\n一致していなければ、「遅れている」行を進める。\n行が一致するまで（あるいはイテレーションのいずれかが終了するまで）これを繰り返す。\n\nこの説明はコードよりもキレイで簡潔だ。stock  iterなどの問題に特化した詳細\nについて言及していないことに注目して欲しい。つまり、変数名はより簡潔で汎用的\nなものに改名できるということだ。この説明に合わせて書き換えたコードは以下にな\nる\n\n。 d\n\nef AdvanceToMatchingTime(roIm iterl, roﾚ¥i iter2, row iters):\n\nwhile row iterl and row iter2 and row iters:\n\ntl = row iterl･time\nt2 = row iter2･time\nt3 = row iters･time\n\n','章コードに思いを込める  def AdvanceToMatchingTime(stock iter, price iter, num shares iter):  つのテーブルの行を一度にイテレートする。 while stock iter and price iter and num shares_iter:  stock time = stock iter.time price time = price iter.time num shares time = num shares iter･time  つの行に同じtimeが含まれていない場合は、最も過去の行をスキップする。 if stock time != price time or stock time != num shares time:  if stock time <= price time and stock time <= num shares time:  elif price time <= stock time and price time <= num shares time:  stock iter・NextRowQ  price iter.NextRowQ  elif num shares time <= stock time and num shares time <= price time:  num shares iter・NextRowQ  assert False # impossible  else:  continue  assert stock time == price time == num shares time return stock time  AdvanceToMatchingTimeQにも同じ手法を使って改善していこう。以下は、この コードに必要なことを説明したものである。  現在の行のtimeを見る。一致していれば終了する。 一致していなければ、「遅れている」行を進める。 行が一致するまであるいはイテレーションのいずれかが終了するまでこれを繰り返す。  この説明はコードよりもキレイで簡潔だ。stock  iterなどの問題に特化した詳細 について言及していないことに注目して欲しい。つまり、変数名はより簡潔で汎用的 なものに改名できるということだ。この説明に合わせて書き換えたコードは以下にな る  。 d  ef AdvanceToMatchingTime(roIm iterl, roﾚ¥i iter, row iters):  while row iterl and row iter and row iters:  tl = row iterl･time t = row iter･time t = row iters･time  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(176,1,175,'１２４まとめʼ１６５\n\nif  tl  ==  t2  ==  t3:\n\nreturn  tl\n\ntmax = max(tl, t2, t3)\n\n＃いずれかの行が「遅れている」のであれば、その行を進める。\n＃最終的にすべての行が一致するまでwhileループを繰り返す。\ni\nf tl < tmax: row iterl.NextRowQ\ni\nf t2 < tmax: row iter2.NextRowQ\ni\nf t3 < tmax: row iter3・NextRowQ\n\nreturn None   #一致する行が見つからない\n\nコードが以前よりもずっとキレイになった。アルゴリズムは単純になったし、複雑\nな比較もほとんどなくなっている。tlのような短い名前を使っているので、データ\nベースのカラム名を考えなくてもよくなった。\n\n１２４まとめ\n本章では、プログラムのことを簡単な言葉で説明する技法について説明した。説明\nすることでコードがより自然になっていく。この技法は思っているよりも簡単だが非\n常に強力だ。説明で使っている単語やフレーズをよく見れば、分割する下位問題がど\nこにあるかがわかる。\n\nこの「簡単な言葉で説明する」手法は、コードを書くこと以外にも適用できる。例\nえば、ある大学の計算機センターにはこんな方針があった。プログラムのデバッグに\n悩む学生は、部屋の隅に置かれたテデイベアに向かって最初に説明しなければいけな\nいのである。驚くべきことに、問題を声に出して説明するだけで、学生は解決策が見\nつかるのだ↑。この技法は「ラバーダッキング汁」とも呼ばれている。\n\n問題や設計をうまく言葉で説明できないのであれば、何かを見落としているか、詳\n細が明確になっていないということだ。プログラム（あるいは自分の考え）を言葉に\nすることで明確な形になるのである。\n\n↑訳注『プログラミング作法』（ブライアン・カーニハン、ロブ・バイク著、福崎俊博訳、アスキー）に登\n\n場する話。\n\n↑●･↑訳注『達人プログラマー一システム開発の職人から名匠への道』（アンドリュー・ハント、デビッド･\nトーマス著、村上雅章訳、ピアソンエデュケーション）では、「１８デバッグ」に「ゴムのアヒルちゃん-\nとして登場している。\n\n','まとめʼ  if  tl  ==  t  ==  t:  return  tl  tmax = max(tl, t, t)  いずれかの行が「遅れている」のであれば、その行を進める。 最終的にすべての行が一致するまでwhileループを繰り返す。 i f tl < tmax: row iterl.NextRowQ i f t < tmax: row iter.NextRowQ i f t < tmax: row iter・NextRowQ  return None   #一致する行が見つからない  コードが以前よりもずっとキレイになった。アルゴリズムは単純になったし、複雑 な比較もほとんどなくなっている。tlのような短い名前を使っているので、データ ベースのカラム名を考えなくてもよくなった。  まとめ 本章では、プログラムのことを簡単な言葉で説明する技法について説明した。説明 することでコードがより自然になっていく。この技法は思っているよりも簡単だが非 常に強力だ。説明で使っている単語やフレーズをよく見れば、分割する下位問題がど こにあるかがわかる。  この「簡単な言葉で説明する」手法は、コードを書くこと以外にも適用できる。例 えば、ある大学の計算機センターにはこんな方針があった。プログラムのデバッグに 悩む学生は、部屋の隅に置かれたテデイベアに向かって最初に説明しなければいけな いのである。驚くべきことに、問題を声に出して説明するだけで、学生は解決策が見 つかるのだ↑。この技法は「ラバーダッキング汁」とも呼ばれている。  問題や設計をうまく言葉で説明できないのであれば、何かを見落としているか、詳 細が明確になっていないということだ。プログラムあるいは自分の考えを言葉に することで明確な形になるのである。  ↑訳注『プログラミング作法』ブライアン・カーニハン、ロブ・バイク著、福崎俊博訳、アスキーに登  場する話。  ↑●･↑訳注『達人プログラマー一システム開発の職人から名匠への道』アンドリュー・ハント、デビッド･ トーマス著、村上雅章訳、ピアソンエデュケーションでは、「デバッグ」に「ゴムのアヒルちゃん- として登場している。  ','2017-11-20 15:02:18','2017-11-20 15:02:18'),(177,1,176,'ʼ\n１６７\n\n督翁童\n短いコードを書く\n\n／ お ば あ ち ゃ ん 、 、\n／おばあちゃん、\nソースがなくなりそうだよ。\nソースがなくなりそうだよ。\n．めちゃくちゃおいしい！\n\nレシピは家族の\nし\n秘密だよね\n\nＦ\nＺ\n態\n１\n\n＝\n\n、­，-柵 |Ｉ柵 刺lllにー\n\n一\n一\n\n-\n-\n\n○\n\n『\n書\n、\nM減\n\nもちろんだわわ\n\n­ 〜 ﾛ …\n\n','ʼ   督翁童 短いコードを書く   お ば あ ち ゃ ん 、 、 おばあちゃん、 ソースがなくなりそうだよ。 ソースがなくなりそうだよ。 めちゃくちゃおいしい  レシピは家族の し 秘密だよね  Ｆ Ｚ 態     、­-柵 |Ｉ柵 刺lllにー  一 一  - -  ○  『 書 、 M減  もちろんだわわ  ­ 〜 ﾛ …  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(178,1,177,'１６８１１３章短いコードを書く\n\nプログラマが学ぶべき最も大切な技能というのは、コードを書かないときを知るこ\nとなのかもしれない。自分で書いたコードであれば、すべての行をテストして保守し\nなければいけない。ライブラリの再利用や機能の削除をすることで、時間を節約した\nり、コードを簡潔に維持したりできる。\n\n(cid:20276)となる考え\n最も読みやすいコードは、何も書かれていないコードだ。\n\n１３.１その機能の実装について悩まないで\n\n­きっと必要ないから\n\nプロジェクトを開始するときには、これから実装するカッコいい機能のことを考え\nて興奮するものだ。そして、プロジェクトに欠かせない機能を過剰に見積もってしま\nう。その結果、多くの機能が、完成しないか、全く使われないか、アプリケーション\nを複雑にするものになってしまう。\n\nプログラマというのは、実装にかかる労力を過小評価するものでもある。プロトタ\nイプの実装にかかる時間を楽観的に見積もったり、将来的に必要となる保守や文書イヒ\nなどの「負担」時間を忘れたりする。\n１３．２質問と要求の分割\nすべてのプログラムが、高速で、100％正しくて、あらゆる入力をうまく処理する\n必要はない。要求を詳しく調べれば、問題をもっと簡単にできることもある。そうす\nれば、必要なコードも少なくて済む。このような例をいくつか見ていこう。\n\n例：店舗検索システム\n商用の「店舗検索システム」を作っているとしよう。要求は以下のようなものだ。\n\n任意のユーザの緯度経度に対して、最も近い店舗を検索する。\n\nこれを100％正しく実装するには、以下のことも考慮しなければいけない。\n\n●日付変更線をまたいでいるときの処理\n\n●北極や南極に近いときの処理\n\n','章短いコードを書く  プログラマが学ぶべき最も大切な技能というのは、コードを書かないときを知るこ となのかもしれない。自分で書いたコードであれば、すべての行をテストして保守し なければいけない。ライブラリの再利用や機能の削除をすることで、時間を節約した り、コードを簡潔に維持したりできる。  (cid:)となる考え 最も読みやすいコードは、何も書かれていないコードだ。  .その機能の実装について悩まないで  ­きっと必要ないから  プロジェクトを開始するときには、これから実装するカッコいい機能のことを考え て興奮するものだ。そして、プロジェクトに欠かせない機能を過剰に見積もってしま う。その結果、多くの機能が、完成しないか、全く使われないか、アプリケーション を複雑にするものになってしまう。  プログラマというのは、実装にかかる労力を過小評価するものでもある。プロトタ イプの実装にかかる時間を楽観的に見積もったり、将来的に必要となる保守や文書イヒ などの「負担」時間を忘れたりする。 質問と要求の分割 すべてのプログラムが、高速で、正しくて、あらゆる入力をうまく処理する 必要はない。要求を詳しく調べれば、問題をもっと簡単にできることもある。そうす れば、必要なコードも少なくて済む。このような例をいくつか見ていこう。  例店舗検索システム 商用の「店舗検索システム」を作っているとしよう。要求は以下のようなものだ。  任意のユーザの緯度経度に対して、最も近い店舗を検索する。  これを正しく実装するには、以下のことも考慮しなければいけない。  ●日付変更線をまたいでいるときの処理  ●北極や南極に近いときの処理  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(179,1,178,'１３２質問と要求の分割ʼ１６９\n\n●「１マイルあたりの経度」に対応した地球の曲率の調整\n\nこれらを真面目に処理すれば、相当な量のコードになる。\nでも、君のアプリケーションで扱うのは、テキサス州にある３０軒の店舗だけだ。\nこんな小さな範囲で上記の３つの処理を考える必要はない。要求から削除すればい\nいのだ。\n\nテキサス州のユーザのために、テキサスで最も近くにある店舗を検索する\n\nこの問題を解決するのは簡単だ。すべての店舗との距離を計算すればいい（\n\n例：キャッシュを追加する\nディスクから頻繁にオブジェクトを取得するJavaアプリケーションを作ったこと\nがある。アプリケーションの速度は、ディスクの読み取り速度によって制限されてい\nた。ぼくたちは何らかのキャッシュを実装したいと思っていた。読み取りの様子は以\n下のような感じだった。\n\nread Object /\nread Object /\nr\nead Objectノ\nr\nead Object E\nr\nead Object E\nread Object (\nread Object [\nread Object [\n\n同じオブジェクトに何度もアクセスしているのがわかると思う。キャッシュは確実\n\nに有効だ。\n\nこの問題に直面したときには、LRU方式（参照されていない時間が最も長い項目\nを削除する方式）のキャッシュを使おうと思っていた。でも、手持ちのライブラリが\nなかったので、自分たちで実装することにした。以前にも同様のデータ構造を実装し\nたことがあったので、大した問題じゃないと思っていた（そのときはハシシュテーブ\nルと単方向リストの両方を使っていて、コードは全部で１００行になった)。\n\nでも、アクセスが必ず順番に行われていることに気づいたので、LRU方式のキャッ\n\n','質問と要求の分割ʼ  ●「マイルあたりの経度」に対応した地球の曲率の調整  これらを真面目に処理すれば、相当な量のコードになる。 でも、君のアプリケーションで扱うのは、テキサス州にある軒の店舗だけだ。 こんな小さな範囲で上記のつの処理を考える必要はない。要求から削除すればい いのだ。  テキサス州のユーザのために、テキサスで最も近くにある店舗を検索する  この問題を解決するのは簡単だ。すべての店舗との距離を計算すればいい  例キャッシュを追加する ディスクから頻繁にオブジェクトを取得するJavaアプリケーションを作ったこと がある。アプリケーションの速度は、ディスクの読み取り速度によって制限されてい た。ぼくたちは何らかのキャッシュを実装したいと思っていた。読み取りの様子は以 下のような感じだった。  read Object / read Object / r ead Objectノ r ead Object E r ead Object E read Object ( read Object [ read Object [  同じオブジェクトに何度もアクセスしているのがわかると思う。キャッシュは確実  に有効だ。  この問題に直面したときには、LRU方式参照されていない時間が最も長い項目 を削除する方式のキャッシュを使おうと思っていた。でも、手持ちのライブラリが なかったので、自分たちで実装することにした。以前にも同様のデータ構造を実装し たことがあったので、大した問題じゃないと思っていたそのときはハシシュテーブ ルと単方向リストの両方を使っていて、コードは全部で行になった)。  でも、アクセスが必ず順番に行われていることに気づいたので、LRU方式のキャッ  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(180,1,179,'１７０１１３章短いコードを書く\n\nシュではなく、単項目キャッシュ(one-item cache)を実装することにした。\n\nD\ni\nskObject lastUsed;   //クラスのメンバ\nskObject lookUp(String key) {\nD\ni\ni\nf (lastUsed == null || !lastUsed・key).equals(key)) {\n\nl\nastUsed = loadDiskObject(key);\n\neturn lastUsed:夕\n\n｝ r\n\nコーディング量は少ないけど、LRU方式を使ったときの９０%の効果があった。そ\n\nれにメモリ使用量も少なくなった。\n\n「要求の削除」と「より単純な問題の解決」に利点があるというのは、何も大げさ\nに言ってるわけじゃない。要求というのは、お互いに微妙に干渉してしまうものだ。\n問題の半分を解決するのに、１/４のコーディング時間で済むこともあるくらいだ。\n１３．３コードを小さく保つ\nコー\n\n／\n\n大きし\n\n〃\n\n〃＝\n\n鐸\n\n\'\n\n一\n\n(cid:9357)\n\n一\n\n小さし\n\n一 … … 一\n\n小さい\n\nコードのサイズ\n\n大きい\n\nソフトウェアプロジェクトを始めるときには、ソースファイルは１つか２つしか\nない。素晴らしい。コードをコンパイルして実行するなんて簡単だ。変更もしやす\nい。関数やクラスをどこで定義しているかもすぐに思い出せる。\n\n','章短いコードを書く  シュではなく、単項目キャッシュ(one-item cache)を実装することにした。  D i skObject lastUsed;   //クラスのメンバ skObject lookUp(String key) { D i i f (lastUsed == null || !lastUsed・key).equals(key)) {  l astUsed = loadDiskObject(key);  eturn lastUsed:夕  ｝ r  コーディング量は少ないけど、LRU方式を使ったときの%の効果があった。そ  れにメモリ使用量も少なくなった。  「要求の削除」と「より単純な問題の解決」に利点があるというのは、何も大げさ に言ってるわけじゃない。要求というのは、お互いに微妙に干渉してしまうものだ。 問題の半分を解決するのに、/のコーディング時間で済むこともあるくらいだ。 コードを小さく保つ コー    大きし  〃  〃  鐸  \'  一  (cid:)  一  小さし  一 … … 一  小さい  コードのサイズ  大きい  ソフトウェアプロジェクトを始めるときには、ソースファイルはつかつしか ない。素晴らしい。コードをコンパイルして実行するなんて簡単だ。変更もしやす い。関数やクラスをどこで定義しているかもすぐに思い出せる。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(181,1,180,'１３．３コードを小さく保つʼ１７１\n\nプロジェクトが進んでいくと、ファイルが増えていく。ディレクトリを分けてファ\nイルを整理しなきゃいけなくなってくる。どの関数がどの関数を呼び出しているかが\nよくわからなくなってくる。バグを見つけるのもだんだん面倒になっていく。\n\n最終的には、いろんなディレクトリにファイルが散らばることになる。プロジェク\nトは巨大になって、すべてを把握できる人は誰もいなくなる。新しい機能を追加する\nのが苦痛になってくる。コードを扱うのが厄介になって楽しくなくなる。\n\nあらゆる協調システムは成長する。それらを結び付ける複雑さはもっと速い速度で\n\n成長する。これは宇宙の自然法則だ。\n\nつまり、プロジェクトが成長しても、コードをできるだけ小さく軽量に維持するし\n\nかない。君がしなければいけないのは、以下のことだ。\n\n●汎用的な「ユーティリティ」コードを作って、重複コードを削除する（｢１０\n\n章無関係の下位問題を抽出する」参照)。\n\n●未使用のコードや無用の機能を削除する（以下のコラムを参照)。\n\n●プロジェクトをサブプロジェクトに分割する。\n\n●コードの「重量」を意識する。軽量で機敏にしておく。\n\n未使用のコードを削除する\n\n園芸家は、植物が生き生きと成長し続けられるように枝を刈り込む。これと同じで、邪\n\n魔になっている未使用のコードを刈り込むのはいい考えだ。\n\nコードを書いたら、削除したくはないものだ。コードというのは「実際の仕事」を表し\nたものだからだ。つまり、コードを削除すれば、そこに費やした時間を無駄にすることに\nなる。そんなのどうでもいいんだよ！ここはクリエイティブな分野だ。写真家・作家・\n映画製作者が、自分の作ったものをすべて残しているだろうか。\n\n独立した関数を削除するのは簡単だ。でも、「未使用のコード」は、気づかないうちにプ\n\nロジェクト全体に深く絡み合っていることがある。例をいくつか挙げよう。\n\n●国際的なファイル名を扱うシステムを設計したとする。そのコードは今でも変換コー\nドに含まれている。でも、そのコードは一度も使われていない。アプリケーションが\n国際的なファイル名を扱うことがないからだ。\n\n','コードを小さく保つʼ  プロジェクトが進んでいくと、ファイルが増えていく。ディレクトリを分けてファ イルを整理しなきゃいけなくなってくる。どの関数がどの関数を呼び出しているかが よくわからなくなってくる。バグを見つけるのもだんだん面倒になっていく。  最終的には、いろんなディレクトリにファイルが散らばることになる。プロジェク トは巨大になって、すべてを把握できる人は誰もいなくなる。新しい機能を追加する のが苦痛になってくる。コードを扱うのが厄介になって楽しくなくなる。  あらゆる協調システムは成長する。それらを結び付ける複雑さはもっと速い速度で  成長する。これは宇宙の自然法則だ。  つまり、プロジェクトが成長しても、コードをできるだけ小さく軽量に維持するし  かない。君がしなければいけないのは、以下のことだ。  ●汎用的な「ユーティリティ」コードを作って、重複コードを削除する｢  章無関係の下位問題を抽出する」参照)。  ●未使用のコードや無用の機能を削除する以下のコラムを参照)。  ●プロジェクトをサブプロジェクトに分割する。  ●コードの「重量」を意識する。軽量で機敏にしておく。  未使用のコードを削除する  園芸家は、植物が生き生きと成長し続けられるように枝を刈り込む。これと同じで、邪  魔になっている未使用のコードを刈り込むのはいい考えだ。  コードを書いたら、削除したくはないものだ。コードというのは「実際の仕事」を表し たものだからだ。つまり、コードを削除すれば、そこに費やした時間を無駄にすることに なる。そんなのどうでもいいんだよここはクリエイティブな分野だ。写真家・作家・ 映画製作者が、自分の作ったものをすべて残しているだろうか。  独立した関数を削除するのは簡単だ。でも、「未使用のコード」は、気づかないうちにプ  ロジェクト全体に深く絡み合っていることがある。例をいくつか挙げよう。  ●国際的なファイル名を扱うシステムを設計したとする。そのコードは今でも変換コー ドに含まれている。でも、そのコードは一度も使われていない。アプリケーションが 国際的なファイル名を扱うことがないからだ。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(182,1,181,'１７２１１３章短いコードを書く\n\nどうしてこの機能を削除しないのだろうか？\n\n●メモリを使い果たしても動くようなシステムにしたかったので、メモリ不足からうま\nく回復するロジックをたくさんプログラムに組み込んだ。考え方は悪くなかったけ\nど、実際にメモリ不足になると単なる不安定なゾンビになってしまう。必要な機能も\n使えない。ワンクリックで死亡だ。\nどうして「システムがメモリ不足です」と言ってプログラムを終了しないのだろう\nか？どうしてメモリ不足の原因となっているコードを削除しないのだろうか？\n\n１３．４身近なライブラリに親しむ\nプログラマというのは、既存のライブラリで問題を解決できることを知らないこと\nが多い。あるいは、ライブラリで可能なことを忘れていることが多い。ライブラリの\n機能を熟知して、実際に活用することが大切だ。\n\nここでささやかな提案だ。たまには標準ライブラリのすべての関数・モジュール・\n型の名前を１５分かけて読んでみよう。標準ライブラリというのは、C++標準テンプ\nレートライブラリSTL)やJavaのAPIやPythonの組み込みモジュールなどのこ\nとだ。\n\nライブラリを全部覚えろと言ってるわけじゃない。どんなことができそうか感じ取\nるだけでいい。そうすれば、新しいコードを書いているときに、「ちょっと待てよ。\nこれは、APIで見たような･･･…」と思い出すことができる。あらかじめやっておけ\nば、すぐに役立つときが来るはずだ。そのうち最初からライブラリを使えるようにな\nるだろう。\n\n例:  Pythonのリストとセット\nPythonのリストを使っているとしよう（例えば、[2,1.2])。リストの要素から重複\nを取り除きたいとする（この場合は、［2,1])。ディクショナリを使って実装すれば、\nキーを一意にしてくれる。\n\ndef unique(elements):\n\ntemp = {}\nfor element in elements:\nt\nemp[element] = None   #値は何でもいい。\nr\ne\nt\nu\nr\nn temp・keys\n\nunique elements = unique([2,l,2])\n\n','章短いコードを書く  どうしてこの機能を削除しないのだろうか  ●メモリを使い果たしても動くようなシステムにしたかったので、メモリ不足からうま く回復するロジックをたくさんプログラムに組み込んだ。考え方は悪くなかったけ ど、実際にメモリ不足になると単なる不安定なゾンビになってしまう。必要な機能も 使えない。ワンクリックで死亡だ。 どうして「システムがメモリ不足です」と言ってプログラムを終了しないのだろう かどうしてメモリ不足の原因となっているコードを削除しないのだろうか  身近なライブラリに親しむ プログラマというのは、既存のライブラリで問題を解決できることを知らないこと が多い。あるいは、ライブラリで可能なことを忘れていることが多い。ライブラリの 機能を熟知して、実際に活用することが大切だ。  ここでささやかな提案だ。たまには標準ライブラリのすべての関数・モジュール・ 型の名前を分かけて読んでみよう。標準ライブラリというのは、C++標準テンプ レートライブラリSTL)やJavaのAPIやPythonの組み込みモジュールなどのこ とだ。  ライブラリを全部覚えろと言ってるわけじゃない。どんなことができそうか感じ取 るだけでいい。そうすれば、新しいコードを書いているときに、「ちょっと待てよ。 これは、APIで見たような･･･…」と思い出すことができる。あらかじめやっておけ ば、すぐに役立つときが来るはずだ。そのうち最初からライブラリを使えるようにな るだろう。  例:  Pythonのリストとセット Pythonのリストを使っているとしよう例えば、[,.])。リストの要素から重複 を取り除きたいとするこの場合は、［,])。ディクショナリを使って実装すれば、 キーを一意にしてくれる。  def unique(elements):  temp = {} for element in elements: t emp[element] = None   #値は何でもいい。 r e t u r n temp・keys  unique elements = unique([,l,])  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(183,1,182,'１３５例：コーディングするよりもUnixツールボックスを使う1７3\n\nでも、あまり知られていないset型を使ったほうがいい。\n\nunique elements = set([2,l,2])   #重複の削除\n\nこのオブジェクトは、通常のリストのようにイテレートできる。リストオブジェク\n\nトが必要であれば、以下のようにする。\n\nunique elements = list(set( 2,1,2   )   #重複の削除\n\nここではsetを使うのが適切だ。でも、set型のことを知らなかったら、上記の\n\nuniqueQのようなコードを自分で作っていただろう。\n\nラ イ ブ ラ リ の 再 利 用 は な ぜ い い こ と な の か\n\nよく使われている統計だけど、平均的なソフトウェアエンジニアが１日に書く出\n荷用のコードは、１０行なのだそうだ。ビックリしてこう言うかもしれない。「１０行\n．．…･だと……？そんなの１分で書けるじゃないか！」\n\n大切なのは、出荷用という言葉だ。成熟したライブラリのコードの裏側には、膨大\nな設計・デバッグ・修正・文書・最適化・テストが存在する。このダーウィンの進化\nを生き延びてきたコードには大きな価値がある。これがライブラリの再利用がよしと\nされている理由の１つだ。時間の節約になるし、書くコードも少なくなる。\n１３．５例：コーディングするよりも\nUnixツールボックスを使う\n\nウェブサーバが頻繁に４】OKや５】感のHTTPレスポンスコードを返していたら、何\nか問題があるという兆候だ（4麺〈はクライアントのエラーで、５】｡〈はサーバのエラー\nだ)。ウェブサーバのアクセスログをパースして、どのURLでエラーが発生してい\nるかを調べたい。\n\nアクセスログというのは、以下のようになっている。\n\n1\n.\n2\n.\n3\n.\n4 example.com [24/Aug/20lO:01:08:34]\n5 example・com [24/Aug/2010:01:14:27]\n4\n3\n2\n.\n.\n.\n3\n.\n4\n.\n5\n.\n6 example.com [24/Aug/20l0:0l:l5:54]\n\n\"GET\n\"GET\n\"GET\n\n/index・html HTTP/1.1\" 200 ...\n/help?topic=8 HTTP/1.1\" 500 ...\n/favicon・ico HTTP/1.1\" 404 ...\n\n','例コーディングするよりもUnixツールボックスを使う  でも、あまり知られていないset型を使ったほうがいい。  unique elements = set([,l,])   #重複の削除  このオブジェクトは、通常のリストのようにイテレートできる。リストオブジェク  トが必要であれば、以下のようにする。  unique elements = list(set( ,,   )   #重複の削除  ここではsetを使うのが適切だ。でも、set型のことを知らなかったら、上記の  uniqueQのようなコードを自分で作っていただろう。  ラ イ ブ ラ リ の 再 利 用 は な ぜ い い こ と な の か  よく使われている統計だけど、平均的なソフトウェアエンジニアが日に書く出 荷用のコードは、行なのだそうだ。ビックリしてこう言うかもしれない。「行 …･だと……そんなの分で書けるじゃないか」  大切なのは、出荷用という言葉だ。成熟したライブラリのコードの裏側には、膨大 な設計・デバッグ・修正・文書・最適化・テストが存在する。このダーウィンの進化 を生き延びてきたコードには大きな価値がある。これがライブラリの再利用がよしと されている理由のつだ。時間の節約になるし、書くコードも少なくなる。 例コーディングするよりも Unixツールボックスを使う  ウェブサーバが頻繁に】OKや】感のHTTPレスポンスコードを返していたら、何 か問題があるという兆候だ麺〈はクライアントのエラーで、】｡〈はサーバのエラー だ)。ウェブサーバのアクセスログをパースして、どのURLでエラーが発生してい るかを調べたい。  アクセスログというのは、以下のようになっている。   .  .  .  example.com [/Aug/lO:::]  example・com [/Aug/:::]    . . .  .  .  .  example.com [/Aug/l:l:l:]  \"GET \"GET \"GET  /index・html HTTP/.\"  ... /help?topic= HTTP/.\"  ... /favicon・ico HTTP/.\"  ...  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(184,1,183,'１７４１１１３章短いコードを書く\n\nつまり、以下のような形式だ。\n\nbrowser-IP host [date] \"GET /url-path HTTP/1.l\" HTTP-response-code ..\n\n4xxや５江のレスポンスコードを返しているurl-pathを見つけるプログラムは、\n\nC++やJavaのような言語で書くと軽く20行を越えてしまう。\n\n一方、Unixでは、以下のコマンドを入力すればいい。\n\ncat access.log | awk \'{ print $5 \" \" $7 }\' | egrep \"[45]..$\" ^\nI sort I uniq -c | sort -nr\n出力は以下のようになる：\n\n95 /favicon.ico 404\n13 /help?topic=8 500\n11 /login 403\n\n〈カウント＞〈パス＞〈HUPレスポンスコード彦\n\nコマンドラインが素ii青らしいのは、「本物」のコードを書かなくてもいいことだ。\n\nそれから、ソース管理にチェックインしなくても済む。\n\n','章短いコードを書く  つまり、以下のような形式だ。  browser-IP host [date] \"GET /url-path HTTP/.l\" HTTP-response-code ..  xxや江のレスポンスコードを返しているurl-pathを見つけるプログラムは、  C++やJavaのような言語で書くと軽く行を越えてしまう。  一方、Unixでは、以下のコマンドを入力すればいい。  cat access.log | awk \'{ print $ \" \" $ }\' | egrep \"[]..$\" ^ I sort I uniq -c | sort -nr 出力は以下のようになる   /favicon.ico   /help?topic=   /login   〈カウント〈パス〈HUPレスポンスコード彦  コマンドラインが素ii青らしいのは、「本物」のコードを書かなくてもいいことだ。  それから、ソース管理にチェックインしなくても済む。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(185,1,184,'１３．６まとめ\n\n冒険。興奮。ジェダイはそんなものは求めておらん。\n\n１３６まとめ17５\n\n­ ヨ ー ダ\n\n本章では、できるだけコードを書かないことについて説明した。新しいコードに\nは、テストや文書や保守が必要になる。また、コードが増えると「重く」なるし、開\n発も難しくなる。\n\n新しいコードを書かないようにするには、\n\n●不必要な機能をプロダクトから削除する。過剰な機能は持たせない。\n\n●最も簡単に問題を解決できるような要求を考える。\n\n●定期的にすべてのAPIを読んで、標準ライブラリに慣れ親しんでおく。\n\n','まとめ  冒険。興奮。ジェダイはそんなものは求めておらん。  まとめ  ­ ヨ ー ダ  本章では、できるだけコードを書かないことについて説明した。新しいコードに は、テストや文書や保守が必要になる。また、コードが増えると「重く」なるし、開 発も難しくなる。  新しいコードを書かないようにするには、  ●不必要な機能をプロダクトから削除する。過剰な機能は持たせない。  ●最も簡単に問題を解決できるような要求を考える。  ●定期的にすべてのAPIを読んで、標準ライブラリに慣れ親しんでおく。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(186,1,185,'m w m\n選抜テーマ\n\nこれまでの３つの部では、コードを理解しやすくするための幅広い技法について\n\n説明した。第Ⅳ部では、これらの技法を２つのテーマに適用していきたいと思う。\n\nまずは、効果的で読みやすいテストの書き方について議論する。\n次に、特定用途のデータ構造（｢分／時間カウンタ｣）の設計と実装を検討し、パ\n\nフォーマンス．優れた設計・読みやすさが相互に作用する例を見ていこう。\n\n','m w m 選抜テーマ  これまでのつの部では、コードを理解しやすくするための幅広い技法について  説明した。第Ⅳ部では、これらの技法をつのテーマに適用していきたいと思う。  まずは、効果的で読みやすいテストの書き方について議論する。 次に、特定用途のデータ構造｢分時間カウンタ｣の設計と実装を検討し、パ  フォーマンス優れた設計・読みやすさが相互に作用する例を見ていこう。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(187,1,186,'\'\n１７９\n\n穏亀章\nテストと読みやすさ\n\n1 - 割 ̅ 州\n\n1\n\n \n\n1\n\n','\'   穏亀章 テストと読みやすさ   - 割 ̅ 州         ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(188,1,187,'180 I   14章テストと読みやすさ\n\n本章では、スッキリと効果的なテストを書くための簡単な技法を教えよう。\nテストというのは人によって意味が違う。本章における「テスト」とは､他の（｢本\n物」の）コードの振る舞いを確認するためのすべてのコードのことだ。ここでは、テ\nストの読みやすさを中心に扱うので、本物のコードよりも先にテストコードを書くべ\nき（｢テスト駆動開発｣）といったテスト開発の哲学については触れないことにする。\n１４．１テストを読みやすくて保守しやすいものにする\nテストコードを読みやすくするのは、テスト以外のコードを読みやすくするのと同\nじくらい大切なことだ。テストコードというのは「本物のコードの動作と使い方を示\nした非公式的な文書」だと考えるプログラマもいるほどである。テストが読みやすけ\nれば、本物のコードの動作が理解しやすくなる。\n\n(cid:20276) と な る 考 え\n他のプログラマが安心してテストの追加や変更ができるように、テストコードを読みやす\nくする。\n\nテストコードが大きくて恐ろしいものだとしたら、以下のようなことが起きる。\n\n●本物のコードを修正するのを恐れる。­「うへえ。このコードには手を出\n\nしたくないなあ。テストを変更するなんて悪夢だよ！」\n\n●\n\n新しいコードを書いたときにテストを追加しなくなる。­テストのあるモ\nジュールが減っていく。そして、コードが正しく動いているのか自信が持て\nなくなる。\n\nコードのユーザ（特に自分！）には、テストコードを安心して使ってもらいたい。\nテストコードを変更したことで既存のテストが壊れたとしても、簡単に原因を突き止\nめられるようにしておきたい。そうすれば、安心してテストを追加できるようにな\nる\n\n４．２このテストのどこがダメなの？\nぼくたちのコードには、検索結果のスコアをソートしてフィルタする関数がある。\n\n関数の宣言は、以下のようになっている。\n\n。 １\n\n',' I   章テストと読みやすさ  本章では、スッキリと効果的なテストを書くための簡単な技法を教えよう。 テストというのは人によって意味が違う。本章における「テスト」とは､他の｢本 物」のコードの振る舞いを確認するためのすべてのコードのことだ。ここでは、テ ストの読みやすさを中心に扱うので、本物のコードよりも先にテストコードを書くべ き｢テスト駆動開発｣といったテスト開発の哲学については触れないことにする。 テストを読みやすくて保守しやすいものにする テストコードを読みやすくするのは、テスト以外のコードを読みやすくするのと同 じくらい大切なことだ。テストコードというのは「本物のコードの動作と使い方を示 した非公式的な文書」だと考えるプログラマもいるほどである。テストが読みやすけ れば、本物のコードの動作が理解しやすくなる。  (cid:) と な る 考 え 他のプログラマが安心してテストの追加や変更ができるように、テストコードを読みやす くする。  テストコードが大きくて恐ろしいものだとしたら、以下のようなことが起きる。  ●本物のコードを修正するのを恐れる。­「うへえ。このコードには手を出  したくないなあ。テストを変更するなんて悪夢だよ」  ●  新しいコードを書いたときにテストを追加しなくなる。­テストのあるモ ジュールが減っていく。そして、コードが正しく動いているのか自信が持て なくなる。  コードのユーザ特に自分には、テストコードを安心して使ってもらいたい。 テストコードを変更したことで既存のテストが壊れたとしても、簡単に原因を突き止 められるようにしておきたい。そうすれば、安心してテストを追加できるようにな る  このテストのどこがダメなの ぼくたちのコードには、検索結果のスコアをソートしてフィルタする関数がある。  関数の宣言は、以下のようになっている。  。   ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(189,1,188,'１４３テストを読みやすくするʼ１８１\n\n// \'docs\'をスコアでソートする（降順)。マイナスのスコアは削除する。\nvoid SortAndFilterDocs(vector<ScoredDocument>* docs);\n\n最初のテストは以下のようになっていた。\n\nvoid TestlQ {\n\nvector<ScoredDocument> docs;\ndocs.resize(5);\ndocs[ol.url = \"http://example・com\":\ndocs[0]・score = -5.o;\ndocs[l].url = \"http://example.com\";\ndocsﬂ].score = l;\ndocs[2].url = \"http://example.com\";\ndocs[2].score = 4;\ndocs[3].url = \"http://example.com\";\ndocs[3].score = -99998.7;\ndocs[4].url = \"http://example.com\";\ndocs[4].score = 3.0;\nSortAndFilterDocs(&docs):\nassert(docs・sizeQ == 3);\nassert(docs[o].score == 4);\nassert(docs[l].score == 3.0);\nassert(docs[2]・score == i);\n\nこのテストコードには少なくとも８つの問題がある。本章が終わるまでに全部見\n\nつけて修正していこう。\n\n１４．３テストを読みやすくする\n一般的な設計原則として、「大切ではない詳細はユーザから隠し、大切な詳細は目\n\n立つようにする」べきだ。\n\n前節のテストコードは、明らかにこの原則を破っている。どうでもいい\n｢vector<ScoredDocument>の設定」がいちばん目立っている。url・Score・docs[］\nなどというのは、C++のオブジェクトを設定する詳細であって、テストの内容を高\nレベルから示したものではない。\n\nこれをキレイにするには、最初に以下のようなヘルパー関数を作る。\n\n','テストを読みやすくするʼ  // \'docs\'をスコアでソートする降順)。マイナスのスコアは削除する。 void SortAndFilterDocs(vector<ScoredDocument>* docs);  最初のテストは以下のようになっていた。  void TestlQ {  vector<ScoredDocument> docs; docs.resize(); docs[ol.url = \"・com\": docs[]・score = -.o; docs[l].url = \"\"; docsﬂ].score = l; docs[].url = \"\"; docs[].score = ; docs[].url = \"\"; docs[].score = -.; docs[].url = \"\"; docs[].score = .; SortAndFilterDocs(&docs): assert(docs・sizeQ == ); assert(docs[o].score == ); assert(docs[l].score == .); assert(docs[]・score == i);  このテストコードには少なくともつの問題がある。本章が終わるまでに全部見  つけて修正していこう。  テストを読みやすくする 一般的な設計原則として、「大切ではない詳細はユーザから隠し、大切な詳細は目  立つようにする」べきだ。  前節のテストコードは、明らかにこの原則を破っている。どうでもいい ｢vector<ScoredDocument>の設定」がいちばん目立っている。url・Score・docs[］ などというのは、C++のオブジェクトを設定する詳細であって、テストの内容を高 レベルから示したものではない。  これをキレイにするには、最初に以下のようなヘルパー関数を作る。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(190,1,189,'１８２１１４章テストと読みやすさ\n\nvoid MakeScoredDoc(ScoredDocument* sd, double score, string url) {\n\nsd->score = score;\nsd->url = url;\n\nの関数を使うと、テストコードはずっと簡潔になる。\n\nvoid TestlQ {\n\nvector<ScoredDocument> docs;\ndocs・resize(5);\nMakeScoredDoc(&docs[o], -5.0, \"http://example・com\");\nMakeScoredDoc(&docs[l], 1, \"http://example.com\");\nMakeScoredDoc(&docs[2], 4, \"http://example・com\");\nMakeScoredDoc(&docs[3], -99998.7, \"http://example・com\");\n\n● ● ●｝\nこれでも不十分だ。どうでもいいことがまだ目立っている。例えば、\"http://\nexample・com\"という引数は目障りだ。どうでもいいのにずっと登場している。\nScoredDocumentに渡すことができれば、URLは何だっていい。\n\n他には、docs・resize(5)や&docs[o]や&docs[l]なんかが邪魔だ。ヘルパー関数\n\nを修正して、AddScoredDoc()という名前に変えよう。\n\nvoid AddScoredDoc(vector<ScoredDocument>& docs, double score) {\n\nの関数を使うと、テストコードはもっと簡潔になる。\n\nScoredDocument sd;\nsd・score = score;\nsd･url = \"http://example･com\";\ndocs.push back(sd);\n\nvoid TestlQ {\n\nvector<ScoredDocument> docs;\nAddScoredDoc(docs, -5.0);\nAddScoredDoc(docs, l);\nAddScoredDoc(docs, 4);\nAddScoredDoc(docs, -99998.7);\n\n｝\n\n｝ こ\n\n｝ こ\n\n','章テストと読みやすさ  void MakeScoredDoc(ScoredDocument* sd, double score, string url) {  sd->score = score; sd->url = url;  の関数を使うと、テストコードはずっと簡潔になる。  void TestlQ {  vector<ScoredDocument> docs; docs・resize(); MakeScoredDoc(&docs[o], -., \"・com\"); MakeScoredDoc(&docs[l], , \"\"); MakeScoredDoc(&docs[], , \"・com\"); MakeScoredDoc(&docs[], -., \"・com\");  ● ● ●｝ これでも不十分だ。どうでもいいことがまだ目立っている。例えば、\" example・com\"という引数は目障りだ。どうでもいいのにずっと登場している。 ScoredDocumentに渡すことができれば、URLは何だっていい。  他には、docs・resize()や&docs[o]や&docs[l]なんかが邪魔だ。ヘルパー関数  を修正して、AddScoredDoc()という名前に変えよう。  void AddScoredDoc(vector<ScoredDocument>& docs, double score) {  の関数を使うと、テストコードはもっと簡潔になる。  ScoredDocument sd; sd・score = score; sd･url = \"･com\"; docs.push back(sd);  void TestlQ {  vector<ScoredDocument> docs; AddScoredDoc(docs, -.); AddScoredDoc(docs, l); AddScoredDoc(docs, ); AddScoredDoc(docs, -.);  ｝  ｝ こ  ｝ こ  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(191,1,190,'１４３テストを読みやすくするʼ１８：\n\nだいぶよくなった。でも、まだ「楽に読み書きできる」テストじゃない。新しい文\n書の一覧をテストしようと思ったら、コードを大量にコピペしなければいけない。さ\nらに改善するにはどうすればいいだろうか？\n\n最 小 の テ ス ト を 作 る\n\nこのテストコードを改善するには、「１２章コードに思いを込める」の技法を使お\n\nう。このテストが何をしようとしているのかを簡単な言葉で説明するのだ。\n\n文書のスコアは[­５，１，４，-99998.7,3]である。\nSortAndFilterDocsQを呼び出したあとのスコアは[４, ３, 1であるく\nスコアはこの順番でなければいけない。\n\nこの説明には、vector<ScoredDocument>の記述はどこにもない。いちばん大切も\n\nのはスコアの配列なのだ。テストコードは以下のようになるといいだろう。\n\nCheckScoresBeforeAfter(\"-5, 1, 4, -99998.7, 3\", \"4, 3, l\");\n\nテストの本質を１行にまとめることができた！\nこれは珍しいことではない。テストの本質というのは、「こういう状況と入力から、\nこういう振る舞いと出力を期待する」のレベルまで要約できる。そして、これは１\n行でまとめられることが多い。コードを簡潔に読みやすくするだけでなく、テストス\nテートメントを短くすることで、テストケースの追加が簡単になる。\n\n独自の「ミニ言語」を実装する\nCheckScoresBeforeAfterQには、スコアの並びを表す文字列の引数が２つある\n最近のC++では、以下のように配列リテラルをそのまま引数として渡せるようになで\nている。\n\nCheckScoresBeforeAfter({-5, 1, 4, -99998.7, 3}, {4, 3, l});\n\n当時はこう書くことができなかったので、スコアをカンマで区切った文字列を渡し\n\nて、CheckScoresBeforeAfter()で引数をパースする必要があった。\n\n独自のミニ言語を定義すれば、小さな領域で多くの情報を表現できる。printf()\n\nや正規表現ライブラリなども、文字列で別の意味を表現できるようになっている。\n\n','テストを読みやすくするʼ  だいぶよくなった。でも、まだ「楽に読み書きできる」テストじゃない。新しい文 書の一覧をテストしようと思ったら、コードを大量にコピペしなければいけない。さ らに改善するにはどうすればいいだろうか  最 小 の テ ス ト を 作 る  このテストコードを改善するには、「章コードに思いを込める」の技法を使お  う。このテストが何をしようとしているのかを簡単な言葉で説明するのだ。  文書のスコアは[­-.,]である。 SortAndFilterDocsQを呼び出したあとのスコアは[, , であるく スコアはこの順番でなければいけない。  この説明には、vector<ScoredDocument>の記述はどこにもない。いちばん大切も  のはスコアの配列なのだ。テストコードは以下のようになるといいだろう。  CheckScoresBeforeAfter(\"-, , , -., \", \", , l\");  テストの本質を行にまとめることができた これは珍しいことではない。テストの本質というのは、「こういう状況と入力から、 こういう振る舞いと出力を期待する」のレベルまで要約できる。そして、これは 行でまとめられることが多い。コードを簡潔に読みやすくするだけでなく、テストス テートメントを短くすることで、テストケースの追加が簡単になる。  独自の「ミニ言語」を実装する CheckScoresBeforeAfterQには、スコアの並びを表す文字列の引数がつある 最近のC++では、以下のように配列リテラルをそのまま引数として渡せるようになで ている。  CheckScoresBeforeAfter({-, , , -., }, {, , l});  当時はこう書くことができなかったので、スコアをカンマで区切った文字列を渡し  て、CheckScoresBeforeAfter()で引数をパースする必要があった。  独自のミニ言語を定義すれば、小さな領域で多くの情報を表現できる。printf()  や正規表現ライブラリなども、文字列で別の意味を表現できるようになっている。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(192,1,191,'１８４１１４章テストと読みやすさ\n\nカンマ区切りの数値をパースするヘルパー関数を書くのは難しいことではない。\n\nCheckScoresBeforeAfter()は以下のようになる。\n\n全を期するために、文字列とvector<ScoredDocument>を変換するヘルパー関数\n\n｝ 完\n\nvoid CheckScoresBeforeAfter(string input, string expected output) {\n\nvector<ScoredDocument> docs = ScoredDocsFromString(input);\nSortAndFilterDocs(&docs);\nstring output = ScoredDocsToString(docs);\nassert(output == expected output);\n\nードが多いように見えるけど､CheckScoresBeforeAfterQを呼び出すだけでテ\n\nも載せておこう。\n\nvector<ScoredDocument> ScoredDocsFromString(string scores) {\n\nvector<ScoredDocument> docs;\nreplace(scores・begin(), scores・end   , V, \' \');\n\n/／空白区切りの文字列から\'docs\'を作る。\ni\nstringstream stream(scores);\ndouble score;\nwhile (stream  score) {\n\nAddScoredDoc(docs, score);\n\neturn docs:\n\n｝ r\n\nstring ScoredDocsToString(vector<ScoredDocument> docs) {\n\nostringstream stream;\nfor (int i = 0; i < docs.sizeQ; i++) {\n\nif (i > 0) stream  \", \";\nstream  docs[il.score;\n\neturn stream.strQ;\n\n｝ r\n\n｝ コ\n\n','章テストと読みやすさ  カンマ区切りの数値をパースするヘルパー関数を書くのは難しいことではない。  CheckScoresBeforeAfter()は以下のようになる。  全を期するために、文字列とvector<ScoredDocument>を変換するヘルパー関数  ｝ 完  void CheckScoresBeforeAfter(string input, string expected output) {  vector<ScoredDocument> docs = ScoredDocsFromString(input); SortAndFilterDocs(&docs); string output = ScoredDocsToString(docs); assert(output == expected output);  ードが多いように見えるけど､CheckScoresBeforeAfterQを呼び出すだけでテ  も載せておこう。  vector<ScoredDocument> ScoredDocsFromString(string scores) {  vector<ScoredDocument> docs; replace(scores・begin(), scores・end   , V, \' \');  /空白区切りの文字列から\'docs\'を作る。 i stringstream stream(scores); double score; while (stream  score) {  AddScoredDoc(docs, score);  eturn docs:  ｝ r  string ScoredDocsToString(vector<ScoredDocument> docs) {  ostringstream stream; for (int i = ; i < docs.sizeQ; i++) {  if (i > ) stream  \", \"; stream  docs[il.score;  eturn stream.strQ;  ｝ r  ｝ コ  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(193,1,192,'１４４エラーメッセージを読みやすくするʼ１８畳\n\nストが書けるようになるのだから強力だ。これならもっとたくさんテスl､を書きたく\nなる（これは本章の後半で扱う予定だ)。\n１４．４エラーメッセージを読みやすくする\n\n機械が\n\n見つかりましたよ！\n｢READY(準備完了川\nʻになったようです。\n\n唾\n\n喫獅\n\n旧蕊』０\n\n｡ 号\n｡ 完\n\n｡\n0\n\n｡\n｡\n\nｉＬ­\n\n｡\n｡\n\n｡\n｡ 。 ｡\n\n｡ 。 ｡ ＆\nc\n\n｡\n\n等官\n\n､\n\n(cid:9356) エ ラ ー が 点 滅 し て -\n｢RDY｣と表示されてるんだ\n、 意 味 な ん だ ろ う ？ 〃\n\nけど､これってどういう\n\n◎ ｡\n\n｡\n\n｡ ◎\n\n蝿\n\nへ\n\n祝 詞\n\nＬ\n\n＝\n\n＜ ­\n\n先ほどのコードは素H肯らしかった。でも、assert(output == expected output)か\n失敗したらどうなるんだろう？おそらく以ﾄのようなエラーメッセージが表示され\nるはずだ。\n\nAssertion failed: (output == expected output),\n\nfunction CheckScoresBeforeAfter, file test・cc, line 37\n\nこのエラーを目にしたら「output  ^  expected  outputの仙はどうなってんの？」\n\nと,1うだろう。\n\nもっといいassertQを使う\n多くの言語やライブラリには、洗練されたassertQが用(cid:7802)されている。以下のよ\nうに書く代わりに、\n\n','エラーメッセージを読みやすくするʼ畳  ストが書けるようになるのだから強力だ。これならもっとたくさんテスl､を書きたく なるこれは本章の後半で扱う予定だ)。 エラーメッセージを読みやすくする  機械が  見つかりましたよ ｢READY(準備完了川 ʻになったようです。  唾  喫獅  旧蕊』  ｡ 号 ｡ 完  ｡   ｡ ｡  ｉＬ­  ｡ ｡  ｡ ｡ 。 ｡  ｡ 。 ｡  c  ｡  等官  ､  (cid:) エ ラ ー が 点 滅 し て - ｢RDY｣と表示されてるんだ 、 意 味 な ん だ ろ う  〃  けど､これってどういう  ◎ ｡  ｡  ｡ ◎  蝿  へ  祝 詞  Ｌ     ­  先ほどのコードは素H肯らしかった。でも、assert(output == expected output)か 失敗したらどうなるんだろうおそらく以ﾄのようなエラーメッセージが表示され るはずだ。  Assertion failed: (output == expected output),  function CheckScoresBeforeAfter, file test・cc, line   このエラーを目にしたら「output  ^  expected  outputの仙はどうなってんの」  と,うだろう。  もっといいassertQを使う 多くの言語やライブラリには、洗練されたassertQが用(cid:)されている。以下のよ うに書く代わりに、  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(194,1,193,'１８６１１４章テストと読みやすさ\n\nassert(output == expected output);\n\nBoost C++ライブラリを使って、\n\nBOOST REQUIRE EOUAL(output, expected output)\n\nこう書ける。テストが失敗すると、以下のような詳細なメッセージが表示される。\n\ntest.cc(37): fatal error in \"CheckScoresBeforeAfter\": critical check\n\noutput == expected output failed \"1, 3, 4\" != \"4, 3, l\"]\n\nこっちのほうがいいよれ。\nもし使えるのであれば、便利なアサーションメソッドを使うべきだ。テストが失敗\n\nするたびに役に立つ。\n\nその他の言語のassertO\n\nPythonに組み込まれたassert  a  ==  bは、以下のような普通のエラーメッセージを表\n\n示する。\n\nFile \"file･py , line X, in <module>\n\nassert a == b\n\nAssertionError\n\n代わりに、unittestモジュールのassertEqualQメソッドが使える。\n\nimport unittest\nc\nl\nass MyTestCasefunittest.TestCase :\n\ndef testFunction(self):\n\nａ＝１\nb = 2\nself.assertEqual(a, b)\n\nif     name     == \'    main    \':\n\nー\n\n一\n\n一\n\n­\n\n­\n\n一\n\n■\n\n■\n\n一\n\nunittest・mainQ\n\n■\n\nこれは以下のようなエラーメッセージを表示する。\n\n','章テストと読みやすさ  assert(output == expected output);  Boost C++ライブラリを使って、  BOOST REQUIRE EOUAL(output, expected output)  こう書ける。テストが失敗すると、以下のような詳細なメッセージが表示される。  test.cc(): fatal error in \"CheckScoresBeforeAfter\": critical check  output == expected output failed \", , \" != \", , l\"]  こっちのほうがいいよれ。 もし使えるのであれば、便利なアサーションメソッドを使うべきだ。テストが失敗  するたびに役に立つ。  その他の言語のassertO  Pythonに組み込まれたassert  a  ==  bは、以下のような普通のエラーメッセージを表  示する。  File \"file･py , line X, in <module>  assert a == b  AssertionError  代わりに、unittestモジュールのassertEqualQメソッドが使える。  import unittest c l ass MyTestCasefunittest.TestCase :  def testFunction(self):  ａ b =  self.assertEqual(a, b)  if     name     == \'    main    \':  ー  一  一  ­  ­  一  ■  ■  一  unittest・mainQ  ■  これは以下のようなエラーメッセージを表示する。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(195,1,194,'１４４エラーメッセージを読みやすくするʼ１８７\n\nFile \"MyTestCase・py , line 7, in testFunctior\n\nself.assertEqual(a, b)\n\nAssertionError：１１＝２\n\nどの言語を使っていても、役に立つライブラリやフレームワーク(xUnitなど）がきっ\n\nとあるはずだ。ライブラリのことを知っておくといいだろう！\n\n手作りのエラーメッセージ\nBOOST REQUIRE EQUAL()を使うと、エラーメッセージがいい感じになる。\n\noutput == expected output failed [\"1, 3, 4\" != \"4, 3, 1\"\n\nでも、もっといい感じにしたい。例えば、以下のようなエラーメッセージがよさそ\n\nうだ。\n\nCheckScoresBeforeAfterQ failed,\n\nʼ\n\'\n­５，１）４，-99998.7,3Ⅱ\n\nInput:\nExpected Output: \"4, 3, 1\"\nActual Output:  \"1, 3, 4\"\n\nこういうエラーメッセージが欲しいなら、自分で書けばいいʼ\n\nvoid CheckScoresBeforeAften…）｛\n\n● ● ●\n\nif (output != expected_output) {\n\ncerr  \"CheckScoresBeforeAfterQ failed,\"  endl;\ncerr  \"Input:\ncerr  \"Expected Output: ¥\"\"  expected output  \"¥\"\"  endl\ncerr  \"Actual Output:  ¥\"\"  output  \"¥\"\"  endl;\nabort();\n\n¥\"\"    input    \"¥\"\"    endl;\n\n｝\n\nこの話の教訓は、「エラーメッセージはできるだけ役に立つようにする」だ。もし\nかすると、自分好みのエラーメッセージを印字する「手作りのアサート」を用意する\nのが最善の道かもしれない。\n\n','エラーメッセージを読みやすくするʼ  File \"MyTestCase・py , line , in testFunctior  self.assertEqual(a, b)  AssertionError  どの言語を使っていても、役に立つライブラリやフレームワーク(xUnitなどがきっ  とあるはずだ。ライブラリのことを知っておくといいだろう  手作りのエラーメッセージ BOOST REQUIRE EQUAL()を使うと、エラーメッセージがいい感じになる。  output == expected output failed [\", , \" != \", , \"  でも、もっといい感じにしたい。例えば、以下のようなエラーメッセージがよさそ  うだ。  CheckScoresBeforeAfterQ failed,  ʼ \' ­-.,Ⅱ  Input: Expected Output: \", , \" Actual Output:  \", , \"  こういうエラーメッセージが欲しいなら、自分で書けばいいʼ  void CheckScoresBeforeAften…｛  ● ● ●  if (output != expected_output) {  cerr  \"CheckScoresBeforeAfterQ failed,\"  endl; cerr  \"Input: cerr  \"Expected Output: ¥\"\"  expected output  \"¥\"\"  endl cerr  \"Actual Output:  ¥\"\"  output  \"¥\"\"  endl; abort();  ¥\"\"    input    \"¥\"\"    endl;  ｝  この話の教訓は、「エラーメッセージはできるだけ役に立つようにする」だ。もし かすると、自分好みのエラーメッセージを印字する「手作りのアサート」を用意する のが最善の道かもしれない。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(196,1,195,'1８8     14章テストと読みやすさ\n\n１４．５テストの適切な入力値を選択する\nテストの適切な入力値を選択するには優れた技能が必要だ。今使っている値はでた\n\nらめだ。\n\nCheckScoresBeforeAfter \"-5, 1, 4, -99998.7, 3\",   \"4, 3, l\");\n\nどうすれば適切な入力値を選択できるのだろう？適切な入力値というのは、コー\nドを完全にテストするものでなければいけない。それに簡単に読めるような単純なも\nのでなければいけない。\n\n(cid:20276)となる考え\nコードを完全にテストする最も単純な入力値の組み合わせを選択しなければいけない（\n\n例えば、以下のように書いたとするｃ\n\nCheckScoresBeforeAfterf\'l, 2, 3\", \"3, 2, 1\");\n\nこのテストは単純だ。でも、SortAndFilterDocsQの「マイナスのスコアをフィル\nタする」という動作がテストできていない。この部分にバグがあったら、この入力値\nでは検知できない。\n\n正反対なのは、以下のようなテストだ。\n\nCheckScoresBeforeAfter(\"l23014, -1082342, 823423, 234205, -235235\",\n\n11823423,234205,123014ʻ\')；\n\nこれらの値は必要以上に複雑だ（それにテストが不完全である)。\n\n入力値を単純化する\n入力値を改善するには何ができるだろう？\n\nCheckScoresBeforeAfter(\"-5, l, 4, -99998.7, 3\",   \"4, 3, 1\" ;\n\n最初に目につくのは「大音量」の値-99998.7だろう。これは単に「任意のマイナ\nス値」を表しているだけだ。単純化すれば­１になる（-99998.7が「ものすごいマイ\nナス値」を表しているのであれば、-leiooのような簡潔な値にしたほうがいい)。\n\n','     章テストと読みやすさ  テストの適切な入力値を選択する テストの適切な入力値を選択するには優れた技能が必要だ。今使っている値はでた  らめだ。  CheckScoresBeforeAfter \"-, , , -., \",   \", , l\");  どうすれば適切な入力値を選択できるのだろう適切な入力値というのは、コー ドを完全にテストするものでなければいけない。それに簡単に読めるような単純なも のでなければいけない。  (cid:)となる考え コードを完全にテストする最も単純な入力値の組み合わせを選択しなければいけない  例えば、以下のように書いたとするｃ  CheckScoresBeforeAfterf\'l, , \", \", , \");  このテストは単純だ。でも、SortAndFilterDocsQの「マイナスのスコアをフィル タする」という動作がテストできていない。この部分にバグがあったら、この入力値 では検知できない。  正反対なのは、以下のようなテストだ。  CheckScoresBeforeAfter(\"l, -, , , -\",  ,,ʻ\')  これらの値は必要以上に複雑だそれにテストが不完全である)。  入力値を単純化する 入力値を改善するには何ができるだろう  CheckScoresBeforeAfter(\"-, l, , -., \",   \", , \" ;  最初に目につくのは「大音量」の値-.だろう。これは単に「任意のマイナ ス値」を表しているだけだ。単純化すれば­になる-.が「ものすごいマイ ナス値」を表しているのであれば、-leiooのような簡潔な値にしたほうがいい)。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(197,1,196,'\'４５テストの適切な入力値を選択するʼ１８９\n\n(cid:20276)となる考え\nテストには最もキレイで単純な値を選ぶ。\n\nその他の値については、もっと単純な数値にできる。それから、マイナスをテスト\n\nする値は１つだけあればいい。以|､̅は、新しいバージョンのテス１，だ。\n\nCheckScoresBeforeAfterfl, 2, -1, 3\", \"3, 2, 1Ⅲハ\n\nテストの効果を変えずに１Il\'iだけ単純にすることができた。\n\n大量「破壊」テスト\n\n入力値を大量に使ってコードをテストするのはいいことだ。例えば、以下のようなテス\n\nトをしたくなるだろう。\n\nCheckScoresBeforeAfter(\"100, 38, 19, -25, 4, 84, [値がたくさんノ…\'1\n\n\"100, 99, 98, 97, 96, 95, 94, 93,…\");\n\n大三の入力値は、バッファオーバーランなどの意図しないバグを検知するのに役立つ。\nでも、数が多すぎてコードを見るのが怖い。これをストレステストにするには数が不十\n分だ。こういうときには、プログラムで入力値を作るといいだろう。（例えば)      100,000\n個の入力値を作ればいい。\n\n','\'テストの適切な入力値を選択するʼ  (cid:)となる考え テストには最もキレイで単純な値を選ぶ。  その他の値については、もっと単純な数値にできる。それから、マイナスをテスト  する値はつだけあればいい。以|､̅は、新しいバージョンのテスだ。  CheckScoresBeforeAfterfl, , -, \", \", , Ⅲハ  テストの効果を変えずにIl\'iだけ単純にすることができた。  大量「破壊」テスト  入力値を大量に使ってコードをテストするのはいいことだ。例えば、以下のようなテス  トをしたくなるだろう。  CheckScoresBeforeAfter(\", , , -, , , [値がたくさんノ…\'  \", , , , , , , ,…\");  大三の入力値は、バッファオーバーランなどの意図しないバグを検知するのに役立つ。 でも、数が多すぎてコードを見るのが怖い。これをストレステストにするには数が不十 分だ。こういうときには、プログラムで入力値を作るといいだろう。例えば)      , 個の入力値を作ればいい。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(198,1,197,'１90      14章テストと読みやすさ\n\n１ つ の 機 能 に 複 数 の テ ス ト\n\nコードを検証する「完ぺき」な入力値を１つ作るのではなく、小さなテストを複\n\n数作るほうが、簡単で、効果的で、読みやすい。\n\n複数のテストで別々の方向からバグを見つけ出すようにする。例えば、\n\nSortAndFilterDocsQには４つのテストがある。\n\nCheckScoresBeforeAfter(\"2, 1, 3\", \"3, 2, l\");\nCheckScoresBeforeAfter(\"0, -0.i, -io\", \"0\");\nCheckScoresBeforeAfter(\"l, -2, l, -2\", \"l, 1\");\nCheckScoresBeforeAfter(\"\", \"\");\n\n/／ソート\n/／マイナスは削除\n/／重複は許可\n/／空の入力は許可\n\nもっと丁寧にやりたければ、テストを増やすこともできる。テストケースが分割さ\nれていれば、次の人がコードを扱いやすくなる。意図せずにバグを発生させたとして\nも、失敗したテストによってその場所がわかる。\n１４．６テストの機能に名前をつける\nテストコードは関数になっていることが多い。関数はテストするメソッドや状況\nでひとまとめにする。例えば､SortAndFilterDocsQをテストするコードは、関数\nTestlQに入れていた。\n\nvoid TestlQ {\n\nスト関数に名前をつけるのは、退屈で無駄なことだと思うかもしれない。でも、\n\n● ● ●\n\n｝ テ\n\nTestlQやTest2(のような意味のない名前をつけてはいけない。\n\nテストの内容を表した名前をつけるべきだ。テストコードを読む人が、以下のこと\n\nをすぐに理解できるものがいい。\n\n●テストするクラス（もしあれば）\n\n●テストする関数\n\n●テストする状況やバグ\n\n','      章テストと読みやすさ   つ の 機 能 に 複 数 の テ ス ト  コードを検証する「完ぺき」な入力値をつ作るのではなく、小さなテストを複  数作るほうが、簡単で、効果的で、読みやすい。  複数のテストで別々の方向からバグを見つけ出すようにする。例えば、  SortAndFilterDocsQにはつのテストがある。  CheckScoresBeforeAfter(\", , \", \", , l\"); CheckScoresBeforeAfter(\", -.i, -io\", \"\"); CheckScoresBeforeAfter(\"l, -, l, -\", \"l, \"); CheckScoresBeforeAfter(\"\", \"\");  /ソート /マイナスは削除 /重複は許可 /空の入力は許可  もっと丁寧にやりたければ、テストを増やすこともできる。テストケースが分割さ れていれば、次の人がコードを扱いやすくなる。意図せずにバグを発生させたとして も、失敗したテストによってその場所がわかる。 テストの機能に名前をつける テストコードは関数になっていることが多い。関数はテストするメソッドや状況 でひとまとめにする。例えば､SortAndFilterDocsQをテストするコードは、関数 TestlQに入れていた。  void TestlQ {  スト関数に名前をつけるのは、退屈で無駄なことだと思うかもしれない。でも、  ● ● ●  ｝ テ  TestlQやTest(のような意味のない名前をつけてはいけない。  テストの内容を表した名前をつけるべきだ。テストコードを読む人が、以下のこと  をすぐに理解できるものがいい。  ●テストするクラスもしあれば  ●テストする関数  ●テストする状況やバグ  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(199,1,198,'１４６テストの機能に名前をつけるʼ１９１\n\nテスト関数にいい名前をつけるには、まずはʻ\"Iもst \"という接頭辞をつけて情報を\n\nひとまとめにするといいだろう。\n\n例えば､TestlQという名前にするのではなく、Test  <関数名>という形式6;\n\nする。\n\nvoid Test SortAndFilterDocsQ\n\nに、状況に応じてこのテスト関数を分割するかどうかを考える。分割する場合\n\nは、Test <関数名> <状況>という形式にすればいい。\n\n｝ 次\n\n長くて変な名前にならないかと怖がることはない。他のコードから呼び出されるも\nのではないので、長くなっても構わない。テスト関数の名前はコメントだと思えばい\nい。ほとんどのテステイングフレームワークでは、テストが失敗したらその関数の名\n前が印字されるようになっている。だから、名前は説明的なほうが役に立つのであ\n。\nる\nテスティングフレームワークを使っていれば、メソッド名の規則や規約があるかも\nしれない。例えば、Pythonのunittestモジュールでは、テストメソッドの名前は\ntestで始めなければいけない。\n\nテストコードのヘルパー関数の名前は、アサートを使っているかどうかで決めれは\nいい。本章では、assertQを呼び出しているヘルパー関数は、すべてCheck…(）と\nいう名前にしている。一方､AddScoredDocQは、普通のヘルパー関数のような名前\nにしている。\n\no\ni\nd Test SortAndFilterDocs NegativeValuesQ ¥\n● ● ●｝\n\n｝ v\n\nvoid Test SortAndFilterDocs BasicSortingQ\n\n● ● ●\n\n','テストの機能に名前をつけるʼ  テスト関数にいい名前をつけるには、まずはʻ\"Iもst \"という接頭辞をつけて情報を  ひとまとめにするといいだろう。  例えば､TestlQという名前にするのではなく、Test  <関数名>という形式;  する。  void Test SortAndFilterDocsQ  に、状況に応じてこのテスト関数を分割するかどうかを考える。分割する場合  は、Test <関数名> <状況>という形式にすればいい。  ｝ 次  長くて変な名前にならないかと怖がることはない。他のコードから呼び出されるも のではないので、長くなっても構わない。テスト関数の名前はコメントだと思えばい い。ほとんどのテステイングフレームワークでは、テストが失敗したらその関数の名 前が印字されるようになっている。だから、名前は説明的なほうが役に立つのであ 。 る テスティングフレームワークを使っていれば、メソッド名の規則や規約があるかも しれない。例えば、Pythonのunittestモジュールでは、テストメソッドの名前は testで始めなければいけない。  テストコードのヘルパー関数の名前は、アサートを使っているかどうかで決めれは いい。本章では、assertQを呼び出しているヘルパー関数は、すべてCheck…(と いう名前にしている。一方､AddScoredDocQは、普通のヘルパー関数のような名前 にしている。  o i d Test SortAndFilterDocs NegativeValuesQ ¥ ● ● ●｝  ｝ v  void Test SortAndFilterDocs BasicSortingQ  ● ● ●  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(200,1,199,'１９２１１４章テストと読みやすさ\n\n１４.了このテストのどこがダメだったのか？\n本章の最初に、このテストコードには少なくとも８つの問題があると言った。\n\nvoid Testl    {\n\nvector<ScoredDocument> docs;\ndocs.resize(5);\ndocs[0].url = \"http://example.com\";\ndocs[o].score = -5.0;\ndocs[l].url = \"http://example.com\";\ndocs[l].score = 1;\ndocs[2].url = \"http://example.com\";\ndocs[2]・score = 4;\ndocs[3].url = \"http://example・com\";\ndocs[3].score = -99998.7;\ndocs[4].url = \"http://example.com\";\ndocs[4].score = 3.o;\nSortAndFilterDocs(&docs;\nassert(docs・sizeQ == 3);\nassert(docs[o].score == 4);\nassert(docs[l].score == 3.0);\nassert(docs[2]・score == l);\n\nこれまでに優れたテストの書き方をいくつか学んできた。さあ、問題点を見つけて\n\nいこう。\n\n1\nʻ\n\nこのテストには、どうでもいいことがたくさん書かれている。テストが何を\nしているかは１つの文で記述できる。テストステートメントはあまり長く\nしてはいけない。\n\n2．テストが簡単に追加できない。思わずコピペしてしまいそうになる。そうな\n\n3\n．\n\nれば、長くて重複の多いコードになってしまう。\n失敗メッセージが役に立たない。このテストが失敗すると、「Assertion\nfailed: docs.sizeQ == 3」と表示されるだけだ。デバッグに使える情報\nが足りない。\n\n','章テストと読みやすさ  .了このテストのどこがダメだったのか 本章の最初に、このテストコードには少なくともつの問題があると言った。  void Testl    {  vector<ScoredDocument> docs; docs.resize(); docs[].url = \"\"; docs[o].score = -.; docs[l].url = \"\"; docs[l].score = ; docs[].url = \"\"; docs[]・score = ; docs[].url = \"・com\"; docs[].score = -.; docs[].url = \"\"; docs[].score = .o; SortAndFilterDocs(&docs; assert(docs・sizeQ == ); assert(docs[o].score == ); assert(docs[l].score == .); assert(docs[]・score == l);  これまでに優れたテストの書き方をいくつか学んできた。さあ、問題点を見つけて  いこう。   ʻ  このテストには、どうでもいいことがたくさん書かれている。テストが何を しているかはつの文で記述できる。テストステートメントはあまり長く してはいけない。  テストが簡単に追加できない。思わずコピペしてしまいそうになる。そうな     れば、長くて重複の多いコードになってしまう。 失敗メッセージが役に立たない。このテストが失敗すると、「Assertion failed: docs.sizeQ == 」と表示されるだけだ。デバッグに使える情報 が足りない。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(201,1,200,'１４８テストに優しい開発ʼ１９３\n\n4．一度にすべてのことをテストしようとしている。ここではマイナスのフィル\nタリングとソートの機能のテストだ。テストは分割したほうが読みやすい。\n\n5．テストの入力値が単純ではない。-99998.7は「大音量」で目立つけど、こ\n\nれといって意味はない。もっと単純なマイナス値で十分である。\n\n6．テストの入力値が不完全である。例えば、スコアが０の文書をテストして\n\nいない（この文書はフィルタリングされるのか？されないのか？）。\n\n7．極端な入力値を使ってテストしていない。例えば、空のベクタ・巨大なベク\n\nタ・スコアが重複したものなど。\n\n8.   TestlQという意味のない名前がついている。テスト関数の名前は、テスト\n\nする関数や状況を表したものにすべきだ。\n\n１４．８テストに優しい開発\nコードにはテストしやすいものとそうでないものがある。テストしやすいコードに\nは、明確なインタフェースがある。状態や「セットアップ」がない。検査するデータ\nが隠されていない。\n\nあとでテストを書くつもりでコードを書くと、おもしろいことが起きる。テストし\nやすいようにコードを設計するようになるのだ！このようにコードを書いていけ\nば、いいコードが書けるようになる！\n\nテストに優しい設計をすれば、振る舞いごとにうまく分割されて、自然にコードが\n\n構成されていく。\n\nテスト駆動開発\n\nテスト駆動開発(TDD:  Test  Driven  Development)は、本物のコードを書く前にテ\nストを書くというプログラミング手法だ。コードを書いてからテストを書くよりもコード\nの品質が飛躍的に向上すると言われている。\n\nよく議論になる話題なので深追いはしないけど、少なくともテストのことを気にしなが\n\nらコードを書けば、コードがよくなるのはそのとおりだと思う。\n\nTDDを採用するかどうかに関わらず、他のコードをテストするコードはできあがる。本\n\n章の目標は、そのテストを読み書きしやすくすることだ。\n\n','テストに優しい開発ʼ  一度にすべてのことをテストしようとしている。ここではマイナスのフィル タリングとソートの機能のテストだ。テストは分割したほうが読みやすい。  テストの入力値が単純ではない。-.は「大音量」で目立つけど、こ  れといって意味はない。もっと単純なマイナス値で十分である。  テストの入力値が不完全である。例えば、スコアがの文書をテストして  いないこの文書はフィルタリングされるのかされないのか。  極端な入力値を使ってテストしていない。例えば、空のベクタ・巨大なベク  タ・スコアが重複したものなど。  .   TestlQという意味のない名前がついている。テスト関数の名前は、テスト  する関数や状況を表したものにすべきだ。  テストに優しい開発 コードにはテストしやすいものとそうでないものがある。テストしやすいコードに は、明確なインタフェースがある。状態や「セットアップ」がない。検査するデータ が隠されていない。  あとでテストを書くつもりでコードを書くと、おもしろいことが起きる。テストし やすいようにコードを設計するようになるのだこのようにコードを書いていけ ば、いいコードが書けるようになる  テストに優しい設計をすれば、振る舞いごとにうまく分割されて、自然にコードが  構成されていく。  テスト駆動開発  テスト駆動開発(TDD:  Test  Driven  Development)は、本物のコードを書く前にテ ストを書くというプログラミング手法だ。コードを書いてからテストを書くよりもコード の品質が飛躍的に向上すると言われている。  よく議論になる話題なので深追いはしないけど、少なくともテストのことを気にしなが  らコードを書けば、コードがよくなるのはそのとおりだと思う。  TDDを採用するかどうかに関わらず、他のコードをテストするコードはできあがる。本  章の目標は、そのテストを読み書きしやすくすることだ。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(202,1,201,'１９４１１４章テストと読みやすさ\n\nプログラムをクラスやメソッドに分割するというのは、疎結合にしたほうがテスト\nしやすいからである。プログラムが密結合していて、クラス間でメソッド呼び出しが\nたくさん行われていて、メソッド呼び出しに多くの引数が必要だったらどうだろう。\nプログラムが理解しにくいだけでなく、テストコードも汚くて読み書きしにくいもの\nになっているはずだ。\n\n「外部」コンポーネント（初期化に必要なグローバル変数や、読み込みが必要なラ\n\nイブラリや設定ファイルなど）が多いと、それだけテストを書くのが面倒になる。\n\nコードを設計していると、「う­ん、これをテストするのは難しそう」と思うこと\nがある。そういうときは、立ち止まって設計を考え直せばいい。表１４­１は、テスト\nと設計の典型的な問題を示したものだ。\n\n表１４­１テスト容易性の低いコードの特性とそこから生じる設計の問題\n驚(cid:7636)蕊識驚議驚議蕊蕊蕊驚篭撫(cid:7767)溌蕊識議(cid:20276)識鴬驚鑑識識識識識#鱗\n\nグローバルの状態をテストごと\nグローバル変数をグローバルの状態をテストごとどの関数にどんな副作用があるのか\nに初期化する必要がある（そう\n使 っ て い る 。 に 初 期 化 す る 必 要 が あ る （ そ う わ か り に く い 。 関 数 を 個 別 に 考 え る\nしないとテスト同士が干渉して\nしないとテスト同士が干渉してことができない。すべてが動くこと\nしまうc\nし ま う o を 理 解 す る に は プ ロ グ ラ ム 全 体 を 把\n\n握しなければいけない。\n\n最初に足場を設定しなければい\n多くの外部コンポ最初に足場を設定しなければい依存しているものが落ちるとシステ\nーネントに依存しけないので、テス|､を書くのがムが使えなくなる。任意の変更にど\nけないので、テス|､を書くのが\n難しい。テストを書くのが楽し\nて い る 。 難 し い 。 テ ス ト を 書 く の が 楽 し ん な 影 響 が あ る の か を 理 解 す る の が\nくないので、みんなテストを書\nくないので、みんなテストを書難しい。クラスのリファクタリング\nこうとしなくなる。\nこ う と し な く な る 。 が 難 し い 。 シ ス テ ム が 考 え な け れ ば\nいけない故障状態や回復経路が増え\nる\n。\n\nコードが非決定的テストは当てにならず、信頼でプログラムが競合状態になったり、\nテストは当てにならず、信頼で\nきない。テストが正常に動かな\nな動作をする。きない。テストが正常に動かな再現不可能なバグが発生したりする。\nいことがあるので、最終的に無\nいことがあるので、最終的に無プログラムを論理的に判断できなく\n視されるようになる。\n視 さ れ る よ う に な る 。 な る 。 バ グ を 追 跡 し た り 修 正 し た り\n\nするのが非常に難しい。\n\n一方、テストしやすい設計にしていれば、いい兆候だ。表１４­２は、有益なテスト\n\nと設計の特性を示している。\n\n','章テストと読みやすさ  プログラムをクラスやメソッドに分割するというのは、疎結合にしたほうがテスト しやすいからである。プログラムが密結合していて、クラス間でメソッド呼び出しが たくさん行われていて、メソッド呼び出しに多くの引数が必要だったらどうだろう。 プログラムが理解しにくいだけでなく、テストコードも汚くて読み書きしにくいもの になっているはずだ。  「外部」コンポーネント初期化に必要なグローバル変数や、読み込みが必要なラ  イブラリや設定ファイルなどが多いと、それだけテストを書くのが面倒になる。  コードを設計していると、「う­ん、これをテストするのは難しそう」と思うこと がある。そういうときは、立ち止まって設計を考え直せばいい。表­は、テスト と設計の典型的な問題を示したものだ。  表­テスト容易性の低いコードの特性とそこから生じる設計の問題 驚(cid:)蕊識驚議驚議蕊蕊蕊驚篭撫(cid:)溌蕊識議(cid:)識鴬驚鑑識識識識識#鱗  グローバルの状態をテストごと グローバル変数をグローバルの状態をテストごとどの関数にどんな副作用があるのか に初期化する必要があるそう 使 っ て い る 。 に 初 期 化 す る 必 要 が あ る  そ う わ か り に く い 。 関 数 を 個 別 に 考 え る しないとテスト同士が干渉して しないとテスト同士が干渉してことができない。すべてが動くこと しまうc し ま う o を 理 解 す る に は プ ロ グ ラ ム 全 体 を 把  握しなければいけない。  最初に足場を設定しなければい 多くの外部コンポ最初に足場を設定しなければい依存しているものが落ちるとシステ ーネントに依存しけないので、テス|､を書くのがムが使えなくなる。任意の変更にど けないので、テス|､を書くのが 難しい。テストを書くのが楽し て い る 。 難 し い 。 テ ス ト を 書 く の が 楽 し ん な 影 響 が あ る の か を 理 解 す る の が くないので、みんなテストを書 くないので、みんなテストを書難しい。クラスのリファクタリング こうとしなくなる。 こ う と し な く な る 。 が 難 し い 。 シ ス テ ム が 考 え な け れ ば いけない故障状態や回復経路が増え る 。  コードが非決定的テストは当てにならず、信頼でプログラムが競合状態になったり、 テストは当てにならず、信頼で きない。テストが正常に動かな な動作をする。きない。テストが正常に動かな再現不可能なバグが発生したりする。 いことがあるので、最終的に無 いことがあるので、最終的に無プログラムを論理的に判断できなく 視されるようになる。 視 さ れ る よ う に な る 。 な る 。 バ グ を 追 跡 し た り 修 正 し た り  するのが非常に難しい。  一方、テストしやすい設計にしていれば、いい兆候だ。表­は、有益なテスト  と設計の特性を示している。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(203,1,202,'１４ｇやりすぎʼ１９塁\n\n表１４­２テスト容易性の高いコードの特性とそこから生じる設計の利点\n|驚議騨驚(cid:20276)(cid:20276)驚(cid:20276)蕊溌鑑識驚(cid:7767)藤蕊蕊蕊識鱗驚蕊(cid:7767)蕊難(cid:20276)蕊織(cid:7767)(cid:20276)議(cid:7767)｜\n\nテストがしやすい。メソッドを\nクラスが小さい。テストがしやすい。メソッドを状態の少ないクラスは単純で理解し\nテストするのにセットアップが\nあ る い は 内 部 状 態 テ ス ト す る の に セ ッ ト ア ッ プ が や す い 。\nを 持 た な い 。 あ ま り 必 要 に な ら な い 。 検 査 す\nあまり必要にならない。検査す\nる状態が隠されていない。\n完全にテストをするためのテス\nトケースが少なくて済む。\n\n各クラスは独立してテストでき\nる（複数のクラスを同時にテス\nトするよりもずっと簡単)。\n\n小さくて単純なコンポーネントがモ\nジュール化されている。システムは\n疎結合である。\nシステムは並列的に開発できる。ク\nラスは他の部分を気にすることなく\n簡単に修正や削除ができる。\n\n明確な動作をテストできる。単\n純なインタフェースなのでテス\nトが楽。\n\nインタフェースがわかりやすくて再\nﾄ|｣川しやすい。\n\n１４．９やりすぎ\n場合によっては、テストに集中しすぎてしまう可能性もある。いくつか例を示そ\nう\n。\n\nテストのために本物のコードの読みやすさを犠牲にしてしまう。­本物の\nコードをテストしやすいように設計するには、両者に利点がなければいけな\nい。本物のコードは単純で疎結合なものにする。テストは読み書きしやすく\nする。テストをしやすくするために、本物のコードにゴミを入れてはいけな\nいｏ\n\nテストのカバレッジを１００％にしないと気が済まない。­コードの90%\nをテストするほうが、残り10%をテストするよりも楽である。最後の10%\nにはユーザインタフェースやどうでもいいエラーケースが含まれている。そ\nの部分はバグのコストが高くないので、テストが割に合わない。\n現実的には、カバレッジが100%になることはない。もしも100%になって\nいるのだとしたら、バグを見逃しているか、機能を実装していないか、仕様\nが変更されたことに気づいていないかのどれかだ。\n\nクラスや関数が１\nつのことをしてい\nる\n\nラスは他のクラ\nスにあまり依存し\nていない。高度に\n疎結合化されてい\nる\n\n数は単純でイン\nタフェースが明確\nである。\n\n。 ク\n\n。 関\n\n','ｇやりすぎʼ塁  表­テスト容易性の高いコードの特性とそこから生じる設計の利点 |驚議騨驚(cid:)(cid:)驚(cid:)蕊溌鑑識驚(cid:)藤蕊蕊蕊識鱗驚蕊(cid:)蕊難(cid:)蕊織(cid:)(cid:)議(cid:)｜  テストがしやすい。メソッドを クラスが小さい。テストがしやすい。メソッドを状態の少ないクラスは単純で理解し テストするのにセットアップが あ る い は 内 部 状 態 テ ス ト す る の に セ ッ ト ア ッ プ が や す い 。 を 持 た な い 。 あ ま り 必 要 に な ら な い 。 検 査 す あまり必要にならない。検査す る状態が隠されていない。 完全にテストをするためのテス トケースが少なくて済む。  各クラスは独立してテストでき る複数のクラスを同時にテス トするよりもずっと簡単)。  小さくて単純なコンポーネントがモ ジュール化されている。システムは 疎結合である。 システムは並列的に開発できる。ク ラスは他の部分を気にすることなく 簡単に修正や削除ができる。  明確な動作をテストできる。単 純なインタフェースなのでテス トが楽。  インタフェースがわかりやすくて再 ﾄ|｣川しやすい。  やりすぎ 場合によっては、テストに集中しすぎてしまう可能性もある。いくつか例を示そ う 。  テストのために本物のコードの読みやすさを犠牲にしてしまう。­本物の コードをテストしやすいように設計するには、両者に利点がなければいけな い。本物のコードは単純で疎結合なものにする。テストは読み書きしやすく する。テストをしやすくするために、本物のコードにゴミを入れてはいけな いｏ  テストのカバレッジをにしないと気が済まない。­コードの% をテストするほうが、残り%をテストするよりも楽である。最後の% にはユーザインタフェースやどうでもいいエラーケースが含まれている。そ の部分はバグのコストが高くないので、テストが割に合わない。 現実的には、カバレッジが%になることはない。もしも%になって いるのだとしたら、バグを見逃しているか、機能を実装していないか、仕様 が変更されたことに気づいていないかのどれかだ。  クラスや関数が つのことをしてい る  ラスは他のクラ スにあまり依存し ていない。高度に 疎結合化されてい る  数は単純でイン タフェースが明確 である。  。 ク  。 関  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(204,1,203,'１９６１１４章テストと読みやすさ\n\nバグのコストによって、テストコードにかける最適な時間は違ってくる。\nウェブサイトのプロトタイプを作っているのであれば、テストは書かなくて\nも問題ない。でも、宇宙船の制御装置や医療機器を作っているのであれば、\nテストに集中しなければいけないだろう。\n\n●\n\nテストがプロダクト開発の邪魔になる。­プロジェクトの一部にすぎない\nテストが、プロジェクト全体を支配している状況を目にしたことがある。テ\nストが触れてはいけない神のようになっているのだ。プログラマたちは、貴\n重なエンジニアリングの時間を犠牲にしていると知りながら、ある種の儀式\nとしてテストを行っているのである。\n\n1 4 . 1 0 ま と め\n\nテストコードでも読みやすさが大切だ。テストが読みやすければ、テストが書きや\nすくなり、みんながテストを追加しやすくなる。また、本物のコードをテストしやす\nく設計すれば、コードの設計が全体的に改善できる。\n\nテストを改善する点をまとめよう。\n\n●テストのトップレベルはできるだけ簡潔にする。入出力のテストはコード１\n\n行で記述できるといい。\n\n●テストが失敗したらバグの発見や修正がしやすいようなエラーメッセージを\n\n表示する。\n\n●テストに有効な最も単純な入力値を使う。\n●テスト関数に説明的な名前をつけて、何をテストしているのかを明らかにす\n\nる。TestlQではなく、Test <関数名> <状況＞のような名前にする。\n\n特に、新しいテストの追加や修正を簡単にすることが大切だ。\n\n','章テストと読みやすさ  バグのコストによって、テストコードにかける最適な時間は違ってくる。 ウェブサイトのプロトタイプを作っているのであれば、テストは書かなくて も問題ない。でも、宇宙船の制御装置や医療機器を作っているのであれば、 テストに集中しなければいけないだろう。  ●  テストがプロダクト開発の邪魔になる。­プロジェクトの一部にすぎない テストが、プロジェクト全体を支配している状況を目にしたことがある。テ ストが触れてはいけない神のようになっているのだ。プログラマたちは、貴 重なエンジニアリングの時間を犠牲にしていると知りながら、ある種の儀式 としてテストを行っているのである。    .   ま と め  テストコードでも読みやすさが大切だ。テストが読みやすければ、テストが書きや すくなり、みんながテストを追加しやすくなる。また、本物のコードをテストしやす く設計すれば、コードの設計が全体的に改善できる。  テストを改善する点をまとめよう。  ●テストのトップレベルはできるだけ簡潔にする。入出力のテストはコード  行で記述できるといい。  ●テストが失敗したらバグの発見や修正がしやすいようなエラーメッセージを  表示する。  ●テストに有効な最も単純な入力値を使う。 ●テスト関数に説明的な名前をつけて、何をテストしているのかを明らかにす  る。TestlQではなく、Test <関数名> <状況のような名前にする。  特に、新しいテストの追加や修正を簡単にすることが大切だ。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(205,1,204,'\'\n１９７\n\n１５章\n｢分／時間カウンタ」を\n設計・実装する\n\n','\'   章 ｢分時間カウンタ」を 設計・実装する  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(206,1,205,'１９８１１５章「分／時間カウンタ」を設計・実装する\n\nこれから本物のプロダクl､コードで使われているデータ構造「分／時間カウンタ」\nを見ていこう。問題を解決して、パフォーマンスを改善して、機能を追加する。この\nようなエンジニアの自然な思考プロセスをたどることにしよう。でも、いちばん大切\nなのは、本書の原則を使ってコードを読みやすくすることだ。途中でll\'IJ違った道に進\nんでしまうかもしれない。君は無事に付いて来れるだろうか。\n\n１５．１問題点\nウェブサーバの直近１分間と直近１時間の転送バイト数を把握したい。以下はこ\n\nれらがどのように保持されているかを示したものだ。\n\n直近1時間で350バイト\n\n一\n一\n４\n》\n、\n》\n『\nつ\nつ\n一\n\nエ\nヤ\n》\nへ\nつ\nゃ\n声\n《\n．\n\n一\nム\nヤ\n）\nへ\n・\nぬ\nト\n\n時間 ●\n\n〜\n\n直近1分間で\n一一\n\n150バイト』碁や）ら厚\n\n層\n\n徹\n\n耐→\n\n素直な問題だ。でも、これを効率的に解決するのは簡単ではなさそうだ。まずは\n\nクラスのインタフェースを定義するところから始めよう。\n１５回２クラスのインタフェースを定義する\n以下は、C++で書いたクラスのインタフェースの最初のバージョンだ畠\n\nc\nl\nass HinuteHourCounter {\npublic:\n\n／／カウントを追加する\nvoid Count(int num bytes);\n\n/／直近１分間のカウントを返す\ni\nnt MinuteCountQ:\n\n/／直近１時間のカウントを返す\ni\nnt HourCountQ;\n\n','章「分時間カウンタ」を設計・実装する  これから本物のプロダクl､コードで使われているデータ構造「分時間カウンタ」 を見ていこう。問題を解決して、パフォーマンスを改善して、機能を追加する。この ようなエンジニアの自然な思考プロセスをたどることにしよう。でも、いちばん大切 なのは、本書の原則を使ってコードを読みやすくすることだ。途中でll\'IJ違った道に進 んでしまうかもしれない。君は無事に付いて来れるだろうか。  問題点 ウェブサーバの直近分間と直近時間の転送バイト数を把握したい。以下はこ  れらがどのように保持されているかを示したものだ。  直近時間でバイト  一 一  》 、 》 『 つ つ 一  エ ヤ 》 へ つ ゃ 声 《   一 ム ヤ  へ ・ ぬ ト  時間 ●  〜  直近分間で 一一  バイト』碁やら厚  層  徹  耐→  素直な問題だ。でも、これを効率的に解決するのは簡単ではなさそうだ。まずは  クラスのインタフェースを定義するところから始めよう。 回クラスのインタフェースを定義する 以下は、C++で書いたクラスのインタフェースの最初のバージョンだ畠  c l ass HinuteHourCounter { public:  カウントを追加する void Count(int num bytes);  /直近分間のカウントを返す i nt MinuteCountQ:  /直近時間のカウントを返す i nt HourCountQ;  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(207,1,206,'１５２クラスのインタフェースを定義するʼ１９９\n\nこのクラスを実装する前に、名前とコメントを見ていこう。変更したい箇所がある\n\nかもしれない。\n\n名前を改善する\nクラス名のMinuteHourCounterはとてもいい。明確で具体的で呼びやすい。\nこのクラス名なら､MinuteCountQやHourCountQというメソッド名も納得がいく。\nGetMinuteCountQやGetHourCountQにしたいと思うかもしれないけど、それはあま\nりいい名前ではない。「３章誤解されない名前」で言ったように、「get」は多くの\n人にとって「軽量アクセサ」を意味する。この実装は軽量ではないので、「get」は使\nわないほうがいい。\n\nCountQというメソッド名には問題がある。ぼくたちは同僚に「Count )は何をす\nると思う？」と聞いてみた。すると「全期間のカウントを返す」と答えた人が何人も\nいた。つまり、この名前は直感的ではないのだ。Countに名詞と動詞があるのが問\n題なのだろう。名詞なら「これまでのカウントが欲しい」という意味になり、動詞な\nら「これをカウントして欲しい」という意味になる。\nCount()の代わりになるものを挙げよう。\nI\n●\nncrementQ\n●ObserveQ\n●RecordQ\n●AddQ\n\nIncrementQにすると値が増加する一方だと思われてしまう（カウントは時間に\nよって変化するのだ)。\nObserveQは問題ない。でも少しあいまいだ。\nRecordQも名詞と動詞の問題があるのでダメだ。\nAddQは興味深い。「この数値を追加する」と「データのリストに追加する」とい\nう２つの意味がある。今回はどちらの意味にも当てはまる。したがって、このメソッ\nドはvoid Add(int num bytes)にしよう。\nでも、仮引数のnum bytesという名前は具体的すぎる。ここではバイト数を扱っ\n\n','クラスのインタフェースを定義するʼ  このクラスを実装する前に、名前とコメントを見ていこう。変更したい箇所がある  かもしれない。  名前を改善する クラス名のMinuteHourCounterはとてもいい。明確で具体的で呼びやすい。 このクラス名なら､MinuteCountQやHourCountQというメソッド名も納得がいく。 GetMinuteCountQやGetHourCountQにしたいと思うかもしれないけど、それはあま りいい名前ではない。「章誤解されない名前」で言ったように、「get」は多くの 人にとって「軽量アクセサ」を意味する。この実装は軽量ではないので、「get」は使 わないほうがいい。  CountQというメソッド名には問題がある。ぼくたちは同僚に「Count )は何をす ると思う」と聞いてみた。すると「全期間のカウントを返す」と答えた人が何人も いた。つまり、この名前は直感的ではないのだ。Countに名詞と動詞があるのが問 題なのだろう。名詞なら「これまでのカウントが欲しい」という意味になり、動詞な ら「これをカウントして欲しい」という意味になる。 Count()の代わりになるものを挙げよう。 I ● ncrementQ ●ObserveQ ●RecordQ ●AddQ  IncrementQにすると値が増加する一方だと思われてしまうカウントは時間に よって変化するのだ)。 ObserveQは問題ない。でも少しあいまいだ。 RecordQも名詞と動詞の問題があるのでダメだ。 AddQは興味深い。「この数値を追加する」と「データのリストに追加する」とい うつの意味がある。今回はどちらの意味にも当てはまる。したがって、このメソッ ドはvoid Add(int num bytes)にしよう。 でも、仮引数のnum bytesという名前は具体的すぎる。ここではバイト数を扱っ  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(208,1,207,'2０0      1５章「分／時間カウンタ」を設計・実装する\n\nているけど、MinuteHourCounterクラスがそのことを知る必要はない。このクラス\nを使って、クエリやデータベーストランザクションを数える人がいるかもしれない。\ndeltaのようなもっと汎用的な名前が使えるかもしれない。だけど、deltaは値がマ\nイナスになる場面で使うことが多いので、ここでは使いたくない。countという名前\nがいいだろう。単純だし汎用的だし「マイナスではない」ことがわかる。それに「カ\nウント」は明確な文脈にも使える。\n\nコメントを改善する\nここまでのクラスのインタフェースはこうなっている。\n\nclass MinuteHourCounter ¥\n\npublic:\n／／カウントを鋤pする\nvoid Add(int count);\n\nはメソッドのコメントを改善する。最初に以下を考えてみよう。\n\n/／カウントを追加する\nvoid Add(int count);\n\nこのコメントは冗長だ。削除するか改善するべきだ。改善したものが以下になる。\n\n/／新しいデータ点を追加する(count >= 0)。\n/／それから１分間は､MinuteCountQの返す値が+countだけ増えるʻ\n/／それから１時間は、HourCountQの返す値が+countだけ増える。\nvoid Add(int count);\n次にMinuteCountQのコメントを見ていこう〈\n\n/／直近１分間のカウントを返す\ni\nnt MinuteCountQ;\n\n/／直近１分間のカウントを返す\ni\nnt MinuteCountQ;\n\n／／直近１時間のカウントを返す\ni\nnt HourCountQ;\n\n； 次\n\n}\n\n','      章「分時間カウンタ」を設計・実装する  ているけど、MinuteHourCounterクラスがそのことを知る必要はない。このクラス を使って、クエリやデータベーストランザクションを数える人がいるかもしれない。 deltaのようなもっと汎用的な名前が使えるかもしれない。だけど、deltaは値がマ イナスになる場面で使うことが多いので、ここでは使いたくない。countという名前 がいいだろう。単純だし汎用的だし「マイナスではない」ことがわかる。それに「カ ウント」は明確な文脈にも使える。  コメントを改善する ここまでのクラスのインタフェースはこうなっている。  class MinuteHourCounter ¥  public: カウントを鋤pする void Add(int count);  はメソッドのコメントを改善する。最初に以下を考えてみよう。  /カウントを追加する void Add(int count);  このコメントは冗長だ。削除するか改善するべきだ。改善したものが以下になる。  /新しいデータ点を追加する(count >= )。 /それから分間は､MinuteCountQの返す値が+countだけ増えるʻ /それから時間は、HourCountQの返す値が+countだけ増える。 void Add(int count); 次にMinuteCountQのコメントを見ていこう〈  /直近分間のカウントを返す i nt MinuteCountQ;  /直近分間のカウントを返す i nt MinuteCountQ;  直近時間のカウントを返す i nt HourCountQ;   次  }  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(209,1,208,'１５２クラスのインタフェースを定義するʼ２０１\n\nこのコメントの意味を同僚に聞いてみたところ、２種類の答えが返ってきた。\n\n1．「午後１２:１３のカウント」のような現在時刻の分数のカウントを返す。\n\n2．時刻の分数に関係なく「直近60秒間のカウント」を返す。\n\n２つめの解釈が実際の動作である。より正確で詳細な言葉を使って、誤解のない明\n\n確なものにしよう。\n\n/／直近60秒間の累積カウントを返す。\ni\nnt MinuteCountQ;\n\n（同様にHourCountQのコメントも改善しておこう｡）\nこれまでの変更を反映したクラス定義が以下になる。クラスレベルのコメントも追\n\n加しておいた。\n\n/／直近１分間および直近１時間の累積カウントを記録する。\n/／例えば、帯域幅の使用状況を確認するのに使える。\nc\nl\nass MinuteHourCounter {\n\n／／新しいデータ点を追加する(count >= 0)。\n／／それから１分間は、MinuteCountQの返す値が+countだけ増える。\n／／それから１時間は、HourCountQの返す値が+countだけ増える。\nvoid Add(int count);\n\n/／直近60秒間の累積カウントを返す。\ni\nnt MinuteCountQ;\n\n／／直近3600秒間の累積カウントを返す。\ni\nnt HourCountQ;\n\n簡潔にするためにこれからはコメントを表記しない｡）\n\n}\n\n； (\n\n','クラスのインタフェースを定義するʼ  このコメントの意味を同僚に聞いてみたところ、種類の答えが返ってきた。  「午後:のカウント」のような現在時刻の分数のカウントを返す。  時刻の分数に関係なく「直近秒間のカウント」を返す。  つめの解釈が実際の動作である。より正確で詳細な言葉を使って、誤解のない明  確なものにしよう。  /直近秒間の累積カウントを返す。 i nt MinuteCountQ;  同様にHourCountQのコメントも改善しておこう｡ これまでの変更を反映したクラス定義が以下になる。クラスレベルのコメントも追  加しておいた。  /直近分間および直近時間の累積カウントを記録する。 /例えば、帯域幅の使用状況を確認するのに使える。 c l ass MinuteHourCounter {  新しいデータ点を追加する(count >= )。 それから分間は、MinuteCountQの返す値が+countだけ増える。 それから時間は、HourCountQの返す値が+countだけ増える。 void Add(int count);  /直近秒間の累積カウントを返す。 i nt MinuteCountQ;  直近秒間の累積カウントを返す。 i nt HourCountQ;  簡潔にするためにこれからはコメントを表記しない｡  }   (  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(210,1,209,'２0２      １5章「分／時間カウンタ」を設計・実装する\n\n外部の視点を得る\n\n何度か同僚に質問していたことに気づいただろうか。外部の視点を得るというのは、コー\nドが「ユーザフレンドリー」かどうかを確認する優れた手段である。素直に第一印象を置\nいてみよう。他の人も同じことを思っているかもしれない。「他の人」には、６か月後の自\n分も含まれている。\n\n１５．３試案１：素朴な解決策\nこれから問題を解決していくことにする。まずは簡単な解決策から始めたいと思\n\nう。タイムスタンプのついた「イベント」のlistを保持するだけだ。\n\nc\nl\nass MinuteHourCounter {\n\nstruct Event {\n\nEvent(int count, time t time) : count(count), time(time) {}\nint count;\ntime t time;\n\n｝\n\n； l\n\n｝ ●\n\n● ●\n\n； 必\n\n}\n\nist<Event> events:\n\npublic:\nvoid Add(int count) {\n\nevents・push back(Event(count, timeQ));\n\n要に応じて直近のイベントをカウントできる。\n\nclass MinuteHourCounter {\n\n● ● ●\n\nnt MinuteCountQ {\ni\ni\nnt count = 0;\nconst time t now sees = timeQ;\n\n','      章「分時間カウンタ」を設計・実装する  外部の視点を得る  何度か同僚に質問していたことに気づいただろうか。外部の視点を得るというのは、コー ドが「ユーザフレンドリー」かどうかを確認する優れた手段である。素直に第一印象を置 いてみよう。他の人も同じことを思っているかもしれない。「他の人」には、か月後の自 分も含まれている。  試案素朴な解決策 これから問題を解決していくことにする。まずは簡単な解決策から始めたいと思  う。タイムスタンプのついた「イベント」のlistを保持するだけだ。  c l ass MinuteHourCounter {  struct Event {  Event(int count, time t time) : count(count), time(time) {} int count; time t time;  ｝   l  ｝ ●  ● ●   必  }  ist<Event> events:  public: void Add(int count) {  events・push back(Event(count, timeQ));  要に応じて直近のイベントをカウントできる。  class MinuteHourCounter {  ● ● ●  nt MinuteCountQ { i i nt count = ; const time t now sees = timeQ;  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(211,1,210,'１５．３試案１：素朴な解決策ʼ２０３\n\nfor (list<Event>::reverse iterator i = events.rbeginQ;\n\ni != events.rendQ && i->time > now sees - 60; ++i) ¥\ncount += i->count;\n\neturn count;\n\n｝r\n\nt HourCountQ {\nint count = 0;\nconst time t now sees = timeQ;\nfor (list<Event>::reverse iterator i = events.rbeginQ;\n\ni != events.rendQ && i->time > now sees - 3600; ++i) {\ncount += i->count;\n\n｝ in\n\nこのコードは理解しやすいか？\n\nこの解決策は「正しい」けれど、読みにくい点がいくつかある。\n\n●forループが少しうるさい。­この部分を読むときに速度が著しく落ちそ\n\n（もちろんバグがないことを確かめるには速度を落とす必要がある)。\n\nｑ\n\nMinuteCountQとHourCountQがほぼ同じ。­重複コードを共有化すれば\nコードを小さくできる。ここは比較的複雑なところなので、特に共有化した\nほうがいい（複雑なコードは一箇所にまとめるべきだ)。\n\n読みやすいバージョン\nMinuteCountQとHourCountQのコードは数値が違うだけだ60と3600)。両方を\n\n処理するヘルパーメソッドを導入して、リファクタリングするのがいいだろう。\n\nc\nl\nass MinuteHourCounter {\n\nlist<Event> events;\n\nint CountSince(time t cutoﬀ) {\n\nint count = 0;\nfor (list<Event>::reverse iterator rit = events.rbeginQ;\n\neturn count;\n\n｝r\n\n｝\n\n;\n\n','試案素朴な解決策ʼ  for (list<Event>::reverse iterator i = events.rbeginQ;  i != events.rendQ && i->time > now sees - ; ++i) ¥ count += i->count;  eturn count;  ｝r  t HourCountQ { int count = ; const time t now sees = timeQ; for (list<Event>::reverse iterator i = events.rbeginQ;  i != events.rendQ && i->time > now sees - ; ++i) { count += i->count;  ｝ in  このコードは理解しやすいか  この解決策は「正しい」けれど、読みにくい点がいくつかある。  ●forループが少しうるさい。­この部分を読むときに速度が著しく落ちそ  もちろんバグがないことを確かめるには速度を落とす必要がある)。  ｑ  MinuteCountQとHourCountQがほぼ同じ。­重複コードを共有化すれば コードを小さくできる。ここは比較的複雑なところなので、特に共有化した ほうがいい複雑なコードは一箇所にまとめるべきだ)。  読みやすいバージョン MinuteCountQとHourCountQのコードは数値が違うだけだと)。両方を  処理するヘルパーメソッドを導入して、リファクタリングするのがいいだろう。  c l ass MinuteHourCounter {  list<Event> events;  int CountSince(time t cutoﬀ) {  int count = ; for (list<Event>::reverse iterator rit = events.rbeginQ;  eturn count;  ｝r  ｝  ;  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(212,1,211,'Ｉ\n\nこの新しいコードには、注目すべき点がいくつかある。\nまず､CountSinceQの仮引数の名前をsecs_agoという(60や3600の）相対値で\nはなく、cutoffという絶対値にしている。動作が変わるわけではないけど、名前を\n変えたほうがCountSinceQが扱いやすくなる。\n\n次に、イテレータの名前をｉからritに変えている。ｉはインデックスによく使わ\nれる名前なので、ぼくたちも最初はこの名前を使おうと思っていた。でも、ここで\n使っているのは逆向きのイテレータだ。このコードを正しく動かすには欠かせない部\n分である。変数名の頭にｒをつけることで､rit  != events.rendQのように対称的\nな文にできる。\n\n最後に、forループからrit-rtime <= cutoffという条件を抽出して、新しくif\n文を作っている。これはなぜだろうか？for(begin；end；advance)形式の「伝統\n的な」forループのほうが読みやすいからだ。こうすれば「すべての要素を調べる」\nことがすぐにわかるし、それ以上深く考える必要がなくなる。\n\n204      15章「分／時間カウンタ」を設計・実装する\n\nrit != events.rendQ; ++rit) {\nif (rit->time <= cutoﬀ) {\n\nount += rit->count;\n\n｝c\n\nbreak;\n\neturn count;\n\n｝r\n\npublic:\nvoid Add(int count) {\n\nevents・push back(Event(count, timeQ));\n\nt MinuteCountQ {\n\nreturn CountSince(time() - 60);\n\nHourCountQ {\n \nreturn CountSince(timeQ - 3600);\n\n｝ in\n\n｝ int\n\n｝\n\n','Ｉ  この新しいコードには、注目すべき点がいくつかある。 まず､CountSinceQの仮引数の名前をsecs_agoという(やの相対値で はなく、cutoffという絶対値にしている。動作が変わるわけではないけど、名前を 変えたほうがCountSinceQが扱いやすくなる。  次に、イテレータの名前をｉからritに変えている。ｉはインデックスによく使わ れる名前なので、ぼくたちも最初はこの名前を使おうと思っていた。でも、ここで 使っているのは逆向きのイテレータだ。このコードを正しく動かすには欠かせない部 分である。変数名の頭にｒをつけることで､rit  != events.rendQのように対称的 な文にできる。  最後に、forループからrit-rtime <= cutoffという条件を抽出して、新しくif 文を作っている。これはなぜだろうかfor(beginendadvance)形式の「伝統 的な」forループのほうが読みやすいからだ。こうすれば「すべての要素を調べる」 ことがすぐにわかるし、それ以上深く考える必要がなくなる。        章「分時間カウンタ」を設計・実装する  rit != events.rendQ; ++rit) { if (rit->time <= cutoﬀ) {  ount += rit->count;  ｝c  break;  eturn count;  ｝r  public: void Add(int count) {  events・push back(Event(count, timeQ));  t MinuteCountQ {  return CountSince(time() - );  HourCountQ {   return CountSince(timeQ - );  ｝ in  ｝ int  ｝  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(213,1,212,'１５４試案２：ベルトコンベヤー設計2０5\n\nパ フ ォ ー マ ン ス の 問 題\n\nマンスの問題が２つある。\n\nこれまでコードの見た目を中心に改善してきたけど、この設計には深刻なパフォー\n\n１\n\n２\n\nこれからも大きくなっていく。\nこのクラスはすべてのイベントを保持している。つまり、メモリを無限に使\n用してしまうのだ!  MinuteHourCounterは、１時間よりも古い不要なイヘ\nントを自動的に削除するべきだ。\nM\ni\nnuteCountQとHourCountQが遅すぎる。\nCountSinceQメソッドの処理時間は0(n)である。〃は任意の時間帯のデー\nタ点の数だ。高性能のサーバが､AddQを１秒間に何百回呼び出したらどう\nなるだろうか。HourCountQを呼び出すたびに、数百万個のデータ点をカウ\nントしなければいけなくなるのだ! MinuteHourCounterは、Addの呼ひ\n出しに対応する値をminute countとhour countとで別々に保持するべき\nだ\n。\n\n１５．４試案２：ベルトコンベヤー設計\n先ほどの問題を両方解決する設計が必要だ。\n\n1．不要なデータを削除する〈\n\n2．事前にminute countとhour countの値を最新のものにしておく。\n\n一\n\n一\n\nこれからやることを説明しておこう。listをベルトコンベヤーのように使うのだ｡\n一方の端に新しいデータが到着したら合計に加算する。データが古すぎたらもう一方\nの端から「落下」させて合計から減算する。\n\nベルトコンベヤー設計の実装は２種類ある。１つめは、２つのlistを管理する方\n法だ。１つは直近１分間のイベントに、もう１つは直近１時間のイベントに使う。新\nしいイベントが到着したら、両方にコピーを追加する。\n\n','試案ベルトコンベヤー設計  パ フ ォ ー マ ン ス の 問 題  マンスの問題がつある。  これまでコードの見た目を中心に改善してきたけど、この設計には深刻なパフォー      これからも大きくなっていく。 このクラスはすべてのイベントを保持している。つまり、メモリを無限に使 用してしまうのだ!  MinuteHourCounterは、時間よりも古い不要なイヘ ントを自動的に削除するべきだ。 M i nuteCountQとHourCountQが遅すぎる。 CountSinceQメソッドの処理時間は(n)である。〃は任意の時間帯のデー タ点の数だ。高性能のサーバが､AddQを秒間に何百回呼び出したらどう なるだろうか。HourCountQを呼び出すたびに、数百万個のデータ点をカウ ントしなければいけなくなるのだ! MinuteHourCounterは、Addの呼ひ 出しに対応する値をminute countとhour countとで別々に保持するべき だ 。  試案ベルトコンベヤー設計 先ほどの問題を両方解決する設計が必要だ。  不要なデータを削除する〈  事前にminute countとhour countの値を最新のものにしておく。  一  一  これからやることを説明しておこう。listをベルトコンベヤーのように使うのだ｡ 一方の端に新しいデータが到着したら合計に加算する。データが古すぎたらもう一方 の端から「落下」させて合計から減算する。  ベルトコンベヤー設計の実装は種類ある。つめは、つのlistを管理する方 法だ。つは直近分間のイベントに、もうつは直近時間のイベントに使う。新 しいイベントが到着したら、両方にコピーを追加する。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(214,1,213,'２０６１１５章「分／時間カウンタ」を設計・実装する\n\nhour events 畔 ʻ\n\nmlnuteevents\n\nベ\n\n間\n\nこの方法はすごく単純だけど、すべてのイベントを２つずつ作るので非効率だ。\n２つめも、２つのlistを管理する方法だ。ただし、１番めのlist  (｢直近１分間\nのイベント｣）にイベントが到着してから、２番めのlist  (｢直近１時間のイベント」\n(ただし直近１分間のイベントはない)）に流れ込むようになっている。\n\nｍＩ｢1uteevents\n\nント\n\n(cid:20276)ベ\n\n２つめの「二段階」ベルトコンベヤー設計のほうが効率的なので、こちらを実装す\n\nることにしよう。\n\n二段階ベルトコンベヤーの実装\n\nまずは、クラスのメンバの列挙から始めようʻ．\n\nclass MinuteHourCounter {\n\nlist<Event> minute events;\nlist<Event> hour events; //直近１分間のイベントは含まれて「いない\n\nint minute count;\nint hour count:    //直近１時間の「すべて」のイベントをカウントしている\n\n','章「分時間カウンタ」を設計・実装する  hour events 畔 ʻ  mlnuteevents  ベ  間  この方法はすごく単純だけど、すべてのイベントをつずつ作るので非効率だ。 つめも、つのlistを管理する方法だ。ただし、番めのlist  (｢直近分間 のイベント｣にイベントが到着してから、番めのlist  (｢直近時間のイベント」 (ただし直近分間のイベントはない)に流れ込むようになっている。  ｍＩ｢uteevents  ント  (cid:)ベ  つめの「二段階」ベルトコンベヤー設計のほうが効率的なので、こちらを実装す  ることにしよう。  二段階ベルトコンベヤーの実装  まずは、クラスのメンバの列挙から始めようʻ  class MinuteHourCounter {  list<Event> minute events; list<Event> hour events; //直近分間のイベントは含まれて「いない  int minute count; int hour count:    //直近時間の「すべて」のイベントをカウントしている  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(215,1,214,'１５．４試案２：ベルトコンベヤー設計２０7\n\nこのベルトコンベヤー設計で最も大切なのは、時間経過に伴うイベントの「移\n動」だ。イベントは、minute  eventsからhour  eventsへと移動する。そのあ\nとで、minute  countとhour  countを更新する。そのためのヘルパーメソッド\nShiftOldEvents )を作ろう。このメソッドがあれば、クラスの実装が楽になる。\n\nvoid Add(int count) {\n\nconst time t now sees = timeQ;\nShift01dEvents(noしm sees);\n\n/／１分間のリストに流し込む（１時間のリストはあとから）\nm\ni\nnute events・push back(Event(count, now sees));\n\nminute count += count:\nhour count += count;\n\nい仕事をShiftOldEvents )に押しつけているのがわかるだろう。\n\n/／古いイベントを見つけて削除して、hour countとminute countを減らす。\nvoid ShiftOldEvents(time t now sees) {\n\nconst int minute ago = now sees - 60;\nconst int hour ago = now sees - 3600;\n\n/／１分以上経過したイベントを\'minute events\'から\'hour events\'へと移動する。\n/／（1時間以上経過した古いイベントは次のループで削除する）\nwhile (!minute events・empty() && minute_events・frontQ.time <= minute ago) {\n\nhour events・push back(minute events・front()):\nm\ni\nnute count -= minute events・frontQ. count;\n\n｝ in\n\n｝ 汚\n\ni\nnt MinuteCountQ {\n\nShift01dEvents(time());\nreturn minute count;\n\nt HourCountQ {\n\nShift01dEvents(time());\nreturn hour count;\n\n','試案ベルトコンベヤー設計  このベルトコンベヤー設計で最も大切なのは、時間経過に伴うイベントの「移 動」だ。イベントは、minute  eventsからhour  eventsへと移動する。そのあ とで、minute  countとhour  countを更新する。そのためのヘルパーメソッド ShiftOldEvents )を作ろう。このメソッドがあれば、クラスの実装が楽になる。  void Add(int count) {  const time t now sees = timeQ; ShiftdEvents(noしm sees);  /分間のリストに流し込む時間のリストはあとから m i nute events・push back(Event(count, now sees));  minute count += count: hour count += count;  い仕事をShiftOldEvents )に押しつけているのがわかるだろう。  /古いイベントを見つけて削除して、hour countとminute countを減らす。 void ShiftOldEvents(time t now sees) {  const int minute ago = now sees - ; const int hour ago = now sees - ;  /分以上経過したイベントを\'minute events\'から\'hour events\'へと移動する。 /時間以上経過した古いイベントは次のループで削除する while (!minute events・empty() && minute_events・frontQ.time <= minute ago) {  hour events・push back(minute events・front()): m i nute count -= minute events・frontQ. count;  ｝ in  ｝ 汚  i nt MinuteCountQ {  ShiftdEvents(time()); return minute count;  t HourCountQ {  ShiftdEvents(time()); return hour count;  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(216,1,215,'２０８１１５章「分／時間カウンタ」を設計・実装する\n\ni\nm\nnute events.pop_frontQ;\n\n／／１時間以上経過した古いイベントを\'hour events\'から削除する\nwhile (!hour events・empty() && hour_events・frontQ.time <= hour_ago) {\n\nhour count -= hour events.frontQ.count;\nhour events・popfrontQ;\n\n｝\n\n｝\n\nこ れ で 終 わ り ？\n\nこれで２つのパフオーマンス問題が解決できた。この解決策で問題ない。多くの\n\nアプリケーションではこれで十分だろう。ただし、欠点がたくさんある。\n\nまず、この設計には柔軟性がない。例えば、直近２４時間のカウントを保存したい\nとする。すると、多くのコードに修正が必要になる。気づいているかもしれないけ\nど､ShiftOldEventsQは、わずかに分と時間のデータのやりとりをしているだけの\n非常に密度の濃い関数である。\n\n次に、メモリの使用量が多い。高トラフイックのサーバが1秒間に100回もAdd )\nを呼び出したとしよう。直近１時間のデータをすべて保持しているので、約５MBの\nメモリが必要になる。\nAddQが頻繁に呼び出されると、それだけメモリを多く消費してしまう。プロダ\nクション環境では、予測不能な量のメモリを使うライブラリはよしとされていない。\nAddが呼び出される頻度に関係なく、MinuteHourCounterの使用するメモリは一定\nであるほうがいい。\n\n１５．５試案３：時間バケツの設計\n気づいてないかもしれないけど、先ほどの２つの実装にはどちらも小さなバグが\nあった。タイムスタンプを保持するのに使ったtime tは秒数を保持しているので、\nここで数値が丸められてしまう。その結果､MinuteCountQは呼び出された時刻に\nよって、５９秒か６０秒のデータを返すことになる。\n例えば、time = 0．９９のときにイベントが発生したら、t=0秒に丸められてしまう。\nそして、MinuteCountQをtime = 60.1秒で呼び出したら、t=l,2,3.…60のイベン\nトの合計が返ってくる。理論上は１分以内のものであっても、最初のイベントが無\n視されるのだ。\n\n','章「分時間カウンタ」を設計・実装する  i m nute events.pop_frontQ;  時間以上経過した古いイベントを\'hour events\'から削除する while (!hour events・empty() && hour_events・frontQ.time <= hour_ago) {  hour count -= hour events.frontQ.count; hour events・popfrontQ;  ｝  ｝  こ れ で 終 わ り   これでつのパフオーマンス問題が解決できた。この解決策で問題ない。多くの  アプリケーションではこれで十分だろう。ただし、欠点がたくさんある。  まず、この設計には柔軟性がない。例えば、直近時間のカウントを保存したい とする。すると、多くのコードに修正が必要になる。気づいているかもしれないけ ど､ShiftOldEventsQは、わずかに分と時間のデータのやりとりをしているだけの 非常に密度の濃い関数である。  次に、メモリの使用量が多い。高トラフイックのサーバが秒間に回もAdd ) を呼び出したとしよう。直近時間のデータをすべて保持しているので、約MBの メモリが必要になる。 AddQが頻繁に呼び出されると、それだけメモリを多く消費してしまう。プロダ クション環境では、予測不能な量のメモリを使うライブラリはよしとされていない。 Addが呼び出される頻度に関係なく、MinuteHourCounterの使用するメモリは一定 であるほうがいい。  試案時間バケツの設計 気づいてないかもしれないけど、先ほどのつの実装にはどちらも小さなバグが あった。タイムスタンプを保持するのに使ったtime tは秒数を保持しているので、 ここで数値が丸められてしまう。その結果､MinuteCountQは呼び出された時刻に よって、秒か秒のデータを返すことになる。 例えば、time = のときにイベントが発生したら、t=秒に丸められてしまう。 そして、MinuteCountQをtime = .秒で呼び出したら、t=l,,.…のイベン トの合計が返ってくる。理論上は分以内のものであっても、最初のイベントが無 視されるのだ。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(217,1,216,'１５５試案３：時間バケツの設計ʼ２０９\n\n平均すると、MinuteCountQは59.5秒間のデータを返すことになる。そして、\n\nHourCountQは3599.5秒間のデータを返す（無視できる数値だ)。\n\nミリ秒の粒度を使えばこの問題はすべて解決できる。でも、MinuteHourCounterを\n使っているアプリケーションでは、このレベルの精度を必要としない。というわけ\nで、このことを踏まえて、高速でメモリ使川量も少ない新しいMinuteHourCounter\nを設計した。パフォーマンスと精度はトレードオフなのだ。\n\nイベントを小さな時間帯に分けてバケツに入れ、バケツ単位でイベントの合計値を\n出すというのが(cid:20276)となる考えだ。例えば、直近１分間のイベン1,は、１秒ごとに６０\n個のバケツに入れる。直近１時間のイベントは、１分ごとに６０個のバケツに入れる轡\n\n1つのバケヅ\n\n現在時刻：\n１\n５９:１５\n:\n\n/一一一人---､ 幽眺\'    1:58 1:59        2;00pm\n\n1 : 0 0   1 : 0 1   1 : 0 2 ． ． ：\n\n60秒で60個のバケツ\n\nこのようなバケツを使えば､MinuteCountQ ^ HourCountQのメソッドは1/60の\n\n精度になる。悪くはない↑。\n\nもっと正確なものが必要であれば、メモリ使用量と引き換えにバケツの数を増やす\nことができる。でも、ここでいちばん大切なのは、この設計にすればメモリ使用量を\n固定化できて予測可能になるということだ。\n\n時間バケツの実装\n\nこの設計をクラス１つで実装すると、理解できない複雑なコードになる。「１１章\n\n一度に１つのことを」のアドバイスにしたがって、複数のクラスで異なる部分を処\n理していきたい。\n\nまずは、期間（直近１時間など）のカウントを追跡するクラスを作る。これを\n前の解決策と同じように、雌後のバケツは1え均して半分のInになる。今\'1｣|の設計では、念のために６()佃で\nはなく６１個のバケツを川意して、現在の「処理\'\'１」のバケツを無視するようにしている。でも、これだと\nデータが部分的に「陳腐化」することもある。この問題を修\'Kするには、処理<l\'のバケツと雌古のバケツ\nを袖完的に組み合わせて、公平で雌新のカウントが手に入るようにすればいい。この実装は読者の練習用\nに残しておこう。\n\n','試案時間バケツの設計ʼ  平均すると、MinuteCountQは.秒間のデータを返すことになる。そして、  HourCountQは.秒間のデータを返す無視できる数値だ)。  ミリ秒の粒度を使えばこの問題はすべて解決できる。でも、MinuteHourCounterを 使っているアプリケーションでは、このレベルの精度を必要としない。というわけ で、このことを踏まえて、高速でメモリ使川量も少ない新しいMinuteHourCounter を設計した。パフォーマンスと精度はトレードオフなのだ。  イベントを小さな時間帯に分けてバケツに入れ、バケツ単位でイベントの合計値を 出すというのが(cid:)となる考えだ。例えば、直近分間のイベン,は、秒ごとに 個のバケツに入れる。直近時間のイベントは、分ごとに個のバケツに入れる轡  つのバケヅ  現在時刻  : :  /一一一人---､ 幽眺\'    : :        ;pm   :      :      :       秒で個のバケツ  このようなバケツを使えば､MinuteCountQ ^ HourCountQのメソッドは/の  精度になる。悪くはない↑。  もっと正確なものが必要であれば、メモリ使用量と引き換えにバケツの数を増やす ことができる。でも、ここでいちばん大切なのは、この設計にすればメモリ使用量を 固定化できて予測可能になるということだ。  時間バケツの実装  この設計をクラスつで実装すると、理解できない複雑なコードになる。「章  一度につのことを」のアドバイスにしたがって、複数のクラスで異なる部分を処 理していきたい。  まずは、期間直近時間などのカウントを追跡するクラスを作る。これを 前の解決策と同じように、雌後のバケツはえ均して半分のInになる。今\'｣|の設計では、念のために()佃で はなく個のバケツを川意して、現在の「処理\'\'」のバケツを無視するようにしている。でも、これだと データが部分的に「陳腐化」することもある。この問題を修\'Kするには、処理<l\'のバケツと雌古のバケツ を袖完的に組み合わせて、公平で雌新のカウントが手に入るようにすればいい。この実装は読者の練習用 に残しておこう。  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(218,1,217,'２10      1５章「分／時間カウンタ」を設計・実装する\n\nTrailingBucketCounterと呼ぶことにしよう。これは、１種類の期間しか扱えない\nMinuteHourCounterクラスを汎化したものになる。インタフェースは以下になる。\n\n/／時間バケツＮ個のカウントを保持するクラス。\nass TrailingBucketCounter {\nc\nl\npublic:\n／/例: TrailingBucketCounter(30, 60)は､直近30分の時間バケツを追跡する。\nTrailingBucketCounter(int num_buckets, int secs_per bucket);\nvoid Add(int count, time t now);\n\nddとTrailingCountQの仮引数に現在時刻(time t now)があるのを不思議\nに思うかもしれない。メソッドの内部でtimeQを計算したほうが楽ではないだろう\nか？\n\n; A\n\n/／最新のnum bucketsの時間に含まれる合計カウントを返す\ni\nnt TrailingCount(time t now);\n\nー\n\n奇妙に思えるかもしれないけれど、現在時刻を外から渡すにはいくつかの利点\nがある。まず、TrailingBucketCounterを「時計なし」のクラスにできる。こう\nすればテストしやすくなるし、バグも少なくなる。次に、timeQの呼び出しを\nMinuteHourCounterに限定できる。時間に依存したシステムでは、時間の呼び出しか\n一箇所に集まっていると楽だ。\n\nTrailingBucketCounter実装できれば、MinuteHourCounterは簡単に実装できる。\n\nc\nl\nass MinuteHourCounter {\n\nTrailingBucketCounter minute counts;\nTrailingBucketCounter hour counts;\n\npublic:\nnuteHourCounter() :\nM\ni\ni\nm\nnute_counts(/* num_buckets = */ 60, /* sees per bucket = */ l),\nhour_counts( /* num_buckets = */ 60, /* sees per bucket = */ 60) {\n\nd Add(int count) {\no\ni\nme t now = timeQ;\nt\ni\nm\ni\nnute counts・Add(count, now)\n\n｝ v\n\n','      章「分時間カウンタ」を設計・実装する  TrailingBucketCounterと呼ぶことにしよう。これは、種類の期間しか扱えない MinuteHourCounterクラスを汎化したものになる。インタフェースは以下になる。  /時間バケツＮ個のカウントを保持するクラス。 ass TrailingBucketCounter { c l public: /例: TrailingBucketCounter(, )は､直近分の時間バケツを追跡する。 TrailingBucketCounter(int num_buckets, int secs_per bucket); void Add(int count, time t now);  ddとTrailingCountQの仮引数に現在時刻(time t now)があるのを不思議 に思うかもしれない。メソッドの内部でtimeQを計算したほうが楽ではないだろう か  ; A  /最新のnum bucketsの時間に含まれる合計カウントを返す i nt TrailingCount(time t now);  ー  奇妙に思えるかもしれないけれど、現在時刻を外から渡すにはいくつかの利点 がある。まず、TrailingBucketCounterを「時計なし」のクラスにできる。こう すればテストしやすくなるし、バグも少なくなる。次に、timeQの呼び出しを MinuteHourCounterに限定できる。時間に依存したシステムでは、時間の呼び出しか 一箇所に集まっていると楽だ。  TrailingBucketCounter実装できれば、MinuteHourCounterは簡単に実装できる。  c l ass MinuteHourCounter {  TrailingBucketCounter minute counts; TrailingBucketCounter hour counts;  public: nuteHourCounter() : M i i m nute_counts(/* num_buckets = */ , /* sees per bucket = */ l), hour_counts( /* num_buckets = */ , /* sees per bucket = */ ) {  d Add(int count) { o i me t now = timeQ; t i m i nute counts・Add(count, now)  ｝ v  ','2017-11-20 15:02:19','2017-11-20 15:02:19'),(219,1,218,'１５．５試案３：時間バケツの設計ʼ２１ʻ\n\nhour counts・Add(count, now);\n\n．． in\n\n｝ in\n\n｝\n\nt MinuteCountQ {\n\nt\ni\nme t now = timeQ;\nreturn minute counts・TrailingCount(now);\n\nt HourCountQ {\n\nt\ni\nme t now = timeQ;\nreturn hour counts.TrailingCount(now);\n\n}:\nこのコードは読みやすい。それに柔軟\'性も高い。バケツの数を増やそうと思えば簡\n\n単に増やせる（ただし、精度は上がるけど、メモリ使用量は増える)。\nTrailingBucketCounterを実装する\nあとは、TrailingBucketCounterクラスの実装だけだ。問題をさらに分割するため\n\nに、もう一度ヘルパークラスを作ろう。\n\nこれからConveyorQueueというデータ構造を作る。潜在的なカウントと合計を扱う\nデータ構造だ。TrailingBucketCounterクラスは、時間経過に伴ってConveyorQueue\nを移動させるタスクに集中できる。\n\n以下は、ConveyorQueueのインタフェースだ。\n\n/／最大数を持ったキュー。古いデータは端から「落ちる｣。\nc\nl\nass ConveyorQueue {\n\nConveyorOueue(int maxitems);\n\n/／キューの最後の値を増加するʻ\nvoid AddToBack(int count);\n\n/／キューの値を\'num shifted\'の分だけシフトする。\n/／新しい項目は０で初期化する。\n/／最古の項目はmax items以下なら削除する。\nvoid Shift(int num shifted);\n\n/／現在のキューに含まれる項目の合計値を返す。\n\n','試案時間バケツの設計ʼʻ  hour counts・Add(count, now);   in  ｝ in  ｝  t MinuteCountQ {  t i me t now = timeQ; return minute counts・TrailingCount(now);  t HourCountQ {  t i me t now = timeQ; return hour counts.TrailingCount(now);  }: このコードは読みやすい。それに柔軟\'性も高い。バケツの数を増やそうと思えば簡  単に増やせるただし、精度は上がるけど、メモリ使用量は増える)。 TrailingBucketCounterを実装する あとは、TrailingBucketCounterクラスの実装だけだ。問題をさらに分割するため  に、もう一度ヘルパークラスを作ろう。  これからConveyorQueueというデータ構造を作る。潜在的なカウントと合計を扱う データ構造だ。TrailingBucketCounterクラスは、時間経過に伴ってConveyorQueue を移動させるタスクに集中できる。  以下は、ConveyorQueueのインタフェースだ。  /最大数を持ったキュー。古いデータは端から「落ちる｣。 c l ass ConveyorQueue {  ConveyorOueue(int maxitems);  /キューの最後の値を増加するʻ void AddToBack(int count);  /キューの値を\'num shifted\'の分だけシフトする。 /新しい項目はで初期化する。 /最古の項目はmax items以下なら削除する。 void Shift(int num shifted);  /現在のキューに含まれる項目の合計値を返す。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(220,1,219,'２１２１１５章「分／時間カウンタ」を設計・実装する\n\ni\nnt TotalSum():\n\nＩ\n\nこのクラスを実装すれば、TrailingBucketCounterの実装が簡単になる。\n\nclass TrailingBucketCounter {\n\nConveyorQueue buckets;\nconst int sees per bucket;\nt\ni\nme t last update time; // UpdateQが最後に呼び出された時刻\n\n/／通過した時間バケツの数を計算してShiftQする。\nvoid Update(time t now) {\n\ni\nnt current_bucket = now / sees per bucket;\nint last_update_bucket = last_update_time / secs_per bucket;\nbuckets.Shift(current_bucket - last update bucket):\nlast update time = now;\n\n１■■■\n\npublic:\nTrailingBucketCounter(int num_buckets, int sees per bucket)\n\nbuckets(num buckets),\nsees per bucket(sees per bucket) {\n\nd Add(int count, time t now) {\no\ni\nUpdate(now);\nbuckets.AddToBack(count):\n\nt TrailingCount(time t now) {\nUpdate(now);\nreturn buckets・TotalSumQ:\n\n｝ v\n\n｝ in\n\n｝\n\nつのクラス(TrailingBucketCounterとConveyorQueue)に分割したのも、「11\n章一度に１つのことを」で説明したことだ。ConveyorQueueを作らずに、Trailing\nBucketCounterだけにしてもよかった。でも、クラスを分割したほうがコードを把握\nしやすくなる。\n\n■■■Ｆ\n\n１ ２\n\n','章「分時間カウンタ」を設計・実装する  i nt TotalSum():  Ｉ  このクラスを実装すれば、TrailingBucketCounterの実装が簡単になる。  class TrailingBucketCounter {  ConveyorQueue buckets; const int sees per bucket; t i me t last update time; // UpdateQが最後に呼び出された時刻  /通過した時間バケツの数を計算してShiftQする。 void Update(time t now) {  i nt current_bucket = now / sees per bucket; int last_update_bucket = last_update_time / secs_per bucket; buckets.Shift(current_bucket - last update bucket): last update time = now;  ■■■  public: TrailingBucketCounter(int num_buckets, int sees per bucket)  buckets(num buckets), sees per bucket(sees per bucket) {  d Add(int count, time t now) { o i Update(now); buckets.AddToBack(count):  t TrailingCount(time t now) { Update(now); return buckets・TotalSumQ:  ｝ v  ｝ in  ｝  つのクラス(TrailingBucketCounterとConveyorQueue)に分割したのも、「 章一度につのことを」で説明したことだ。ConveyorQueueを作らずに、Trailing BucketCounterだけにしてもよかった。でも、クラスを分割したほうがコードを把握 しやすくなる。  ■■■Ｆ     ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(221,1,220,'１５５試案３：時間バケツの設計ʼ２１３\n\nConveyorQueueの実装\nこれで残すはConveyorQueueクラスの実装だけとなった。\n\n/／最大数を持ったキュー。古いデータは端から「落ちる｣。\nc\nl\nass ConveyorQueue {\n\nqueue<int> q;\nint max items;\nint total sum;   // qに含まれるすべての項目の合計\n\npublic:\nConveyorQueue(int max_items) : max_items(max items), total sum(o) {\n\noid Shift(int num shifted) {\n\n／／項目がシフトされすぎた場合に、キューをクリアする。\nif (num shifted >= max items) {\n\nq = queue<int>();   // clear the queue\ntotal sum = 0;\nreturn;\n\nt TotalSumQ {\n\nreturn total sum:\n\n｝ in\n\n｝ v\n\nvoid AddToBack(int count) {\n\nf   q.empty      Shift 1 :   // qが少なくとも１つの項目を持つようにする。\ni\nq\n.\nbackQ += count;\n\n／必要な分だけ０をプッシュする。\nwhile (num shifted > 0) {\n\nq\n.\npush(O);\nnum shifted--;\n\n／超過した項目はすべて落とす。\nwhile (q.sizeQ > max items) {\n\ntotal sum -= q.frontQ;\nq\n.\npopQ;\n\n｝ /\n\n｝ /\n\n｝\n\n','試案時間バケツの設計ʼ  ConveyorQueueの実装 これで残すはConveyorQueueクラスの実装だけとなった。  /最大数を持ったキュー。古いデータは端から「落ちる｣。 c l ass ConveyorQueue {  queue<int> q; int max items; int total sum;   // qに含まれるすべての項目の合計  public: ConveyorQueue(int max_items) : max_items(max items), total sum(o) {  oid Shift(int num shifted) {  項目がシフトされすぎた場合に、キューをクリアする。 if (num shifted >= max items) {  q = queue<int>();   // clear the queue total sum = ; return;  t TotalSumQ {  return total sum:  ｝ in  ｝ v  void AddToBack(int count) {  f   q.empty      Shift  :   // qが少なくともつの項目を持つようにする。 i q . backQ += count;  必要な分だけをプッシュする。 while (num shifted > ) {  q . push(O); num shifted--;  超過した項目はすべて落とす。 while (q.sizeQ > max items) {  total sum -= q.frontQ; q . popQ;  ｝ /  ｝ /  ｝  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(222,1,221,'２１４１１５章「分／時間カウンタ」を設計・実装する\n\ntotal sum += count:\n\n完成だ！このMinuteHourCounterは高速でメモリ効率もいい。簡単に再利用で\nきる柔軟性の高いTrailingBucketCounterもある。例えば、直近１日分や直近10分\n間などのさまざまな期間をカウントできるRecentCounterが簡単に作れる。\n１５．６３つの解決策を比較する\n本章で取り上げた解決策を比較しよう。以下の表は、コードの規模とパフォーマ\nンスの指標だ（1秒間に100回AddQを呼び出す高トラフイックのユースケースを想\n定\n)\n。\n\n解決策\n\n素朴な解決策\n\nベルトコンベヤー設計\n\n時間バケツ設計\n(バケツ６０個！\n\n認\nﾄ\nのｉＨ｡u〔C･u剛(），の計算量\n\n3\n３\n\n5\n５\n\n9\n８\n\n0(1時間の\nイベンl､数：\n(\n〜３６０万》\n0(11\n\n0(1)\n\nメモリ使用量\n\n:\nＩ限なし\n\nＣｏunt(）\nr\nHCI_」\nの誤差\n1/3600\n\n0(1時間の\nイベント数）\n(〜5MBJ\n0バケツの数〉\n(〜５０()バイド\n\n1/3600\n\n6\n1\n/\n(\n）\n\n３つのクラスを使うことになった時間バケツのコード行数は、他の２つのコード行\n数よりもずっと多い。でも、パフォーマンスは高いし、設計に柔軟性がある。それ\nに、クラスに分割しているので読みやすい。これは好ましい変更だと言える。５０行\nの読みにくいコードよりも、100行の読みやすいコードのほうが優れているのだ。\n\n問題を複数のクラスに分割すると、複数のクラスになったことが原因で複雑になる\nこともある（クラスが１つなら発生しない複雑さだ)。今回はクラスが「線形」につ\nながっていて、ユーザに公|淵されているクラスは１つだけになっている。したがっ\nて、問題を分割することで、利点だけが得られるようになっている。\n\n','章「分時間カウンタ」を設計・実装する  total sum += count:  完成だこのMinuteHourCounterは高速でメモリ効率もいい。簡単に再利用で きる柔軟性の高いTrailingBucketCounterもある。例えば、直近日分や直近分 間などのさまざまな期間をカウントできるRecentCounterが簡単に作れる。 つの解決策を比較する 本章で取り上げた解決策を比較しよう。以下の表は、コードの規模とパフォーマ ンスの指標だ秒間に回AddQを呼び出す高トラフイックのユースケースを想 定 ) 。  解決策  素朴な解決策  ベルトコンベヤー設計  時間バケツ設計 (バケツ個  認 ﾄ のｉＨ｡u〔C･u剛(の計算量           (時間の イベンl､数 ( 〜万》 (  ()  メモリ使用量  : Ｉ限なし  Ｃｏunt( r HCI_」 の誤差 /  (時間の イベント数 (〜MBJ バケツの数〉 (〜()バイド  /    / (   つのクラスを使うことになった時間バケツのコード行数は、他のつのコード行 数よりもずっと多い。でも、パフォーマンスは高いし、設計に柔軟性がある。それ に、クラスに分割しているので読みやすい。これは好ましい変更だと言える。行 の読みにくいコードよりも、行の読みやすいコードのほうが優れているのだ。  問題を複数のクラスに分割すると、複数のクラスになったことが原因で複雑になる こともあるクラスがつなら発生しない複雑さだ)。今回はクラスが「線形」につ ながっていて、ユーザに公|淵されているクラスはつだけになっている。したがっ て、問題を分割することで、利点だけが得られるようになっている。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(223,1,222,'１５．５試案３：時間バケツの設計ʼ２１５\n\n１５．７まとめ\n最終的にMinuteHourCounterになるまでの手順をおさらいしよう。コードの進化\n\nの様子がうまく表されている。\n\nまずは、素朴な解決策から始めた。ここから設計上の課題が２つあることがわかっ\n\nた。速度とメモリ使用量である。\n\n次に、「ベルトコンベヤー」設計を試した。この設計は速度とメモリ使用量の問題\nは改善できたけど、高パフオーマンスのアプリケーションには適していなかった。ま\nた、柔軟性が乏しく、その他の時間帯を扱うにはかなり手を入れる必要があった。\n\n最終的な設計では、複数の下位問題に分割することで、これらの問題を解決した。\nボトムアップで３つのクラスを作り、それぞれのクラスで各下位問題を解決するよ\nうにした。\n\n●ConveyorQueue\n\n最大長のあるキュー。「シフト」可能で合計値を保持する。\n\n●\n\n●\n\nTrailingBucketCounter\n時間経過に伴ってConveyorQueueを移動する。また、１つの（最新の）時間\n帯のカウントを任意の精度で保持する。\n\nMinuteHourCounter\n2つのTrailingBucketCounterを保持する。１つは１分間のカウントで、も\nう１つは１時間のカウントだ。\n\n','試案時間バケツの設計ʼ  まとめ 最終的にMinuteHourCounterになるまでの手順をおさらいしよう。コードの進化  の様子がうまく表されている。  まずは、素朴な解決策から始めた。ここから設計上の課題がつあることがわかっ  た。速度とメモリ使用量である。  次に、「ベルトコンベヤー」設計を試した。この設計は速度とメモリ使用量の問題 は改善できたけど、高パフオーマンスのアプリケーションには適していなかった。ま た、柔軟性が乏しく、その他の時間帯を扱うにはかなり手を入れる必要があった。  最終的な設計では、複数の下位問題に分割することで、これらの問題を解決した。 ボトムアップでつのクラスを作り、それぞれのクラスで各下位問題を解決するよ うにした。  ●ConveyorQueue  最大長のあるキュー。「シフト」可能で合計値を保持する。  ●  ●  TrailingBucketCounter 時間経過に伴ってConveyorQueueを移動する。また、つの最新の時間 帯のカウントを任意の精度で保持する。  MinuteHourCounter つのTrailingBucketCounterを保持する。つは分間のカウントで、も うつは時間のカウントだ。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(224,1,223,'\'\n２１７\n\n付録\nあわせて読みたい\n\n皇 あなたの博士論文\n\nじゃないですか？\n\n(cid:7678)\n\n弾\n(cid:20276)\n\n(cid:7802)i\n\n型呈\n\nこの古代文字の意味が\n\nまだ解読できん。\n\n我々の文字と\nよく似ている\nようだが……\n\n＄\n鐙(cid:7767)蕊\n(cid:106)\n\n','\'   付録 あわせて読みたい  皇 あなたの博士論文  じゃないですか  (cid:)  弾 (cid:)  (cid:)i  型呈  この古代文字の意味が  まだ解読できん。  我々の文字と よく似ている ようだが……   鐙(cid:)蕊 (cid:)  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(225,1,224,'２１８１付録あわせて読みたい\n\n本書を執筆するにあたり、実際にどのようなものがうまくいっているのかを把握し\nようと思い、本物のコードを大量に分析した。また、関連書籍や論文も数多く読ん\nだ。さらに学習したい人は、これから紹介する情報源が役に立つだろう。完全なもの\nではないかもしれないけど、まずはここから読み始めるといいと思う。\n高品質のコードを書くための書籍\n『Code Complete第２版く上〉〈下〉­完全なプログラミングを目指して』スティー\nブ・マコネル著、クイープ訳、日経BPソフトプレス\n\nコードの品質などソフトウェアの構築に関するあらゆる側面について、綴密でよ\nく調査された学術書。\n\n『リファクタリングープログラムの体質改善テクニック』マーチン・ファウラー著、\n児玉公信、平(cid:7637)章、友野晶夫、梅沢真史訳、ピアソンエデュケーション\n\n漸進的なコードの改善に関する名著。さまざまなリファクタリング手法の詳細な\nカタログとコードを破壊せずに変更を加える手順が載っている。\n\n『プログラミング作法』ブライアン・カーニハン、ロブ・バイク著、福崎俊博訳、\nアスキー\n\nデバッグ・テスト・移植性・パフォーマンスなどのプログラミングに関する話題\nと豊富なサンプルコードが載っている。\n\n『達人プログラマー­システム開発の職人から名匠への道』アンドリュー・ハント、\nデビッド・トーマス著、村上雅章訳、ピアソンエデユケーシヨン\n\nプログラミングやエンジニアリングの優れた原則がたくさん集められていて、短\nい考察と一緒に載っている。\n\n『Clean  Code-アジャイルソフトウェア達人の技』ロバート．Ｃ・マーテイン著、\n花井志生訳、アスキー・メディアワークス\n\n本書と似ている（こちらはJava専用になっている）けれど、エラー処理や同時\n並行\'性などについても考察されている。\n\n','付録あわせて読みたい  本書を執筆するにあたり、実際にどのようなものがうまくいっているのかを把握し ようと思い、本物のコードを大量に分析した。また、関連書籍や論文も数多く読ん だ。さらに学習したい人は、これから紹介する情報源が役に立つだろう。完全なもの ではないかもしれないけど、まずはここから読み始めるといいと思う。 高品質のコードを書くための書籍 『Code Complete第版く上〉〈下〉­完全なプログラミングを目指して』スティー ブ・マコネル著、クイープ訳、日経BPソフトプレス  コードの品質などソフトウェアの構築に関するあらゆる側面について、綴密でよ く調査された学術書。  『リファクタリングープログラムの体質改善テクニック』マーチン・ファウラー著、 児玉公信、平(cid:)章、友野晶夫、梅沢真史訳、ピアソンエデュケーション  漸進的なコードの改善に関する名著。さまざまなリファクタリング手法の詳細な カタログとコードを破壊せずに変更を加える手順が載っている。  『プログラミング作法』ブライアン・カーニハン、ロブ・バイク著、福崎俊博訳、 アスキー  デバッグ・テスト・移植性・パフォーマンスなどのプログラミングに関する話題 と豊富なサンプルコードが載っている。  『達人プログラマー­システム開発の職人から名匠への道』アンドリュー・ハント、 デビッド・トーマス著、村上雅章訳、ピアソンエデユケーシヨン  プログラミングやエンジニアリングの優れた原則がたくさん集められていて、短 い考察と一緒に載っている。  『Clean  Code-アジャイルソフトウェア達人の技』ロバートＣ・マーテイン著、 花井志生訳、アスキー・メディアワークス  本書と似ているこちらはJava専用になっているけれど、エラー処理や同時 並行\'性などについても考察されている。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(226,1,225,'プログラミングに関する書籍ʼ２１９\n\nプログラミングに関する書籍\nfJavaScript: The Good Parts-「良いパーツ」によるベストプラクティス』ダグラ\nス・クロックフォード著、水野貴明訳、オライリー・ジャパン\n\n読みやすさのことを扱っているわけではないけど、ぼくたちと同じ魂が宿ってい\nる。JavaScriptでエラーの少ないキレイなサブセットを使うという内容だ。\n\n『Effective  Java第２版』ジヨシユア・ブロック著、柴田芳樹訳、ピアソンエデユ\nケーション\n\nJavaのプログラムを読みやすくバグの少ないものにできる驚異的な本。Javaに\n関する本だけど、ここで紹介されている多くの原則があらゆる言語に当てはま\nる。非常にオススメ。\n\n『オブジェクト指向における再利用のためのデザインパターン』エリック・ガンマ、\nリチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブリシデイース著、本位田真\n一、吉田和樹訳、ソフトバンククリエイティブ\n\nソフトウェアエンジニアがオブジェクト指向プログラミングについて語る上で共\n通言語となる「パターン」の原典。汎用的で便利なソフトウェアパターンを一覧\nにしたものであり、これらを使えば、はじめて遭遇する厄介な問題を解決すると\nきに陥りそうな良を回避できる。\n\n『珠玉のプログラミング­本質を見抜いたアルゴリズムとデータ構造』ジョン・ベ\nントリー著、小林健一郎訳、ピアソンエデュケーション\n\n実際のソフトウェアの問題に関する本。現実世界の問題を解決する鋭い知見をも\nたらしてくれる。\n\n『ハイパフォーマンスWebサイトー高速サイトを実現する14のルール』スティー\nブ・サウダーズ著、武舎広幸、福地太郎、武舎るみ訳、オライリー・ジャパン\n\nプログラミングの本じゃないけれど、できるだけコードを書かないでウェブサ\nイトを最適化する方法を紹介してくれるという点で注目に値する（｢１３章短い\nコードを書く」とあわせて読みたい)。\n\n','プログラミングに関する書籍ʼ  プログラミングに関する書籍 fJavaScript: The Good Parts-「良いパーツ」によるベストプラクティス』ダグラ ス・クロックフォード著、水野貴明訳、オライリー・ジャパン  読みやすさのことを扱っているわけではないけど、ぼくたちと同じ魂が宿ってい る。JavaScriptでエラーの少ないキレイなサブセットを使うという内容だ。  『Effective  Java第版』ジヨシユア・ブロック著、柴田芳樹訳、ピアソンエデユ ケーション  Javaのプログラムを読みやすくバグの少ないものにできる驚異的な本。Javaに 関する本だけど、ここで紹介されている多くの原則があらゆる言語に当てはま る。非常にオススメ。  『オブジェクト指向における再利用のためのデザインパターン』エリック・ガンマ、 リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブリシデイース著、本位田真 一、吉田和樹訳、ソフトバンククリエイティブ  ソフトウェアエンジニアがオブジェクト指向プログラミングについて語る上で共 通言語となる「パターン」の原典。汎用的で便利なソフトウェアパターンを一覧 にしたものであり、これらを使えば、はじめて遭遇する厄介な問題を解決すると きに陥りそうな良を回避できる。  『珠玉のプログラミング­本質を見抜いたアルゴリズムとデータ構造』ジョン・ベ ントリー著、小林健一郎訳、ピアソンエデュケーション  実際のソフトウェアの問題に関する本。現実世界の問題を解決する鋭い知見をも たらしてくれる。  『ハイパフォーマンスWebサイトー高速サイトを実現するのルール』スティー ブ・サウダーズ著、武舎広幸、福地太郎、武舎るみ訳、オライリー・ジャパン  プログラミングの本じゃないけれど、できるだけコードを書かないでウェブサ イトを最適化する方法を紹介してくれるという点で注目に値する｢章短い コードを書く」とあわせて読みたい)。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(227,1,226,'２２０１付録あわせて読みたい\n\n[Joel on Software』ジョエル・スポルスキー著、青木靖訳、オーム社\n\nhttp://www.joelonsoftware.com/から厳選された記事を集めた本｡スポルスキー\nは、ソフトウェアエンジニアリングのさまざまな側面に高い洞察力を見せてい\nる。特に「あなたが絶対すべきでないことPARTI」と「ジョエル・テスト：い\nいプログラムへの１２のステップ」は必読だ。\n\n歴史的記録\n『ライティングソリッドコードーバグのないプログラミングを目指して』スティー\nブ・マグワイア著、関本健太郎訳、アスキー\n\nこの本は残念ながら少し時代遅れになっている。でも、コードのバグを減らすた\nめの素晴らしいアドバイスは確実に影響を与えてくれる。\n\n『ケント・ベックのSmalltalkベストプラクティス・パターンーシンプル・デザイ\nンへの宝石集』ケント・ベック著、梅沢真史、皆川誠、小黒直樹、森島みどり訳、\nピァソンェデュヶーション\n\nサンプルコードはSmalltalkで書かれているけれど、この本には優れたプログラ\nミングの原則が数多く載っている。\n\n『プログラム書法』ブライアン・カーニハン、PJ.プローガー著、木村泉訳、共立出\n版\n\n「最もキレイな書き方」に関する最古の書籍と思われる。サンプルコードの多く\nはFortranとPL/Iで書かれている。\n\n｢文芸的プログラミング』ドナルド．E.クヌース著、有沢誠訳、アスキ­\n\nぼくたちはクヌース先生の言葉に心から賛同している。「すなわち、われわれ\nの主な仕事がコンピュータに何をさせるかを命令することだと思わずに、人間\nに対してコンピュータに何をしてほしいかを説明することに集中すべきである」\n(p､135)ただし、この本はクヌース先生の文芸的プログラミング環境WEBに関\nするものである。WEBというのは、文芸作品としてプログラムを書くための言\n語であり、実際のコードは脇役にすぎない。ぼくたちもWEBを実際に試してみ\nたけれど、コードが絶えず変化していくので（それが普通なのだ)、ぼくたちが\n\n','付録あわせて読みたい  [Joel on Software』ジョエル・スポルスキー著、青木靖訳、オーム社  から厳選された記事を集めた本｡スポルスキー は、ソフトウェアエンジニアリングのさまざまな側面に高い洞察力を見せてい る。特に「あなたが絶対すべきでないことPARTI」と「ジョエル・テストい いプログラムへののステップ」は必読だ。  歴史的記録 『ライティングソリッドコードーバグのないプログラミングを目指して』スティー ブ・マグワイア著、関本健太郎訳、アスキー  この本は残念ながら少し時代遅れになっている。でも、コードのバグを減らすた めの素晴らしいアドバイスは確実に影響を与えてくれる。  『ケント・ベックのSmalltalkベストプラクティス・パターンーシンプル・デザイ ンへの宝石集』ケント・ベック著、梅沢真史、皆川誠、小黒直樹、森島みどり訳、 ピァソンェデュヶーション  サンプルコードはSmalltalkで書かれているけれど、この本には優れたプログラ ミングの原則が数多く載っている。  『プログラム書法』ブライアン・カーニハン、PJ.プローガー著、木村泉訳、共立出 版  「最もキレイな書き方」に関する最古の書籍と思われる。サンプルコードの多く はFortranとPL/Iで書かれている。  ｢文芸的プログラミング』ドナルドE.クヌース著、有沢誠訳、アスキ­  ぼくたちはクヌース先生の言葉に心から賛同している。「すなわち、われわれ の主な仕事がコンピュータに何をさせるかを命令することだと思わずに、人間 に対してコンピュータに何をしてほしいかを説明することに集中すべきである」 (p､)ただし、この本はクヌース先生の文芸的プログラミング環境WEBに関 するものである。WEBというのは、文芸作品としてプログラムを書くための言 語であり、実際のコードは脇役にすぎない。ぼくたちもWEBを実際に試してみ たけれど、コードが絶えず変化していくのでそれが普通なのだ)、ぼくたちが  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(228,1,227,'歴史的記録ʼ２２ʻ\n\n推奨していることを続けるよりも、いわゆる「文芸的プログラム」にするほう力\n難しいと思う\n\n','歴史的記録ʼʻ  推奨していることを続けるよりも、いわゆる「文芸的プログラム」にするほう力 難しいと思う  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(229,1,228,'\'\n２２３\n\n解 説\n\n須藤功平\n\n読んでみていかがだっただろうか。プログラマにとってとても大切な「読みやすい\n\nコード」を書くということを「理解しやすく」伝えていたはずだ。\n\n本書は元の英語も読みやすく書かれている。少し英語を読める人なら原書でも読め\nるだろう。そんな原書のいいところをしっかりと残して読みやすい日本語にしたのが\n訳者の角さんだ。角さんは本書以外にもソフトウェア関連の訳書が数冊あり、どれも\n読みやすい日本語になっている。角さんの訳の特徴は、読みやすい日本語と時折はさ\nんでくる（わかる人にはわかるくらいのちょっと）有名な言葉だ。本書を読んでニヤ\nリとした人もいたのではないだろうか。やわらかい言い回しでまじめな話をしながら\n時折ユーモアあふれる挿絵をはさむ本書の訳者として、角さんはまさにうってつけの\n存在だ。\n\n読みやすい日本語だし、技術的に難しい内容でもないので、サクサク読めただろ\nう。でも、難しくない内容だからといって軽視していいわけじゃない。本書に書いて\nあることはとても大切なことだ。あなたがこれからプログラマとして信頼してもらえ\nるコードを書くかどうかは本書に書いてあることを身につけるかどうかにかかってい\nると言ってもいい。もし身につけていないなら、少なくとも私は信頼しない。\n\nそんな本書の内容を身につけて、自然に読みやすいコードを書けるようになるため\n\nの３つのステップを紹介しよう。\n\n● 実 際 に や る\n\n●当たり前にする\n\n●コードで伝える\n\n','\'   解 説  須藤功平  読んでみていかがだっただろうか。プログラマにとってとても大切な「読みやすい  コード」を書くということを「理解しやすく」伝えていたはずだ。  本書は元の英語も読みやすく書かれている。少し英語を読める人なら原書でも読め るだろう。そんな原書のいいところをしっかりと残して読みやすい日本語にしたのが 訳者の角さんだ。角さんは本書以外にもソフトウェア関連の訳書が数冊あり、どれも 読みやすい日本語になっている。角さんの訳の特徴は、読みやすい日本語と時折はさ んでくるわかる人にはわかるくらいのちょっと有名な言葉だ。本書を読んでニヤ リとした人もいたのではないだろうか。やわらかい言い回しでまじめな話をしながら 時折ユーモアあふれる挿絵をはさむ本書の訳者として、角さんはまさにうってつけの 存在だ。  読みやすい日本語だし、技術的に難しい内容でもないので、サクサク読めただろ う。でも、難しくない内容だからといって軽視していいわけじゃない。本書に書いて あることはとても大切なことだ。あなたがこれからプログラマとして信頼してもらえ るコードを書くかどうかは本書に書いてあることを身につけるかどうかにかかってい ると言ってもいい。もし身につけていないなら、少なくとも私は信頼しない。  そんな本書の内容を身につけて、自然に読みやすいコードを書けるようになるため  のつのステップを紹介しよう。  ● 実 際 に や る  ●当たり前にする  ●コードで伝える  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(230,1,229,'２24解弓\n\nまず、実際に読みやすいコードを書く。はじめはうまくいかないだろうが、本書を\n読み返しながら意識して読みやすいコードを書く。読みやすいコードが書けるように\nなってきたら、「読みやすいコードを書くことが当たり前」にする。読みにくいコー\nドなんてありえない。そんな状況だ。そんな状況で読みにくいコードが入ってきた\nら、どうしたら読みやすくなるかを読みやすいコードで伝える。「読みやすいコード\nとはこう書くんだよ｡」そういうことを読みやすいコードで伝えるんだ。ここまでく\nれば、自然に読みやすいコードを書けるようになっているだろう。\n\nさあ、それぞれのステップの具体的なやり方を紹介しよう。\n\n実際にやる\nまず１つめのステップは、実際にやるということだ。\n当たり前だけどこれはとても大事なことだ。（本書の内容も当たり前だけどとても\n大事なことだったね｡）本書の内容を実践して、これから書くコードは読みやすい\nコードにしよう。実際にやるとはじめて気づくことがたくさんある。\n\n実際にやるとぶつかること\n\nまず、内容を活かす場所がぜんぜんないって思うだろう。でも、それはあなたの書\nいたコードがすでに読みやすいからじゃない。単に「気づかない」からだ。本書を読\nんでいるときは次々と出てくる小さなコードを読みながら「たしかにここはそう変え\nた方がいいな。ふむふむ｡」なんて読んでいただろう。読みながらあなたが「ふむふ\nむ」言っていられたのは著者がわかりやすく書いてくれていたからだ。でも、実際の\nコードにはそういうヒントはない。著者のヒントがないんだから、実際のコードを読\nんでいるときは見逃してしまうだろう。それが自分が書いている真っ最中のコードな\nらなおさらだ。読む側の視点じゃなくて書く側の視点でコードを見ているんだから。\nウソだと思うなら新しく読みやすいコードを書いて私にコードを見せてみるとい\nい↑。読みやすいコードになっているかどうか、よっぽど気にして書かないと何かし\nらツッコミが入るだろう。もちろん、イジワルするつもりじゃないから、読みやすい\nコードだったらちゃんと「すばらしい！」とコメントするつもりだ。\n\n連絡先はkou＠cleal路code・Ｃｏｍｏもし、Rubyのコードなら、るびま編集部に送ってもいいだろう。コー\nドを添削する企画があるのでそこでコードを読んでくれるはずだ。http:/伽.rubyist.net/magazine/\nmagazine@jp.rubyist.net\n\n','解弓  まず、実際に読みやすいコードを書く。はじめはうまくいかないだろうが、本書を 読み返しながら意識して読みやすいコードを書く。読みやすいコードが書けるように なってきたら、「読みやすいコードを書くことが当たり前」にする。読みにくいコー ドなんてありえない。そんな状況だ。そんな状況で読みにくいコードが入ってきた ら、どうしたら読みやすくなるかを読みやすいコードで伝える。「読みやすいコード とはこう書くんだよ｡」そういうことを読みやすいコードで伝えるんだ。ここまでく れば、自然に読みやすいコードを書けるようになっているだろう。  さあ、それぞれのステップの具体的なやり方を紹介しよう。  実際にやる まずつめのステップは、実際にやるということだ。 当たり前だけどこれはとても大事なことだ。本書の内容も当たり前だけどとても 大事なことだったね｡本書の内容を実践して、これから書くコードは読みやすい コードにしよう。実際にやるとはじめて気づくことがたくさんある。  実際にやるとぶつかること  まず、内容を活かす場所がぜんぜんないって思うだろう。でも、それはあなたの書 いたコードがすでに読みやすいからじゃない。単に「気づかない」からだ。本書を読 んでいるときは次々と出てくる小さなコードを読みながら「たしかにここはそう変え た方がいいな。ふむふむ｡」なんて読んでいただろう。読みながらあなたが「ふむふ む」言っていられたのは著者がわかりやすく書いてくれていたからだ。でも、実際の コードにはそういうヒントはない。著者のヒントがないんだから、実際のコードを読 んでいるときは見逃してしまうだろう。それが自分が書いている真っ最中のコードな らなおさらだ。読む側の視点じゃなくて書く側の視点でコードを見ているんだから。 ウソだと思うなら新しく読みやすいコードを書いて私にコードを見せてみるとい い↑。読みやすいコードになっているかどうか、よっぽど気にして書かないと何かし らツッコミが入るだろう。もちろん、イジワルするつもりじゃないから、読みやすい コードだったらちゃんと「すばらしい」とコメントするつもりだ。  連絡先はkoucleal路code・Ｃｏｍｏもし、Rubyのコードなら、るびま編集部に送ってもいいだろう。コー ドを添削する企画があるのでそこでコードを読んでくれるはずだ。http:/伽.rubyist.net/magazine/ magazine  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(231,1,230,'実際にやるʼ２２５\n\n他の人に読んでもらう\n今、さらっと私に見せてみるといいなんて書いたけど、自分が書いたコードを人に\n読んでもらうということは、読みやすいコードを書くためのとてもいい機会になる。\n本書の中で、「他の人がこのコードを読んでどう思うか」ということを何度も気にし\nていたのを覚えているだろうか。\n\nだから、読む人は私じゃなくたっていい。仲間と一緒にコードを書いているなら、\n仲間に見てもらうのがいいだろう。でも、そのときは「気になるところがあったら遠\n慮せずに言ってくれ！」と念を押すことを忘れずに。同じコードを触っている仲間な\nら多少理解しづらいコードがあってもなんとなくわかってしまう。そうすると、本当\nは読みにくいコードなのに気づいてもらえないかもしれない。\n\nできれば、仲間にも本書を読んでもらって、どうすれば読みやすいコードになるか\nを共有しておくのがいい。仲間と一緒に実践できるとなおいい。仲間と一緒に始めれ\nば、「今のコードは読みやすいね！」といった話や「今のコードをこう変えればもっ\nと読みやすくなると思うんだけどどうだろう？」といった話ができる。そうなったら\nより楽しみながら「読みやすいコード」を書けるようになる。まわりにいるすごいプ\nログラマにも意見を聞いてみるといいだろう。「このコードで○○を読みやすくでき\nなかったんですが、なにかいいアイディアがあったら教えてもらえませんか？」\n\nあなたが読みやすいコードを書こうとしていることがみんなに伝われば、「ここ、\nもう少し読みやすくならないかな？」といったフィードバックが増えるだろう。そう\nすると、あなたの書くコードはどんどん読みやすくなっていくはずだ。（ただし、あ\nなたが素直にフィードバックを聞ければ、だ。自分が読みやすいと思って書いたコー\nドを読みにくいと言われるのはつらいことだけど、別にあなたを攻撃しようとしてい\nるわけじゃないので落ち着いて素直に聞いてみよう｡）\n\nお さ ら い\n\n自然に読みやすいコードを書けるようになるための１つめのステップは、実際に\nやるということだ。はじめはどこをよくすればいいかを見つけることが難しい。本書\nを読み返したり、仲間にコードを読んでもらったりしながら自分で「気付ける」よう\nになって欲しい。読みにくいことに気付いたら、読みやすくする方法は本書に書いて\nある。ここはそんなに難しい話じゃないはずだ。自分で自分のコードの読みにくいと\nころに「気付ける」ようになれば、読みやすいコードも書けるようになっているだろ\nう。そうなったら次のステップへの準備はできている。さあ、次のステップへ進も\n\n','実際にやるʼ  他の人に読んでもらう 今、さらっと私に見せてみるといいなんて書いたけど、自分が書いたコードを人に 読んでもらうということは、読みやすいコードを書くためのとてもいい機会になる。 本書の中で、「他の人がこのコードを読んでどう思うか」ということを何度も気にし ていたのを覚えているだろうか。  だから、読む人は私じゃなくたっていい。仲間と一緒にコードを書いているなら、 仲間に見てもらうのがいいだろう。でも、そのときは「気になるところがあったら遠 慮せずに言ってくれ」と念を押すことを忘れずに。同じコードを触っている仲間な ら多少理解しづらいコードがあってもなんとなくわかってしまう。そうすると、本当 は読みにくいコードなのに気づいてもらえないかもしれない。  できれば、仲間にも本書を読んでもらって、どうすれば読みやすいコードになるか を共有しておくのがいい。仲間と一緒に実践できるとなおいい。仲間と一緒に始めれ ば、「今のコードは読みやすいね」といった話や「今のコードをこう変えればもっ と読みやすくなると思うんだけどどうだろう」といった話ができる。そうなったら より楽しみながら「読みやすいコード」を書けるようになる。まわりにいるすごいプ ログラマにも意見を聞いてみるといいだろう。「このコードで○○を読みやすくでき なかったんですが、なにかいいアイディアがあったら教えてもらえませんか」  あなたが読みやすいコードを書こうとしていることがみんなに伝われば、「ここ、 もう少し読みやすくならないかな」といったフィードバックが増えるだろう。そう すると、あなたの書くコードはどんどん読みやすくなっていくはずだ。ただし、あ なたが素直にフィードバックを聞ければ、だ。自分が読みやすいと思って書いたコー ドを読みにくいと言われるのはつらいことだけど、別にあなたを攻撃しようとしてい るわけじゃないので落ち着いて素直に聞いてみよう｡  お さ ら い  自然に読みやすいコードを書けるようになるためのつめのステップは、実際に やるということだ。はじめはどこをよくすればいいかを見つけることが難しい。本書 を読み返したり、仲間にコードを読んでもらったりしながら自分で「気付ける」よう になって欲しい。読みにくいことに気付いたら、読みやすくする方法は本書に書いて ある。ここはそんなに難しい話じゃないはずだ。自分で自分のコードの読みにくいと ころに「気付ける」ようになれば、読みやすいコードも書けるようになっているだろ う。そうなったら次のステップへの準備はできている。さあ、次のステップへ進も  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(232,1,231,'たり前にする\n次のステップは当たり前にするということだ。\n１つめのステップであなたが新しく書くコードは読みやすくなっている。そうする\nと、既存のコードの読みにくいところがちらほら目につくようになる。目の前のそれ\nらのコードを読みやすくしようと意気込んでいることだろう。それはとてもすばらし\nいことだ！だが注意して欲しいことがある。それは、一時の頑張りだけでは読みや\nすいコードにはならないということだ。もし、それを忘れてしまうとせっかくの意気\n込みが消えてしまう。それはとてももったいないことだ。\n\nう 当\n\n(cid:7772)\n\n既 存 の コ ー ド を 読 み や す く す る 前 に や る こ と\n\nあなたが既存のコードを直し始めたとしよう。でも、仲間たちはその間も新しい\nコードを書いている。それらのコードは読みやすいコードではないかもしれない。自\n分だけが読みやすいコードを書いているという状況はとてもつらい。他の人がコード\nを書くたびに読みづらいコードが入ってくる。掃除しているそばからゴミを捨てられ\nているような感覚だ。まずは新しく書くコードが読みやすいコードだけになるように\nしよう。既存のコードを直すことはそれまでガマンして欲しい。\n具体的には、これからあなたが触るコードは読みやすいコードにしていく。まず、\n新しく書くコードは読みやすいコードで書こう。これはもうできているはずだ。で\nも、できているからといって油断してはいけない。まだ意識しないと読みやすいコー\nドを書けない状態だから、気を抜くと読みやすくないコードを書いてしまう。気を付\nけて。\n\nさらに、他の人が新しく書いたコードについても同じく読みやすいコードにしてい\nく。読みやすくないコードだったらその人と相談して読みやすいコードにしよう。既\n存のコードはそのコードを変更するときに読みやすいコードにしていこう。やり方は\nわかるはずだ。理解するまでに時間がかかる書き方だったらどうする？名前が暖昧\nだったらどうする？ピンとこなかったら本書をもう一度読み直してみよう。本書で\n丁寧に説明している。\n\nこれを続けて読みやすいコードを書くことが当たり前なことにしよう。誰かが読み\nにくいコードを書いたら、「ここ、少し読みにくくない？」と指摘する人がいるのが\n自然な状態だ。そうなれば習ʻ慣になったといえる。ここまできたら既存のコードを読\n\n２２６１解説\n\n','たり前にする 次のステップは当たり前にするということだ。 つめのステップであなたが新しく書くコードは読みやすくなっている。そうする と、既存のコードの読みにくいところがちらほら目につくようになる。目の前のそれ らのコードを読みやすくしようと意気込んでいることだろう。それはとてもすばらし いことだだが注意して欲しいことがある。それは、一時の頑張りだけでは読みや すいコードにはならないということだ。もし、それを忘れてしまうとせっかくの意気 込みが消えてしまう。それはとてももったいないことだ。  う 当  (cid:)  既 存 の コ ー ド を 読 み や す く す る 前 に や る こ と  あなたが既存のコードを直し始めたとしよう。でも、仲間たちはその間も新しい コードを書いている。それらのコードは読みやすいコードではないかもしれない。自 分だけが読みやすいコードを書いているという状況はとてもつらい。他の人がコード を書くたびに読みづらいコードが入ってくる。掃除しているそばからゴミを捨てられ ているような感覚だ。まずは新しく書くコードが読みやすいコードだけになるように しよう。既存のコードを直すことはそれまでガマンして欲しい。 具体的には、これからあなたが触るコードは読みやすいコードにしていく。まず、 新しく書くコードは読みやすいコードで書こう。これはもうできているはずだ。で も、できているからといって油断してはいけない。まだ意識しないと読みやすいコー ドを書けない状態だから、気を抜くと読みやすくないコードを書いてしまう。気を付 けて。  さらに、他の人が新しく書いたコードについても同じく読みやすいコードにしてい く。読みやすくないコードだったらその人と相談して読みやすいコードにしよう。既 存のコードはそのコードを変更するときに読みやすいコードにしていこう。やり方は わかるはずだ。理解するまでに時間がかかる書き方だったらどうする名前が暖昧 だったらどうするピンとこなかったら本書をもう一度読み直してみよう。本書で 丁寧に説明している。  これを続けて読みやすいコードを書くことが当たり前なことにしよう。誰かが読み にくいコードを書いたら、「ここ、少し読みにくくない」と指摘する人がいるのが 自然な状態だ。そうなれば習ʻ慣になったといえる。ここまできたら既存のコードを読  解説  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(233,1,232,'コードで伝えるʼ２２７\n\nみやすくするやり方を考え始めてもいいだろう。（ただし、１年かけて読みやすくす\nるというようなやり方がでてきたら危険な合図だ。そのやり方をもっと小さく分割し\nたりできないか考えてみるべきだ。ただ、この話題は本書の範囲を超えるのでまたの\n機会に｡）\n\n続 け る こ と が 大 事\n\n本書で説明している読みやすいコードを書くための方法は小さな基本的なことばか\nりだ。ソフトウェア全体をキレイにまとめるパターンなんかではない。１つの方法で\nはコードが少しキレイになるだけだ。しかし、これらの方法をコード全体に適用して\nいけばコード全体がキレイな読みやすいコードになる。一時的にコードを読みやすく\nしようというスタイルではなく、継続してコードを読みやすくしようというスタイル\nでコードを書いて欲しい。\n\n明日、あなたが読むコードは今日まであなた（と仲間たち）が書いたコードだ。明\n日、見たくないコードを見なくてもすむようにするには、今日、読みやすいコードを\n書くことだ。\n\n読みやすいコードを書くということはたまに思い出してやることではない。習慣に\nして常に実践することなんだ。それを忘れないで欲しい。それが実践できれば明日も\nずっとその先も楽しくコードを書けるはずだ。\n\n読みやすいコードが当たり前の世界へようこそ。さあ、次のステップへ進もう！\nコードで伝える\n最後のステップはコードで伝えるということだ。\n読みやすいコードが当たり前になったら、その先なんてないと思うかもしれない。\nだって、みんなが読みやすいコードを書いているんだから。これ以上なにを求めると\n言うんだ。\n\n読 み や す い コ ー ド が も っ と 当 た り 前 で あ り 続 け る た め に\n\nでも、あなたには仲間が増える。それは若い子だったり新人だったりするかもしれ\nない。新しい仲間は本書を読む前のあなたと同じだ。最後のステップでは新しい仲間\nを手伝って、新しい仲間も読みやすいコードを書くことが当たり前になれるようにす\nる。ちょうど本書の著者があなたにやってくれたように。\n\n本書はたくさんの人に伝えられるように一般的な例を使って書かれている。それで\n\n','コードで伝えるʼ  みやすくするやり方を考え始めてもいいだろう。ただし、年かけて読みやすくす るというようなやり方がでてきたら危険な合図だ。そのやり方をもっと小さく分割し たりできないか考えてみるべきだ。ただ、この話題は本書の範囲を超えるのでまたの 機会に｡  続 け る こ と が 大 事  本書で説明している読みやすいコードを書くための方法は小さな基本的なことばか りだ。ソフトウェア全体をキレイにまとめるパターンなんかではない。つの方法で はコードが少しキレイになるだけだ。しかし、これらの方法をコード全体に適用して いけばコード全体がキレイな読みやすいコードになる。一時的にコードを読みやすく しようというスタイルではなく、継続してコードを読みやすくしようというスタイル でコードを書いて欲しい。  明日、あなたが読むコードは今日まであなたと仲間たちが書いたコードだ。明 日、見たくないコードを見なくてもすむようにするには、今日、読みやすいコードを 書くことだ。  読みやすいコードを書くということはたまに思い出してやることではない。習慣に して常に実践することなんだ。それを忘れないで欲しい。それが実践できれば明日も ずっとその先も楽しくコードを書けるはずだ。  読みやすいコードが当たり前の世界へようこそ。さあ、次のステップへ進もう コードで伝える 最後のステップはコードで伝えるということだ。 読みやすいコードが当たり前になったら、その先なんてないと思うかもしれない。 だって、みんなが読みやすいコードを書いているんだから。これ以上なにを求めると 言うんだ。  読 み や す い コ ー ド が も っ と 当 た り 前 で あ り 続 け る た め に  でも、あなたには仲間が増える。それは若い子だったり新人だったりするかもしれ ない。新しい仲間は本書を読む前のあなたと同じだ。最後のステップでは新しい仲間 を手伝って、新しい仲間も読みやすいコードを書くことが当たり前になれるようにす る。ちょうど本書の著者があなたにやってくれたように。  本書はたくさんの人に伝えられるように一般的な例を使って書かれている。それで  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(234,1,233,'２２８１解訪\n\nもわかりやすく書かれているが、実際に自分たちが触るコードを使って説明した方力\nより実感がわくし、納得もしやすい。新しい仲間にどうすれば読みやすいコードにな\nるかを伝えるために自分たちが書いているソフトウェアを使おう。自分たちのソフト\nウエアを読みやすいコードで書くことで、どうすれば読みやすいコードになるかを仮\nえるんだ。\n\nコミットメールのススン\n\nソフトウェアはコードの変更の積み重ねで作られている。それを管理するためのソ\nフトウェアがGitやSubversionなどのバージョン管理システムだ。もちろんあなた\nも使っているはずだ。まだ使っていないなら急いで使えるようになろう！読みやす\nいコードを書こうと試行錯誤するときにとても役立つ。仲間とコードを共有すること\nにも便利だ。\n\nよし、バージョン管理システムは用意できたね。それでは、コミットメールも用意\nしよう。コミットメールとはバージョン管理システムに変更を追加（コミット）した\nときに送られる通知メールのことだ。コミットした人は誰か、どんな変更だったかの\n説明なんかが書かれている。これを読めばどんな変更が入ったか、雰囲気がわかる。\n具体的な変更点(diff)は入ったり入らなかったりする◎私はdiffも入れることを強\nくオススメする。diffもあるとどのようにコードが変更されたかまですぐに確認でき\nるo diffを入れないとgit log -pやsvn diff> Webブラウザでリポジトリブラウザを\n開くなどの追加のひと手間が必要になる。コードを読むための敷居はできるだけ低く\nする。これはとても大事なことだ。コードを読むことが面倒になると、「どうせ誰も\n読まないって！」となってしまう。これでは「どうして読みやすいコードを書かな\nきゃいけないの？」に逆戻りだ。\n\nまずはあなたが読む\ndiff入りのコミットメールは仲間みんなに届くようにしよう。はじめは誰もあなた\nのdiffを読んでくれないかもしれない。ここであきらめちゃダメだ。まずはあなた\nが仲間のdiffを読もう。diffを読んで、読みにくいコードがあったら教えてあげよ\nう。diffにはコード全体ではなく変更箇所の周辺しか含まれていない。「diffだけ読\nんで読みやすいかわかるわけないじゃん！」と思うだろう。でも、diffだけ読んでも\n読みやすくなるようなコードにしないといけないんだ。もちろん、diffだけでその周\n辺のロジックまで正しいかどうかはわからないことの方が多いだろう。それでもdifl\n\n','解訪  もわかりやすく書かれているが、実際に自分たちが触るコードを使って説明した方力 より実感がわくし、納得もしやすい。新しい仲間にどうすれば読みやすいコードにな るかを伝えるために自分たちが書いているソフトウェアを使おう。自分たちのソフト ウエアを読みやすいコードで書くことで、どうすれば読みやすいコードになるかを仮 えるんだ。  コミットメールのススン  ソフトウェアはコードの変更の積み重ねで作られている。それを管理するためのソ フトウェアがGitやSubversionなどのバージョン管理システムだ。もちろんあなた も使っているはずだ。まだ使っていないなら急いで使えるようになろう読みやす いコードを書こうと試行錯誤するときにとても役立つ。仲間とコードを共有すること にも便利だ。  よし、バージョン管理システムは用意できたね。それでは、コミットメールも用意 しよう。コミットメールとはバージョン管理システムに変更を追加コミットした ときに送られる通知メールのことだ。コミットした人は誰か、どんな変更だったかの 説明なんかが書かれている。これを読めばどんな変更が入ったか、雰囲気がわかる。 具体的な変更点(diff)は入ったり入らなかったりする◎私はdiffも入れることを強 くオススメする。diffもあるとどのようにコードが変更されたかまですぐに確認でき るo diffを入れないとgit log -pやsvn diff> Webブラウザでリポジトリブラウザを 開くなどの追加のひと手間が必要になる。コードを読むための敷居はできるだけ低く する。これはとても大事なことだ。コードを読むことが面倒になると、「どうせ誰も 読まないって」となってしまう。これでは「どうして読みやすいコードを書かな きゃいけないの」に逆戻りだ。  まずはあなたが読む diff入りのコミットメールは仲間みんなに届くようにしよう。はじめは誰もあなた のdiffを読んでくれないかもしれない。ここであきらめちゃダメだ。まずはあなた が仲間のdiffを読もう。diffを読んで、読みにくいコードがあったら教えてあげよ う。diffにはコード全体ではなく変更箇所の周辺しか含まれていない。「diffだけ読 んで読みやすいかわかるわけないじゃん」と思うだろう。でも、diffだけ読んでも 読みやすくなるようなコードにしないといけないんだ。もちろん、diffだけでその周 辺のロジックまで正しいかどうかはわからないことの方が多いだろう。それでもdifl  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(235,1,234,'コードで伝える２29\n\nだけで読みやすいコードを書いているかどうかはわかるんだ。\n\n本書の内容を気にして書かれているコードはdiffになっても読みやすい。小さな\ndiffの中だけでtmpという変数名を使っているならそれは本当に一時的な変数なん\nだろう。このようなコードは適切な名前がついていて読みやすい。でも、大きなdiff\nの中でtmpという変数名を使っているなら要注意だ。単にいい名前をつけなかっただ\nけかもしれない。思い出して欲しい。本書の中でたくさんのサンプルコードが出てき\nた。それらのほとんどは１０行未満のコードだった。でも、そのコードを読んで、読\nみやすいコードとそうじゃないコードがどう違うかが伝わったはずだ。だったらdiff\nを読んだってわかるはずだ。\n\nまずはあなたがdiffを読んで仲間にフィードバックしよう。「こうすればもっと読\nみやすくなるんじゃないかな？」それを続けていれば仲間もあなたのdiffを読んで\nくれるようになるはずだ。あなたがコミットするときは読みやすいdiffになるよう\nにコミットしよう。仲間のdiffを読んでいたあなたはどういうdiffが読みやすいか\nはわかっているはずだ。\n\nわかりやすい目安はこうだ。１つのdiffに１つのことを。もし、あなたが本書中の\nコードを読みやすくする方法でコードを変更したときは、１つの方法ごとにコミット\nすること。「2.1明確な単語を選ぶ」と「4.4縦の線をまっすぐにする」を一緒に\nコミットしてはいけない。「2.1明確な単語を選ぶ」で１回、「4.4縦の線をまっす\nぐにする」でもう１回コミットするんだ。そう、「１１章一度に１つのことを」だ。\n\n添削コミット\n他の人が読みにくいコードをコミットしたら、「こうすればもっと読みやすくなる\nんじゃないか」というコードをコミットしよう。そして、「今コミットしたように変\n更するともっと読みやすくなると思うんだけどどうかな？」と声をかけてみよう。た\nだし、他の人のコードに手を入れるというのが「当たり前」の文化でない環境の場合\nはいきなりやると角が立つかもしれない。（バージョン管理システムを使っているな\nらコードを共有する文化は根付いていると思うけど！）その場合は、まずは「このあ\nたりのコードを整理していい？」と事前に確認してからやるのもいいだろう。\n\nこれは私が「添削コミット」と呼んでいるものだ。「添削」だと上から目線のイ\n\nメージがあるので「提案コミット」と呼ぶほうがいいかもしれない。\n\nどうして最後のステップで「添削コミット」をオススメしているのか。それは、添\n削コミットではまさに「読みやすいコード」になっていなければいけないからだ。\n\n','コードで伝える  だけで読みやすいコードを書いているかどうかはわかるんだ。  本書の内容を気にして書かれているコードはdiffになっても読みやすい。小さな diffの中だけでtmpという変数名を使っているならそれは本当に一時的な変数なん だろう。このようなコードは適切な名前がついていて読みやすい。でも、大きなdiff の中でtmpという変数名を使っているなら要注意だ。単にいい名前をつけなかっただ けかもしれない。思い出して欲しい。本書の中でたくさんのサンプルコードが出てき た。それらのほとんどは行未満のコードだった。でも、そのコードを読んで、読 みやすいコードとそうじゃないコードがどう違うかが伝わったはずだ。だったらdiff を読んだってわかるはずだ。  まずはあなたがdiffを読んで仲間にフィードバックしよう。「こうすればもっと読 みやすくなるんじゃないかな」それを続けていれば仲間もあなたのdiffを読んで くれるようになるはずだ。あなたがコミットするときは読みやすいdiffになるよう にコミットしよう。仲間のdiffを読んでいたあなたはどういうdiffが読みやすいか はわかっているはずだ。  わかりやすい目安はこうだ。つのdiffにつのことを。もし、あなたが本書中の コードを読みやすくする方法でコードを変更したときは、つの方法ごとにコミット すること。「.明確な単語を選ぶ」と「.縦の線をまっすぐにする」を一緒に コミットしてはいけない。「.明確な単語を選ぶ」で回、「.縦の線をまっす ぐにする」でもう回コミットするんだ。そう、「章一度につのことを」だ。  添削コミット 他の人が読みにくいコードをコミットしたら、「こうすればもっと読みやすくなる んじゃないか」というコードをコミットしよう。そして、「今コミットしたように変 更するともっと読みやすくなると思うんだけどどうかな」と声をかけてみよう。た だし、他の人のコードに手を入れるというのが「当たり前」の文化でない環境の場合 はいきなりやると角が立つかもしれない。バージョン管理システムを使っているな らコードを共有する文化は根付いていると思うけどその場合は、まずは「このあ たりのコードを整理していい」と事前に確認してからやるのもいいだろう。  これは私が「添削コミット」と呼んでいるものだ。「添削」だと上から目線のイ  メージがあるので「提案コミット」と呼ぶほうがいいかもしれない。  どうして最後のステップで「添削コミット」をオススメしているのか。それは、添 削コミットではまさに「読みやすいコード」になっていなければいけないからだ。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(236,1,235,'２３０１解討\n\n｢添削コミット」はコードで自分が意図していることを伝えるということだ。伝える\nためには他の人が理解しやすいコードでなければいけない。これはまさに本書で言っ\nていることだ。\n\n本書は読みやすいコードの書き方をわかりやすく伝えている。どうしてわかりやす\nいのか。それは、「どうしてこの書き方がいいのか」という「理由」だけでなく、そ\nのための「具体的な書き方」という「方法」も一緒に伝えているからだ。たとえ「理\n由」だけがわかってもそれを実現するための「方法」がわからなければ実践できな\nい。例えば、「関数を理解しやすくなるのでいい名前をつけましょう」だけでは実践\nできない。「いい名前」だけでは抽象的すぎて人それぞれの「いい名前」になってし\nまう。\n\n添削コミットでは読みやすいコードにするための「具体的な書き方」がコミットの\n内容そのものになる。コミットメッセージにはどうしてこの書き方の方が読みやすい\nのかの「理由」を書く。こうすることで本書でやっているような伝え方を実現でき\nる。修正しているので実際にコードがよくなるし、具体的な実例をつけてより読みや\nすいコードを伝えることができるので、ぜひやってみて欲しい。\n\nもちろん、添削コミットをする前にその人にも本書を読んでおいてもらうといいだ\n\nろう。読みやすいコードについて、より伝わりやすくなるはずだ。\n\nお さ ら い\n\n自然に読みやすいコードを書けるようになるための最後のステップは、コードで伝\nえるということだ。これまでのステップではあなたが読みやすいコードを書けるよう\nになることを重視していた。最後のステップではあなたが読みやすいコードを伝えら\nれるようになることを重視する。あなたの意図をコードで伝えられるなら、それは本\n当に読みやすいコードになっているということだ。\n\nあなたが読みやすいコードを伝えるためには、自分たちが書いているソフトウェア\nで伝えるのが一番わかりやすい。一般的な例題で伝えるよりもピンとくる。自分たち\nのソフトウェアを材料にするために、みんながより自然にコードを読む環境を作る。\nその方法としてdiffを共有するo diffをただ流すだけにしてはいけない。まずあなた\nがdiffを読んでそこから読みにくいところを見つける。そして、その改善案をコー\nドで伝える。読みやすいコードで伝える。具体的な改善案と読みやすくなる理由で読\nみやすいコードを伝えるという方法は本書で著者たちが使っていた方法だ。今度はあ\nなたが読みやすいコードを伝える番だ。\n\n','解討  ｢添削コミット」はコードで自分が意図していることを伝えるということだ。伝える ためには他の人が理解しやすいコードでなければいけない。これはまさに本書で言っ ていることだ。  本書は読みやすいコードの書き方をわかりやすく伝えている。どうしてわかりやす いのか。それは、「どうしてこの書き方がいいのか」という「理由」だけでなく、そ のための「具体的な書き方」という「方法」も一緒に伝えているからだ。たとえ「理 由」だけがわかってもそれを実現するための「方法」がわからなければ実践できな い。例えば、「関数を理解しやすくなるのでいい名前をつけましょう」だけでは実践 できない。「いい名前」だけでは抽象的すぎて人それぞれの「いい名前」になってし まう。  添削コミットでは読みやすいコードにするための「具体的な書き方」がコミットの 内容そのものになる。コミットメッセージにはどうしてこの書き方の方が読みやすい のかの「理由」を書く。こうすることで本書でやっているような伝え方を実現でき る。修正しているので実際にコードがよくなるし、具体的な実例をつけてより読みや すいコードを伝えることができるので、ぜひやってみて欲しい。  もちろん、添削コミットをする前にその人にも本書を読んでおいてもらうといいだ  ろう。読みやすいコードについて、より伝わりやすくなるはずだ。  お さ ら い  自然に読みやすいコードを書けるようになるための最後のステップは、コードで伝 えるということだ。これまでのステップではあなたが読みやすいコードを書けるよう になることを重視していた。最後のステップではあなたが読みやすいコードを伝えら れるようになることを重視する。あなたの意図をコードで伝えられるなら、それは本 当に読みやすいコードになっているということだ。  あなたが読みやすいコードを伝えるためには、自分たちが書いているソフトウェア で伝えるのが一番わかりやすい。一般的な例題で伝えるよりもピンとくる。自分たち のソフトウェアを材料にするために、みんながより自然にコードを読む環境を作る。 その方法としてdiffを共有するo diffをただ流すだけにしてはいけない。まずあなた がdiffを読んでそこから読みにくいところを見つける。そして、その改善案をコー ドで伝える。読みやすいコードで伝える。具体的な改善案と読みやすくなる理由で読 みやすいコードを伝えるという方法は本書で著者たちが使っていた方法だ。今度はあ なたが読みやすいコードを伝える番だ。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(237,1,236,'最後にʼ２３１\n\n最後に\n解説として、本書の内容を身につけて自然に読みやすいコードを書けるようになる\nための３つのステップを紹介した。３つめのステップまでいけば「読みやすいコード\nを書かないなんてありえない！」となる。そうなったら著者が本書の最初で書いてい\nたようなことが現実になる。\n\n君はきっと優秀なプログラマになれるはずだ。自分の仕事に誇りを持ち、周囲のみ\nんなが喜んで使ってくれるような、バグの少ないコードを作り出せるようになる。\n\n私は読みにくいコードを書く人とは一緒にコードを書きたくない。私が読みにくい\nコードを触るときは、まず、見た目を直して読みやすくする。そう、本書の「第１部\n表面上の改善」に相当することだ。本書を読んで「わかってるな！」と思ったとこ\n\nろは、まず「第１部表面上の改善」を持ってきているところだった。\n\nあなたも本書の内容を活用して、読みやすいコードを書くプログラマとなってくれ\n\nることを期待している。\n\n読みやすいコードを書いて、自分が書いたコードを忘れてしまっても問題ないよう\n\nにして欲しい。読みやすいコードを書こう。忘れてもいいコードを書こう。\n\n｢自分が書いたコードってどのくらい覚えているんですか？」\n｢ほとんど覚えていないですよ｡」\n｢直すときどうするんですか？わからなくなってるじゃないですか｡」\n｢忘れても見たら簡単にわかるように書いておくんですよ｡」\n\n須藤功平（すとうこうへい）\nフリーソフトウェアプログラマで、株式会社クリアコード代表取締役（２代目)。社\n名の命名者でもある。社名の由来は「キレイなコード｣。その名の通りキレイなコー\nドを書く会社であろうという意図を込めている。最近は自分がどうやってキレイな\nコードを書いているかを他の人にうまく伝えるにはどうしたらよいかに興味がある。\n他に興味があることは立派じゃない盆栽を種から育てること。訳者の角さんと初めて\n話したのは2005-08-27のLLDNが終わった後のロフトプラスワン前。訳者の角さん\nと編集の高さんも所属しているたいやき部の部長としても活躍中。\n\n','最後にʼ  最後に 解説として、本書の内容を身につけて自然に読みやすいコードを書けるようになる ためのつのステップを紹介した。つめのステップまでいけば「読みやすいコード を書かないなんてありえない」となる。そうなったら著者が本書の最初で書いてい たようなことが現実になる。  君はきっと優秀なプログラマになれるはずだ。自分の仕事に誇りを持ち、周囲のみ んなが喜んで使ってくれるような、バグの少ないコードを作り出せるようになる。  私は読みにくいコードを書く人とは一緒にコードを書きたくない。私が読みにくい コードを触るときは、まず、見た目を直して読みやすくする。そう、本書の「第部 表面上の改善」に相当することだ。本書を読んで「わかってるな」と思ったとこ  ろは、まず「第部表面上の改善」を持ってきているところだった。  あなたも本書の内容を活用して、読みやすいコードを書くプログラマとなってくれ  ることを期待している。  読みやすいコードを書いて、自分が書いたコードを忘れてしまっても問題ないよう  にして欲しい。読みやすいコードを書こう。忘れてもいいコードを書こう。  ｢自分が書いたコードってどのくらい覚えているんですか」 ｢ほとんど覚えていないですよ｡」 ｢直すときどうするんですかわからなくなってるじゃないですか｡」 ｢忘れても見たら簡単にわかるように書いておくんですよ｡」  須藤功平すとうこうへい フリーソフトウェアプログラマで、株式会社クリアコード代表取締役代目)。社 名の命名者でもある。社名の由来は「キレイなコード｣。その名の通りキレイなコー ドを書く会社であろうという意図を込めている。最近は自分がどうやってキレイな コードを書いているかを他の人にうまく伝えるにはどうしたらよいかに興味がある。 他に興味があることは立派じゃない盆栽を種から育てること。訳者の角さんと初めて 話したのは--のLLDNが終わった後のロフトプラスワン前。訳者の角さん と編集の高さんも所属しているたいやき部の部長としても活躍中。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(238,1,237,'\'\n２３３\n\n索 引\n\n記 号\n\nI\n、……….……………………………….……….….…………….…７４\n\nＡ\n\nAddQ………….………………………….……….………199.208\nAddScoredDocO….…….……….…………………………l82\nAdvanceToMatching!､ime()……………………………163\ne\na\nl\nO………………………………………………………….…133\nr\nt\na\nl\nl\n_\nr\neplies.………….……………………………………..……１２２\nassert()…………….……….……………………………185,186\n\nＢ\n\nbegin……….………………….….……………….……….………３３\nBOOST REQUIRE-EQUALO………………….…….187\n\nＣ\n\nCheckFullNameQ .……………….……….…………………４７\nCheckScoresBeforeAfterO….…………….……………183\nC\ni\npher.….……………………….……………………….………l39\nC\nl\neanReplyQ……………………………………………………５９\nC\nl\nearQ…………………………….………………………………６３\nC\nl\ni\npQ………………….……….………………….……………….３０\nCompareProductByPrice……….…………………………７６\ncontinue.……………….………………….………………………９５\nConveyorQueue…………………….….211.212,213,215\ncopy…………….………………………….……….………………３８\nCount….………….….……….………………………………..…２００\ncounts! 1…………………………………………………………153\nCountSinceQ…………….……………………………………204\n\n，\n\ndatecreated……..……………………………………………１３６\nDeleteRegistryQ..…..….….…………………………………６０\ndelta…….…….…………………………………..………………２００\n\nd\ni\nf\nf\n……………….…………………………………………………２２８\nDISALLOWEVILCONSTRUCTORS………………１７\ndo/whileループ…………….…………………….….…..……８９\ndocument､cookie………..…….…….………………………１３８\ndone.……………….…………………………………………..…１１４\n\nＥ\n\nend…….………………………………….………….…………..…３３\nexample.value.…………………………………………….…１２０\nexpand.・all..………….…….……….……………………………８７\n\nＦ\n\nn\nl\ne_get_contents() ..…….…………………………………132\nf\ni\nl\nt\nerO…………………………………….……………….…….…３０\nEnd………………………………..…………………………………１２\nf\ni\nndClosestLocation ()………………………….…………130\nnrst…….…………….………….…………………….…….………３２\nF\ni\nxBrokenHtml () ..………….….………….……………..…６５\nＦｌＸＭＥ:…………………………….……….……………..………６１\nformat_pretty()……………..……………….………. 134,135\n\nＧ\n\nget*()….…………………………….….…………………………３４\nget_cookie()……………………………………….…….……138\nＧ\ni\nt…….….…………………………………..…….…….…….…２２８\ngoｔｏ……………….…………………………………………………９２\n\nＨ\n\nＨＡＣＫ:………….….……….…………………………….….……６１\nhourcount…….………….……………………………………２０５\nHourCountQ……………….….………………………203, 205\nＨＯＷ.………………….……………………………………………６８\nHttpDownload………………….…………………………….１５２\n\n','\'   索 引  記 号  I 、……….……………………………….……….….…………….…  Ａ  AddQ………….………………………….……….………. AddScoredDocO….…….……….…………………………l AdvanceToMatching!､ime()…………………………… e a l O………………………………………………………….… r t a l l _ r eplies.………….……………………………………..…… assert()…………….……….……………………………,  Ｂ  begin……….………………….….……………….……….……… BOOST REQUIRE-EQUALO………………….…….  Ｃ  CheckFullNameQ .……………….……….………………… CheckScoresBeforeAfterO….…………….…………… C i pher.….……………………….……………………….………l C l eanReplyQ…………………………………………………… C l earQ…………………………….……………………………… C l i pQ………………….……….………………….………………. CompareProductByPrice……….………………………… continue.……………….………………….……………………… ConveyorQueue…………………….…..,, copy…………….………………………….……….……………… Count….………….….……….………………………………..… counts! ………………………………………………………… CountSinceQ…………….……………………………………    datecreated……..…………………………………………… DeleteRegistryQ..…..….….………………………………… delta…….…….…………………………………..………………  d i f f ……………….………………………………………………… DISALLOWEVILCONSTRUCTORS……………… do/whileループ…………….…………………….….…..…… document､cookie………..…….…….……………………… done.……………….…………………………………………..…  Ｅ  end…….………………………………….………….…………..… example.value.…………………………………………….… expand.・all..………….…….……….……………………………  Ｆ  n l e_get_contents() ..…….………………………………… f i l t erO…………………………………….……………….…….… End………………………………..………………………………… f i ndClosestLocation ()………………………….………… nrst…….…………….………….…………………….…….……… F i xBrokenHtml () ..………….….………….……………..… ＦｌＸＭＥ:…………………………….……….……………..……… format_pretty()……………..……………….………. ,  Ｇ  get*()….…………………………….….………………………… get_cookie()……………………………………….…….…… Ｇ i t…….….…………………………………..…….…….…….… goｔｏ……………….…………………………………………………  Ｈ  ＨＡＣＫ:………….….……….…………………………….….…… hourcount…….………….…………………………………… HourCountQ……………….….………………………,  ＨＯＷ.………………….…………………………………………… HttpDownload………………….…………………………….  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(239,1,238,'２３４１索弓\n\ni\nf/elseブロック…………….……..……………………..……8（\nI\nncrementQ……………………..………….…..…………….19G\ni\nndextoremove…………………………………………….１１３\ni\nnfO.…….…………..…….…………..……….………………….１１７\ni\nnheIit….……………..……….………………..…………………３８\n\nreadQ……………….…….……………………….……….……132\nReadFileToStringQ….…………………….……….133,13!\nRecordQ .…….………………………………..……………….19（\nｒｅｍｍ文………..…………………….……………...….….……９］\nretval.…………………………….………..………………….……１２\nr\neuse………….…….………………………………………………３〔\n-runjocally…….……….……………………………….…….､１｛\n\nＬ\n\nこ\n』\n\nl\nast………………….……………………….……………………….３１\nl\ni\nst.…….…….………………………………….……….…202,201\nl\ni\nst::size()….……………………………………….………….…3（\nl\nocation info.…………………….………………….…147,141\nLRU方式..……………….….………..…..……………………16（\n\nＭ\n\nmake……..…………………………………………………………１２\nmake_url_friendly Q…………………….…….….……….131\nｍａｘ………….……………….…….……….………….………….､３］\nmaxresults…………….………………………………….….１３（\ni\nｍ\nn……………………….………….………………………………３］\nm\ni\nnutecount.………….……….….…………………………２０〔\nMinuteCountQ……………………..…….……203,205,20（\nMinuteHourCounter.…………………199,205,209,21E\n\nＮ\n\nname………….………………….…….……….…………….….１３６\nnewｖｏｔｅ….…………..…………………………………….….１４５\nnow…..……………………………….……………..……………１１２\nnum_bytes………….……………………………..……………１９９\nnumberofshares……………….………….…………….､１６１\n\n０\n\nObserve Q….….………………………….……………………199\no\nl\ndvote………….………………………………………………１４５\nopenQ .….….……………….……….…………...…………….132\nOverlapsWithQ………………….….……………….………104\n\nＰ\n\np\nl\nace.……………………………….….……..………….….……１４９\npnce……………….…………………….……….……………….１６１\nPython、リストとセット……….………………….…….172\n\nsafeMessageBody……………….……………………………２１\nscore.…………….….……………………………………………１４〔\nsend….….….….…………………………………….……….……１２\nServerCanStartQ….….…………………………….……….､1（\nsetFirstEmptylnputQ .………….…………………………124\nShiftOldEventsQ………………………………….…………207\nSortAndFilterDocsQ…………………………….…188,19C\nsphericaLdistanceQ….……………………..……….……131\ns\nt\nart…….…………………….………….……………….…………１２\ns\nt\na\nt\ni\nc…………….……….……..………….…………….………１１７\ns\nt\nr……………….…….……….…………………………………１１f\nsubmitted…..……………………….…………………….……１１８\nSubversion.….……….….…………………………………….２２８\n\nＴ\n\n\'\n1℃pConnectionSimulator….………………………...…….４４\nＴＤＤ…..……….….………………………………………………１９３\ntemplate.…..…………………….…………………….….………３７\nt\ni\ncker_symbo………………………………………….………１６１\nt\ni\nme…………..……………………………………………………１６１\nt\ni\nmeQ…………………….………………………………………２１Ｃ\nｔｉｍｅｔ…………..…………………………………………………２０８\nｔｉｍｅｔｎｏｗ.…….…...…………….………….………….……２１０\nt\ni\nmeoutms.………….………..……………………………….､７７\ntmp………………….…….………….…………………..……12,13\nＴＯＤＯ:……………………………………………………….….…６１\nTrailingBucketCounter.……………. 210,211,212,215\ntrustedUrl……………..…………………………………………２１\n\nＵ\n\nunittest………..………………………….………………………１９１\nＵｎｉｘツールボツクス.………………………….………….､１７３\nunknown…..…...…………………………..………………..…１５２\nUpdateCounts Q.…………………………….………………151\nurl……………………….…….……………………………………１３６\nurl-path….…..…………………….…….………..…………….１７４\n\nR\n\nＷ\n\nRange….……………………………………………..………..…１０３\n\nＷＨＡＴ・ＷＨＹ….……….………………………….….………６８\n\n','索弓  i f/elseブロック…………….……..……………………..…… I ncrementQ……………………..………….…..…………….G i ndextoremove……………………………………………. i nfO.…….…………..…….…………..……….…………………. i nheIit….……………..……….………………..…………………  readQ……………….…….……………………….……….…… ReadFileToStringQ….…………………….……….,! RecordQ .…….………………………………..………………. ｒｅｍｍ文………..…………………….……………...….….……］ retval.…………………………….………..………………….…… r euse………….…….………………………………………………〔 -runjocally…….……….……………………………….…….､｛  Ｌ  こ 』  l ast………………….……………………….………………………. l i st.…….…….………………………………….……….…, l i st::size()….……………………………………….………….… l ocation info.…………………….………………….…, LRU方式..……………….….………..…..……………………  Ｍ  make……..………………………………………………………… make_url_friendly Q…………………….…….….………. ｍａｘ………….……………….…….……….………….………….､］ maxresults…………….………………………………….…. i ｍ n……………………….………….………………………………］ m i nutecount.………….……….….…………………………〔 MinuteCountQ……………………..…….……,, MinuteHourCounter.…………………,,,E  Ｎ  name………….………………….…….……….…………….…. newｖｏｔｅ….…………..…………………………………….…. now…..……………………………….……………..…………… num_bytes………….……………………………..…………… numberofshares……………….………….…………….､    Observe Q….….………………………….…………………… o l dvote………….……………………………………………… openQ .….….……………….……….…………...……………. OverlapsWithQ………………….….……………….………  Ｐ  p l ace.……………………………….….……..………….….…… pnce……………….…………………….……….………………. Python、リストとセット……….………………….…….  safeMessageBody……………….…………………………… score.…………….….……………………………………………〔 send….….….….…………………………………….……….…… ServerCanStartQ….….…………………………….……….､ setFirstEmptylnputQ .………….………………………… ShiftOldEventsQ………………………………….………… SortAndFilterDocsQ…………………………….…,C sphericaLdistanceQ….……………………..……….…… s t art…….…………………….………….……………….………… s t a t i c…………….……….……..………….…………….……… s t r……………….…….……….…………………………………f submitted…..……………………….…………………….…… Subversion.….……….….…………………………………….  Ｔ  \' ℃pConnectionSimulator….………………………...……. ＴＤＤ…..……….….……………………………………………… template.…..…………………….…………………….….……… t i cker_symbo………………………………………….……… t i me…………..…………………………………………………… t i meQ…………………….………………………………………Ｃ ｔｉｍｅｔ…………..………………………………………………… ｔｉｍｅｔｎｏｗ.…….…...…………….………….………….…… t i meoutms.………….………..……………………………….､ tmp………………….…….………….…………………..……, ＴＯＤＯ:……………………………………………………….….… TrailingBucketCounter.……………. ,,, trustedUrl……………..…………………………………………  Ｕ  unittest………..………………………….……………………… Ｕｎｉｘツールボツクス.………………………….………….､ unknown…..…...…………………………..………………..… UpdateCounts Q.…………………………….……………… url……………………….…….…………………………………… url-path….…..…………………….…….………..…………….  R  Ｗ  Range….……………………………………………..………..…  ＷＨＡＴ・ＷＨＹ….……….………………………….….………  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(240,1,239,'索引ʼ２３５\n\nwhileループ………….……………..………………………….､９０\n\nき\n\nX\n\nXXX:………………….……………..………………………………６１\n\nキャッシュを追加.…………………….………….…………１６９\n行数.….……………………….……….……………...……………７３\n記録……….….……….………………………………………….…６０\n\nあ\n\nく\n\n値、単位…………….…………………………………………….２０\n当たり前にする.……..…………………….…………………226\n\nい\n\n一貫性\n\n意味………………………………….…………….…………４９\n改行位置…･………………………….……………..………４４\n好み･…･……･…………………..……………………………５２\n\n意図\n\nコード………．．………………………………………………７６\nイベント…………………..………………….…………………２０２\nインタフェース\n\n簡潔に……･……………….….…………….………..……１３７\n整える…..……………….…….….………….……………139\n\n­\n\nつ\n\n美しさ…･………………….….……………………………………４２\n\nえ\n\nエラーメッセージ.….………………………………….……１８５\n手作り.……………….……………….……………………１８７\n\nお\n\nオブジェクト、値を抽出….………………………………147\n\nか\n\n改行位置……………………………………………………….….４４\n改行文字……………….………….…………….……….….……７４\n解決策\n\n言葉で説明….….……….……………………….………163\n比較………….……………….………….………….…..…２１４\n外部の視点…….………….…………………………….………202\n下位問題.……………….…….……………….…………….….１３０\n頭文字.…….….…….…………………….……………………….２４\nカラフルな単語……………………..………………….………１１\n関数……………………….….…………………….…….…………９１\n記述………………………….……….………………………７３\n監督のコメンタリー……….………………………………….６０\n\nクラス.……….……..………..……………………………….…１９８\nクリーンアップコード.………………………………………９２\nグローバルスコープ….…….…….………….……….……･ʼ\'９\nグローバル変数…….…………………………………………１１５\n\nけ\n\nケント・ベックの\n\nSmalltalkベストプラクティス・パターン..……１４１\n\nこ\n\nコード\n\n意図……….……………………………..…………….….…７６\n欠陥……….….…………..……………………………….…６１\n削除…………………………….…….…….………………１７１\n処理や分割………….……………...….……………….､100\n段落に分割….……………………………….…………….５１\n小さく保つ.………………………………………………１７０\n伝える…･…．.………………..………………………….…２２７\n短い･…………….…………….………………….…….….１６８\n誤解……………….….………….….…………….….…………….３０\n好み…………………………………………………………….……５２\nコメンタリー.………………………….………….…….………６０\nコメント…．．……………….……………….……………….……５６\n簡潔……．．………………………………….….…………….７２\nコードの欠陥…………….…………………….…………６１\n代名詞………………….…………………….………………７２\n定数………………………………………………….……….６２\n\nさ\n\n再利用…………………･……･……･…･…………………………１７３\n削除、中間結果･………………………………………………１１３\n三項演算子･…………………….…………………………………８８\n\nし\n\n実際にやる…….………………………………….……….……２２４\n時間バケツ\n\n実装…………………………………………………………２０９\n設計………….……………………….………….…………２０８\n式\n.\n.\n……………….……………….…………….……………….…１０７\n質問と要求…..…….….…………………………….………….168\n\n','索引ʼ  whileループ………….……………..………………………….､  き  X  XXX:………………….……………..………………………………  キャッシュを追加.…………………….………….………… 行数.….……………………….……….……………...…………… 記録……….….……….………………………………………….…  あ  く  値、単位…………….……………………………………………. 当たり前にする.……..…………………….…………………  い  一貫性  意味………………………………….…………….………… 改行位置…･………………………….……………..……… 好み･…･……･…………………..……………………………  意図  コード……………………………………………………… イベント…………………..………………….………………… インタフェース  簡潔に……･……………….….…………….………..…… 整える…..……………….…….….………….……………  ­  つ  美しさ…･………………….….……………………………………  え  エラーメッセージ.….………………………………….…… 手作り.……………….……………….……………………  お  オブジェクト、値を抽出….………………………………  か  改行位置……………………………………………………….…. 改行文字……………….………….…………….……….….…… 解決策  言葉で説明….….……….……………………….……… 比較………….……………….………….………….…..… 外部の視点…….………….…………………………….……… 下位問題.……………….…….……………….…………….…. 頭文字.…….….…….…………………….………………………. カラフルな単語……………………..………………….……… 関数……………………….….…………………….…….………… 記述………………………….……….……………………… 監督のコメンタリー……….………………………………….  クラス.……….……..………..……………………………….… クリーンアップコード.……………………………………… グローバルスコープ….…….…….………….……….……･ʼ\' グローバル変数…….…………………………………………  け  ケント・ベックの  Smalltalkベストプラクティス・パターン..……  こ  コード  意図……….……………………………..…………….….… 欠陥……….….…………..……………………………….… 削除…………………………….…….…….……………… 処理や分割………….……………...….……………….､ 段落に分割….……………………………….……………. 小さく保つ.……………………………………………… 伝える…･….………………..………………………….… 短い･…………….…………….………………….…….…. 誤解……………….….………….….…………….….……………. 好み…………………………………………………………….…… コメンタリー.………………………….………….…….……… コメント………………….……………….……………….…… 簡潔……………………………………….….……………. コードの欠陥…………….…………………….………… 代名詞………………….…………………….……………… 定数………………………………………………….……….  さ  再利用…………………･……･……･…･………………………… 削除、中間結果･……………………………………………… 三項演算子･…………………….…………………………………  し  実際にやる…….………………………………….……….…… 時間バケツ  実装………………………………………………………… 設計………….……………………….………….………… 式 . . ……………….……………….…………….……………….… 質問と要求…..…….….…………………………….………….  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(241,1,240,'２３６１索引\n\n自分の考え、記録….………………………………………….６０\n出荷用.………….……………………………….….……………173\n条件………….…………………………….…….………………….８４\n情報密度の高い言葉……….………….………………………７８\n省略形.……………………………..…..………………………….2４\n\nす\n\n優れたコード….…….….……………….………..………………２\nスコープ….….……………………..…………….………………２３\n\nせ\n\n整列………………...……………………….………………………４８\nメソッド..….………………………………….……………４６\n設計……………………….…….….………………..…………..…４２\n説明変数.….…………………….….………….……………….100\n宣言、ブロックにまとめる…….…….……………………５０\n全体像、コメント………………………….……………….…6６\n\nそ\n\n属性、追加..….….…………...…….…….…….……………….２１\n\nた\n\n代名詞…………..…………………………….….………….…….７２\n大量破壊テスト………………….………………..…..…….､189\nタスク………….…………………………….…...……….…….１４４\n-一度に１つ..…………….……………….………………149\n縦の線…………………………….……….……..…….……….…４７\n単位、値……….…….…………...……..………….……………２０\n単語\n\nカラフルな………….……………………….………….…１１\n明確な…………….……….…….……….….………………１０\n段落に分割、コード……….……….……………...…………５１\n短絡評価の悪用………………………………….……………102\n\nち\n\n中間結果、削除.……………….……………..………………１１３\n\nつ\n\nやりすぎ….….……………………………………………１９５\nテスト機能……………………………..………………….……190\nテスト駆動開発….….….…………………………………….１９３\nテスト容易性…………….…………………………..…….….194\n手作りアサート……………………………………………….187\nデフラグ..….…………………………………………….144,150\n添削コミット…….…………….………………………………229\n店舗検索システム……………………….…….…….………168\n\nと\n\nド・モルガン法則….….…………..………….…………….，０，\nトップダウン……･………………………………………....…１３６\n\nな\n\n名前………….………….….……………………………………….１０\n情報を追加….…………………………………………..…１９\nプール値……….…………….….…………….……………３３\nフォーマット……………….….…………………………２５\n複数……………….…….…….………………………..……３６\n名前付き引数コメント………………………….……………７７\n名前の長さ.…….……………………………………………...…２２\n並び、一貫性と意味.………….….…….…….……….…..…4９\n\nに\n\n二段階ベルトコンベヤー….……………….………..……206\n入出力の実例.……………..…….……………………….…….､７４\n入力値……………..…………….……………….………………188\n\nね\n\nネスト\n\n浅くする……….……………………….….….……………９３\n削除….….………………...……………………….…….….９４\n仕組み……………….…….…………….…….…….………９４\nループ内部.…………………….………………………….９５\n\nは\n\nハンガリアン記法…………………..………………..…….…２，\n汎用コード……･…………･…………………….………………１３５\n\n追加、名前……….…….…………………..…………………….1９\n\nひ\n\nて\n\nテスト………..…………………………………..………..…….１８０\n最小….….…………….…….…….………..…….….……１８３\nダメ…………….………………………………….…….…１９２\n優しい……….…..…………………….……………..……１９３\n\n引数の並び順･…･…………………･………………….…………８４\nヒント…･……･………………………………………..…………１５９\n\n','索引  自分の考え、記録….…………………………………………. 出荷用.………….……………………………….….…………… 条件………….…………………………….…….…………………. 情報密度の高い言葉……….………….……………………… 省略形.……………………………..…..………………………….  す  優れたコード….…….….……………….………..……………… スコープ….….……………………..…………….………………  せ  整列………………...……………………….……………………… メソッド..….………………………………….…………… 設計……………………….…….….………………..…………..… 説明変数.….…………………….….………….………………. 宣言、ブロックにまとめる…….…….…………………… 全体像、コメント………………………….……………….…  そ  属性、追加..….….…………...…….…….…….……………….  た  代名詞…………..…………………………….….………….……. 大量破壊テスト………………….………………..…..…….､ タスク………….…………………………….…...……….……. -一度につ..…………….……………….……………… 縦の線…………………………….……….……..…….……….… 単位、値……….…….…………...……..………….…………… 単語  カラフルな………….……………………….………….… 明確な…………….……….…….……….….……………… 段落に分割、コード……….……….……………...………… 短絡評価の悪用………………………………….……………  ち  中間結果、削除.……………….……………..………………  つ  やりすぎ….….…………………………………………… テスト機能……………………………..………………….…… テスト駆動開発….….….……………………………………. テスト容易性…………….…………………………..…….…. 手作りアサート………………………………………………. デフラグ..….……………………………………………., 添削コミット…….…………….……………………………… 店舗検索システム……………………….…….…….………  と  ド・モルガン法則….….…………..………….……………. トップダウン……･………………………………………....…  な  名前………….………….….………………………………………. 情報を追加….…………………………………………..… プール値……….…………….….…………….…………… フォーマット……………….….………………………… 複数……………….…….…….………………………..…… 名前付き引数コメント………………………….…………… 名前の長さ.…….……………………………………………...… 並び、一貫性と意味.………….….…….…….……….…..…  に  二段階ベルトコンベヤー….……………….………..…… 入出力の実例.……………..…….……………………….…….､ 入力値……………..…………….……………….………………  ね  ネスト  浅くする……….……………………….….….…………… 削除….….………………...……………………….…….…. 仕組み……………….…….…………….…….…….……… ループ内部.…………………….………………………….  は  ハンガリアン記法…………………..………………..…….… 汎用コード……･…………･…………………….………………  追加、名前……….…….…………………..…………………….  ひ  て  テスト………..…………………………………..………..……. 最小….….…………….…….…….………..…….….…… ダメ…………….………………………………….…….… 優しい……….…..…………………….……………..……  引数の並び順･…･…………………･………………….………… ヒント…･……･………………………………………..…………  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(242,1,241,'索引ʼ２３７\n\nふ\n\nや\n\nプール値\n\nフォーマット\n\n名前…………………….………………….…………………３３\n\n名前.…………..……………………………….…………….２５\nフォーマット規約………………..…………………….､２６\n複数の名前……………….………….…………….…………….､３６\nブロックにまとめる、宣言.….………..……….…………５０\n文、分割.…………………………….………………………･…106\n分割\n\n巨大な文….……………………………………….………１０６\n質問と要求..….……….……….……….….……………１６８\n分／時間カウンタ….………….………………………….…１９８\n文章を磨く.…………..……………....…….……………………７３\n\nやりすぎ…………………………….……..……………………１４０\n\nゆ\n\nユーザの期待…….………………………………………………３４\n\nよ\n\n要約コメント…………………………………………………….６７\n要約変数……………………………………….….….…………１００\nヨーダ記法.……….………..……….……………………………８５\n読み手の立場….…………………………….….……….………６３\n読みやすさ……………….…………………………………………３\n\nへ\n\nら\n\nベルトコンベヤー設計……………….…………………….２０５\n変数………………..……………….….……………………･……１１２\n書き込む….….…………………….……….…………….１２３\n\nほ\n\n包含／排他的範囲.…………….………………………………３３\nボトムアップ…………………………………………………..１３６\n\nま\n\nマクロを定義…….…….……..……..………･…………･……107\n\nみ\n\nライターズブロック.……………….….…………………….､６８\nライブラリ.…….…………………………………….…………１７２\n再利用….………………………………….…….…………１７３\n知る…………………………………………………………１５９\nラバーダッキング…………….…….…………………….…１６５\n\nり\n\nリファクタリング………….………………….…………….１４１\n\nる\n\nループイテレータ…….……………………………………….１４\nループ内部、ネストを削除…………………………..……９５\n\nミー三・言五，一に,I,ｎ.…………………………………….………….………１８３\n\nろ\n\nめ\n\nロジック………….………………..……………………………１５８\n\nメソッド、整列…………………………………………………４６\n面接…….………….…….…………………………………….….１１５\n\nも\n\n問題点…….…….…….………………………..………….….…１９８\n\nわ\n\n良を告知……………….…….………….……….………….……６４\n\n','索引ʼ  ふ  や  プール値  フォーマット  名前…………………….………………….…………………  名前.…………..……………………………….……………. フォーマット規約………………..…………………….､ 複数の名前……………….………….…………….…………….､ ブロックにまとめる、宣言.….………..……….………… 文、分割.…………………………….………………………･… 分割  巨大な文….……………………………………….……… 質問と要求..….……….……….……….….…………… 分時間カウンタ….………….………………………….… 文章を磨く.…………..……………....…….……………………  やりすぎ…………………………….……..……………………  ゆ  ユーザの期待…….………………………………………………  よ  要約コメント……………………………………………………. 要約変数……………………………………….….….………… ヨーダ記法.……….………..……….…………………………… 読み手の立場….…………………………….….……….……… 読みやすさ……………….…………………………………………  へ  ら  ベルトコンベヤー設計……………….……………………. 変数………………..……………….….……………………･…… 書き込む….….…………………….……….…………….  ほ  包含排他的範囲.…………….……………………………… ボトムアップ…………………………………………………..  ま  マクロを定義…….…….……..……..………･…………･……  み  ライターズブロック.……………….….…………………….､ ライブラリ.…….…………………………………….………… 再利用….………………………………….…….………… 知る………………………………………………………… ラバーダッキング…………….…….…………………….…  り  リファクタリング………….………………….…………….  る  ループイテレータ…….………………………………………. ループ内部、ネストを削除…………………………..……  ミー三・言五一に,I,ｎ.…………………………………….………….………  ろ  め  ロジック………….………………..……………………………  メソッド、整列………………………………………………… 面接…….………….…….…………………………………….….  も  問題点…….…….…….………………………..………….….…  わ  良を告知……………….…….………….……….………….……  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(243,1,242,'●著者について\nDustin Bosweil (ダスティン・ボズウェル）\nサーカスで育てられたが、アクロバットよりコンピュータが向いていることに気づい\nて、カリフォルニアエ科大学で理学士号を取得。コンピュータサイエンスに夢中にな\nる。その後、カリフオルニア大学サンデイエゴ校で修士号を取得。Google社で５年\n間勤務し、ウェブクローリング用のインフラなどさまざまなプロジェクトに携わる。\n現在は、インターネットスタートアップ企業が大好きで、暇なときにはサンタモニカ\n山地をハイキングしている。新米パパ。\n\nTrevor Foucher (トレバー・フォシェ）\n１０年以上もの間、Microsoft社でWindows  2000やOneCare，Google社でWeb\nmaster  Toolsなどのソフトウェアプロジェクトを送り出してきた。現在は独立コン\nトリビュータ・マネージャ・テクニカルリードである。コードを読みやすく信頼でき\nるものにすることが目標だ。\n\n●訳者紹介\n角征典(Masanori Kado a.k.a kdmsnr)\n1978年山口県生まれのプログラマ。訳書に『Clean Coder]  (アスキー・メデイア\nワークス)、『随cebookマーケティング』（アスキー・メディアワークス)、「ウェブ\nオペレーション』（オライリー・ジャパン)、「メタプログラミングRubyJ (アスキー・\nメディアワークス)、『アジャイルレトロスペクテイブズ』（オーム社）がある。\n\n','●著者について Dustin Bosweil (ダスティン・ボズウェル サーカスで育てられたが、アクロバットよりコンピュータが向いていることに気づい て、カリフォルニアエ科大学で理学士号を取得。コンピュータサイエンスに夢中にな る。その後、カリフオルニア大学サンデイエゴ校で修士号を取得。Google社で年 間勤務し、ウェブクローリング用のインフラなどさまざまなプロジェクトに携わる。 現在は、インターネットスタートアップ企業が大好きで、暇なときにはサンタモニカ 山地をハイキングしている。新米パパ。  Trevor Foucher (トレバー・フォシェ 年以上もの間、Microsoft社でWindows  やOneCareGoogle社でWeb master  Toolsなどのソフトウェアプロジェクトを送り出してきた。現在は独立コン トリビュータ・マネージャ・テクニカルリードである。コードを読みやすく信頼でき るものにすることが目標だ。  ●訳者紹介 角征典(Masanori Kado a.k.a kdmsnr) 年山口県生まれのプログラマ。訳書に『Clean Coder]  (アスキー・メデイア ワークス)、『随cebookマーケティング』アスキー・メディアワークス)、「ウェブ オペレーション』オライリー・ジャパン)、「メタプログラミングRubyJ (アスキー・ メディアワークス)、『アジャイルレトロスペクテイブズ』オーム社がある。  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(244,1,243,'本書は著作権上の保護を受けています。本書の一部あるいは全部について、株式会社オライリー・ジャ\nパンから文書による許諾を得ずに、いかなる方法においても無断で複写、複製することは禁じられて\nいます。\n\nリーダブルコード\n­より良いコードを書くためのシンプルで実践的なテクニック\n\n2012年６月２２日\n2017年１月１０日\n\n初版第１刷発行\n初版第２０刷発行\n\n行\n印刷・\n発 行\n\nDus伽Bosweil (ダスティン・ボズウェル）\nTrevor Foucher (トレバー・フォシェ）\n角征典（かどまさのり）\nテイム・オライリー\n日経印刷株式会社\n株式会社オライリー・ジャパン\n〒1600002束京都新宿区四谷坂町１２番22号\n\'\n1℃１（03)33565227\nFax  (03)3356-5263\n電子メールjapan@oreilly.co.jp\n株式会社オーム社\n〒101-8460束京都千代田区神田錦町3-1\n\'\n1℃1    (03)3233-0641 (代表）\nFax   (03)3233-3440\nPrinted in Japan (ISBN978-4-87311-565-8)\n乱丁、落丁の際はお取り替えいたします。\n\n者 人 本 所\n\n著\n\n訳 発\n\n者\n\n製\n\n発\n\n売\n\n元\n\n','本書は著作権上の保護を受けています。本書の一部あるいは全部について、株式会社オライリー・ジャ パンから文書による許諾を得ずに、いかなる方法においても無断で複写、複製することは禁じられて います。  リーダブルコード ­より良いコードを書くためのシンプルで実践的なテクニック  年月日 年月日  初版第刷発行 初版第刷発行  行 印刷・ 発 行  Dus伽Bosweil (ダスティン・ボズウェル Trevor Foucher (トレバー・フォシェ 角征典かどまさのり テイム・オライリー 日経印刷株式会社 株式会社オライリー・ジャパン 〒束京都新宿区四谷坂町番号 \' ℃) Fax  ()- 電子メールjapan 株式会社オーム社 〒-束京都千代田区神田錦町- \' ℃    ()- (代表 Fax   ()- Printed in Japan (ISBN----) 乱丁、落丁の際はお取り替えいたします。  者 人 本 所  著  訳 発  者  製  発  売  元  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(245,1,244,'r舵Art ofReadabﾉe Code\nリーダブルコード\nーより良いコードを書くためのシンプルで実践的なテクニック\n\n美しいコードを見ると感動する。優れたコードは見た|瞬間に何をＬ\nているかが伝わってくる。そういうコードは使うのが架しいし、自\n分のコードもそうあるべきだと思わせてくれる。本書のII的は、君\nのコードを良くすることだ。（本書『はじめに」より）\nコードは理解しやすくなければならない。本書はこの原則を日々の\nコーディングの様々な場面に当てはめる方法を紹介する。名前の付\nけ方､コメントの書き方など表面上の改善について。コードを動か\nすための制御フロー、論理式、変数などループとロジックについ\nて。またコードを再構成するための方法。さらにテストの書き方な\nどについて､楽しいイラストと共に説明する。Ⅱ本語版ではRuby^\neroongaのコミッタとしても著名な須藤功平氏による解説を収録。\n\n○REILLY^発行所／オライリー・ジャパン\n\n','r舵Art ofReadabﾉe Code リーダブルコード ーより良いコードを書くためのシンプルで実践的なテクニック  美しいコードを見ると感動する。優れたコードは見た|瞬間に何をＬ ているかが伝わってくる。そういうコードは使うのが架しいし、自 分のコードもそうあるべきだと思わせてくれる。本書のII的は、君 のコードを良くすることだ。本書『はじめに」より コードは理解しやすくなければならない。本書はこの原則を日々の コーディングの様々な場面に当てはめる方法を紹介する。名前の付 け方､コメントの書き方など表面上の改善について。コードを動か すための制御フロー、論理式、変数などループとロジックについ て。またコードを再構成するための方法。さらにテストの書き方な どについて､楽しいイラストと共に説明する。Ⅱ本語版ではRuby^ eroongaのコミッタとしても著名な須藤功平氏による解説を収録。  ○REILLY^発行所オライリー・ジャパン  ','2017-11-20 15:02:20','2017-11-20 15:02:20'),(246,1,245,'ISBN978-4-873I  1-565-8\n\nC3055      ¥2400E\n\n９７８４８７３１１５６５８\n\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n\'\n１1９２３０５５０２４００７\n\'\n\'\n\'\n\nThe Art ofReadabﾉe Code\nリーダブルコード\nーより良いコードを書くためのシンプルで実践的なテクニック\n\n美しいコードを見ると感動する。優れたコードは見た|瞬間に何をし\nているかが伝わってくる。そういうコードは使うのが楽しいし、自\n分のコードもそうあるべきだと思わせてくれる。本書の目的は、君\nのコードを良くすることだ。（本書｢はじめに」より）\nコードは理解しやすくなければならない。本書はこの原則をｌ１々の\nコーディングの様々な場面に当てはめる方法を紹介する。名前の付\nけ方､コメントの書き方など表面上の改善について。コードを動か\nすための制御フロー、論理式、変数などループとロジックについ\nて。またコードを再構成するための方法。さらにテストの書き方な\nどについて､楽しいイラストと共に説|ﾘＩする。日本語版ではRuby^\ngroongaのコミッタとしても著名な須藤功平氏による解説を収録。\n\n○\'REILLY^発行所／オライリー・ジャパン\n\n○hmsha\n\n発売元／オーム社\n定価（本体2,400円十税1\n\n','ISBN--I  --  C      ¥E    \' \' \' \' \' \' \' \' \' \' \' \' \' \' \' \' \' \' \'  \' \' \'  The Art ofReadabﾉe Code リーダブルコード ーより良いコードを書くためのシンプルで実践的なテクニック  美しいコードを見ると感動する。優れたコードは見た|瞬間に何をし ているかが伝わってくる。そういうコードは使うのが楽しいし、自 分のコードもそうあるべきだと思わせてくれる。本書の目的は、君 のコードを良くすることだ。本書｢はじめに」より コードは理解しやすくなければならない。本書はこの原則をｌ々の コーディングの様々な場面に当てはめる方法を紹介する。名前の付 け方､コメントの書き方など表面上の改善について。コードを動か すための制御フロー、論理式、変数などループとロジックについ て。またコードを再構成するための方法。さらにテストの書き方な どについて､楽しいイラストと共に説|ﾘＩする。日本語版ではRuby^ groongaのコミッタとしても著名な須藤功平氏による解説を収録。  ○\'REILLY^発行所オライリー・ジャパン  ○hmsha  発売元オーム社 定価本体,円十税  ','2017-11-20 15:02:20','2017-11-20 15:02:20');
/*!40000 ALTER TABLE `pages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `vectors`
--

DROP TABLE IF EXISTS `vectors`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `vectors` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `book_id` int(11) NOT NULL,
  `page_id` int(11) DEFAULT NULL,
  `vec_type` varchar(30) DEFAULT NULL,
  `vec_target` varchar(30) DEFAULT NULL,
  `vector` text,
  `created` datetime NOT NULL,
  `modified` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `book_id` (`book_id`),
  KEY `page_id` (`page_id`),
  CONSTRAINT `vectors_ibfk_1` FOREIGN KEY (`book_id`) REFERENCES `books` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `vectors_ibfk_2` FOREIGN KEY (`page_id`) REFERENCES `pages` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `vectors`
--

LOCK TABLES `vectors` WRITE;
/*!40000 ALTER TABLE `vectors` DISABLE KEYS */;
/*!40000 ALTER TABLE `vectors` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-12-21 20:03:15
